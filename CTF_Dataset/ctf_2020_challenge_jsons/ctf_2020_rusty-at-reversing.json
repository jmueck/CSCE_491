{
    ".gitignore": "target/\n.idea/\nvenv/\nCargo.lock\n",
    "build.sh": "#!/bin/bash\n\ncargo clean\nRUSTFLAGS='-C link-arg=-s' cargo +nightly build --release\n",
    "Cargo.toml": "[package]\nname = \"rusty-at-reversing\"\nversion = \"0.1.0\"\nauthors = [\"Addison Crump <addisoncrump@tamu.edu>\"]\nedition = \"2018\"\n\n[profile.dev]\nopt-level = 0\n\n[profile.release]\nopt-level = 0\ncodegen-units = 1\n\n[lib]\ncrate-type = [\"cdylib\"]\n",
    "Dockerfile.builder": "FROM rust:slim\n\nRUN rustup install nightly",
    "docker_build.sh": "#!/bin/bash\n\ndocker build -t rust-nightly . -f Dockerfile.builder\ndocker run --rm --user \"$(id -u)\":\"$(id -g)\" -v \"$PWD\":/usr/src/rusty-at-reversing -w /usr/src/rusty-at-reversing rust-nightly ./build.sh\n",
    "link_solution.c": "#include \"stdio.h\"\n\nlong * get_flag(long * param_1, char * param_2, size_t * param_3, long param_4, size_t param_5);\n\nint main() {\n    char flag[28];\n    get_flag((long *) flag, NULL, NULL, 0, 0);\n    printf(\"%.28s\\n\", flag);\n}",
    "README.md": "# Rusty at Reversing?\n\nShared object rust reversal with no standard libraries packed in (I mean none).\n\n## Design\n\nActually there's a lot of really careful flags to ensure that:\n1. The library looks like a typical Rust binary (with safety checks) and not like pure C.\n   - If you want to see the difference for personal edification, change `opt-level` to `'z'`.\n2. The library has some extraneous functions but not the standard lib.\n   - If you want to see the difference, add `lto = true` under `[profile.release]`.\n3. The library can be analysed by most reverse engineering frameworks relatively trivially.\n   - If you want to see the difference:\n     - Change the `loop` block with `if i == 28...` to a `for i in 0..28` (LLVM unrolling)\n     - Change `cdylib` to `dylib` in `Cargo.toml`\n3. Function names are not mangled so that users can actually find the right functions.\n   - If you want to see the difference, remove `#[no_mangle]`.\n4. The .so file isn't enormous.\n   - `#[no_mangle]` enforces that the debug symbols remain for those functions, so we can strip the binary.\n   - To see the difference, remove `RUSTFLAGS='-C link-args=-s'`\n\nAmusingly, these changes seem to really confuse Rust and lead to some odd choices in the reversed binary.\n\n## Solution 1: Linking, like a madlad\n\nIf you were an absolute madlad, you could just choose to link a C program to the functions. I have provided this\nsolution for personal edification. This is not particularly difficult but I doubt it would occur to most at first.\n\nMake sure you build with `gcc link_solution.c target/release/librusty_at_reversing.so`.\n\n## Solution 2: Reversing\n\nLet's do the intended solution: manual labour.\n\n### Reversing the get_flag function\n\nPop the library open in Ghidra and, lo!:\n\n![](assets/functions.png)\n\nTraverse into it a bit and we find:\n1. A huge block of bytes (indicating an array of some sort) and\n2. A call to `decrypt` passing a pointer to the first byte of our block.\n\n![](assets/decrypt_call.png)\n\n### Reversing the decrypt function\n\nBelow is the entire decompiled `decrypt` function here:\n\n![](assets/decrypt.png)\n\nNow, remember how I said that compiling like this made Rust unhappy? The repeated bounds checks and parameters\nabove demonstrate that pretty well. The do-while bounds prevent this condition from occurring, and these would normally\nbe optimised out by LLVM.\n\nDiscarding the bounds checks and the unused parameters, this function is quite straightforward. To write some\npseudocode:\n\n```text\nlocal_9 = 0xe4\nlocal_8 = 0\ndo {\n    EVar1 = ctx[local_8]\n    ctx[local_8] = local_9 ^ ctx[local_8]\n    local_8++\n    local_9 = EVar1;\n} while (local_8 != 0x1c)\n```\n\nThis appears to be a simple dragging XOR. This do-while can additionally be turned into a for loop quite trivially.\n\n### Getting the flag\n\nWe'll write a C implementation because Ghidra provides us with a pretty neat decompiler utility.\n\nFirst, we retype local_1c to a byte[28] and rename it to flag:\n\n![](assets/retyping.png)\n\nWe then copy this over to our solution file to construct our main (fixing the last entry little-endianly):\n\n```\nint main() {\n    char flag [28];\n\n    flag[0] = 0x83;\n    flag[1] = 0xea;\n    flag[2] = 0x8d;\n    flag[3] = 0xe8;\n    flag[4] = 0x85;\n    flag[5] = 0xfe;\n    flag[6] = 0x93;\n    flag[7] = 0xe1;\n    flag[8] = 0xbe;\n    flag[9] = 0xcd;\n    flag[10] = 0xb9;\n    flag[11] = 0xd8;\n    flag[12] = 0xaa;\n    flag[13] = 0xc1;\n    flag[14] = 0x9e;\n    flag[15] = 0xf7;\n    flag[16] = 0xa8;\n    flag[17] = 0xce;\n    flag[18] = 0xab;\n    flag[19] = 0xce;\n    flag[20] = 0xa2;\n    flag[21] = 0xfd;\n    flag[22] = 0x8f;\n    flag[23] = 0xfa;\n    flag[24] = 0x89;\n    flag[25] = 0xfd;\n    flag[26] = 0x84;\n    flag[27] = 0xf9;\n\n    decrypt(&flag);\n    printf(\"%.28s\\n\", flag);\n}\n```\n\nThen, using our pseudocode from earlier, we write the decrypt function:\n\n```\nvoid decrypt(char *flag) {\n    char temp;\n    char local_9 = 0xe4;\n    char local_8 = 0;\n    for (int i = 0; i < 28; i++) {\n        temp = flag[i];\n        flag[i] = local_9 ^ flag[i];\n        local_8++;\n        local_9 = temp;\n    }\n}\n```\n\nBundling it all together and compiling, we get the flag. You can compile `solution.c` to this result.",
    "solution.c": "#include \"stdio.h\"\n\nvoid decrypt(char *flag) {\n    char temp;\n    char local_9 = 0xe4;\n    for (int local_8 = 0; local_8 < 28; local_8++) {\n        temp = flag[local_8];\n        flag[local_8] = local_9 ^ flag[local_8];\n        local_9 = temp;\n    }\n}\n\nint main() {\n    char flag [28];\n\n    flag[0] = 0x83;\n    flag[1] = 0xea;\n    flag[2] = 0x8d;\n    flag[3] = 0xe8;\n    flag[4] = 0x85;\n    flag[5] = 0xfe;\n    flag[6] = 0x93;\n    flag[7] = 0xe1;\n    flag[8] = 0xbe;\n    flag[9] = 0xcd;\n    flag[10] = 0xb9;\n    flag[11] = 0xd8;\n    flag[12] = 0xaa;\n    flag[13] = 0xc1;\n    flag[14] = 0x9e;\n    flag[15] = 0xf7;\n    flag[16] = 0xa8;\n    flag[17] = 0xce;\n    flag[18] = 0xab;\n    flag[19] = 0xce;\n    flag[20] = 0xa2;\n    flag[21] = 0xfd;\n    flag[22] = 0x8f;\n    flag[23] = 0xfa;\n    flag[24] = 0x89;\n    flag[25] = 0xfd;\n    flag[26] = 0x84;\n    flag[27] = 0xf9;\n\n    decrypt(&flag);\n    printf(\"%.28s\\n\", flag);\n}\n",
    "assets\\decrypt.png": "[Binary file or unsupported type: png]",
    "assets\\decrypt_call.png": "[Binary file or unsupported type: png]",
    "assets\\functions.png": "[Binary file or unsupported type: png]",
    "assets\\retyping.png": "[Binary file or unsupported type: png]",
    "src\\lib.rs": "#![feature(lang_items)]\n#![no_std]\n\nuse core::panic::PanicInfo;\n\nstatic INIT_XOR: u8 = (2020 & 255) as u8;\n\n#[no_mangle]\nfn encrypt(enc: &mut [u8; 28]) {\n    let mut prev = INIT_XOR;\n    let mut i = 0;\n    loop { // required to prevent LLVM unrolling\n        enc[i] = prev ^ enc[i];\n        prev = enc[i];\n        i += 1;\n        if i == 28 { break; }\n    }\n}\n\n#[no_mangle]\nfn decrypt(enc: &mut [u8; 28]) {\n    let mut prev: u8;\n    let mut curr = INIT_XOR;\n    let mut i = 0;\n    loop { // required to prevent LLVM unrolling\n        prev = curr;\n        curr = enc[i];\n        enc[i] = prev ^ enc[i];\n        i += 1;\n        if i == 28 { break; }\n    }\n}\n\n#[no_mangle]\nfn get_flag() -> [u8; 28] {\n    let mut flag: [u8; 28] = [131, 234, 141, 232, 133, 254, 147, 225, 190, 205, 185, 216, 170, 193, 158, 247, 168, 206, 171, 206, 162, 253, 143, 250, 137, 253, 132, 249];\n    decrypt(&mut flag);\n    flag\n}\n\n#[panic_handler]\nfn panic_handler(_info: &PanicInfo) -> ! { loop {} }\n\n#[lang = \"eh_personality\"]\nextern \"C\" fn eh_personality() {}\n\n//#[lang = \"panic_fmt\"]\n//extern \"C\" fn panic_fmt() -> ! { loop {} }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    static FLAG: &'static str = \"gigem{mr_stark_i_feel_rusty}\";\n\n//    #[test]\n//    fn encrypt_flag() {\n//        let mut flag_arr = [0; 28];\n//        flag_arr.copy_from_slice(FLAG.as_bytes());\n//        encrypt(&mut flag_arr);\n//        println!(\"{:?}\", flag_arr);\n//    }\n\n    #[test]\n    fn encrypt_decrypt_match() {\n        let mut flag_arr = [0; 28];\n        flag_arr.copy_from_slice(FLAG.as_bytes());\n        encrypt(&mut flag_arr);\n        decrypt(&mut flag_arr);\n        for i in 0..flag_arr.len() {\n            assert_eq!(FLAG.as_bytes()[i], flag_arr[i]);\n        }\n    }\n\n    #[test]\n    fn get_flag_match() {\n        let flag_arr = get_flag();\n        for i in 0..flag_arr.len() {\n            assert_eq!(FLAG.as_bytes()[i], flag_arr[i]);\n        }\n    }\n}\n",
    "category": "Reversing"
}