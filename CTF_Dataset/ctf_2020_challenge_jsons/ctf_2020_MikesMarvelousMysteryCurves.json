{
    "key_exchange.pcap": "[Binary file or unsupported type: pcap]",
    "README.md": "# Elliptic Curve Diffie Hellman key exchange exploit\n## Challenge\nMike, the System Administrator, thought it would be a good idea to implement his own Elliptic Curve Diffie Hellman key exchange using unnamed curves to use across the network. \nWe managed to capture TCP traffic of the unencrypted key exchange along with an encrypted file exchange. See if you can read the contents of that file.\n\nHint: The password to the AES256-CBC encrypted file is the shared key in the ECDH key exchange. It is the string representation of the x coordinate concatenated with the y coordinate of the shared key.\n\tExample: \n\t\tshared key: (12345,67890)\n\t\tpassword: 1234567890\nMike forgot to include the order of the points on the curve in his homemade certificates.\n\n## Setup\nPlayers are given ecdhKeyExchange.pcap\n\n\n## Solution\nIn the \"solution\" directory, there are 2 files, aesDecrypter.py and sharedKeySolver.py\n1. Open up the pcap in whichever app you prefer (I like wireshark)\n2. There are 3 TCP streams. The first two have certificates in them and the third one has a file transfer.\n3. The 2 certificate are just fake x509 certs encoded in base64. Not actually an ssl certificate. Decode those base64.\n4. Get the information for the elliptic curve in the cert: \n\ty^2 = x^3 + 10717230661382162362098424417014722231813x + 22043581253918959176184702399480186312 mod 412220184797\n5. And the generator point(they're the same for both): \n\tG = (56797798272,349018778637)\n6. Gather the public key from both: \n\tPubA = (61801292647,228288385004) \n\tPubB = (196393473219,35161195210)\n7. Calculate the order of either point. They should be the same. The library I used utilizes Shank's algorithm to complete this task: \n\tIn \"sharedKeySolver.py\", this is done with the function computeOrder()\n\tOrder = 137406875064\n8. Figure out either one of private keys using the Pohlig-Hellman algorithm with the Chinese Remainder theorem to solve this discrete logarithm problem:\n\tPrivA = 54628069049 \n\tPrivB = 6895697291\n9. Use that private key to generate the shared secret by finishing the last step in the elliptic curve diffie hellman key exchange: \n\tshared secret = (PrivA * PubB) or (PrivB * PubA) = (130222573707,242246159397)\n\t\t- (where * is elliptic curve point multiplication)\n10. Form the password by concatenating the x and y values from the shared secret:\n\tpassword = 130222573707242246159397\n11. Save the raw data from TCP stream 2 (the third one) as a file.\n12. Decrypt the AES256-CBC encrypted file with the password.\n13. Cat the decrypted file and grep gigem for the flag:\n\tgigem{Forty-two_said_Deep_Thought}\n",
    "client\\cert": "Certificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number:\n            a8:49:ac:8c:84:0f:84:ce\n    Signature Algorithm: ecdsa-with-SHA256\n        Issuer: C = US, ST = Texas, L = College Station, O = Texas A&M University, OU = tamuCTF, CN = Bob, emailAddress = bob@tamuctf.edu\n        Validity\n            Not Before: Oct  9 13:15:35 2018 GMT\n            Not After : Nov  8 13:15:35 2018 GMT\n        Subject: C = US, ST = Texas, L = College Station, O = Texas A&M University, OU = tamuCTF, CN = Bob, emailAddress = bob@tamuctf.edu\n        Subject Public Key Info:\n            Public Key Algorithm: id-ecPublicKey\n                Public-Key:\n                    196393473219\n                    35161195210\n                ASN1 OID: badPrime96v4\n                CURVE: JustNo\n                    Field Type: prime-field\n                    Prime:\n                        412220184797\n                    A:   \n                        10717230661382162362098424417014722231813\n                    B:   \n                        22043581253918959176184702399480186312\n                    Generator:\n                        56797798272\n                        349018778637\n        X509v3 extensions:\n            X509v3 Subject Key Identifier: \n                84:25:43:45:2C:0C:7E:1C:85:BC:E9:AF:44:BE:42:A1:84:D6:D2:27\n            X509v3 Authority Key Identifier: \n                keyid:84:25:43:45:2C:0C:7E:1C:85:BC:E9:AF:44:BE:42:A1:84:D6:D2:27\n\n            X509v3 Basic Constraints: critical\n                CA:TRUE\n    Signature Algorithm: ecdsa-with-SHA256\n         30:46:02:21:00:d4:45:84:18:e3:06:8d:bb:3b:e9:4d:68:a9:\n         56:f4:af:e0:28:23:26:7d:4d:1e:84:2b:e8:c4:d3:ac:85:a9:\n         c8:02:21:00:e9:ef:bc:0d:fa:3a:85:c4:39:1a:16:3b:6a:c0:\n         6a:3f:ac:f2:7a:5f:49:ea:86:e4:18:5e:ac:91:75:31:b3:5b\n",
    "client\\client.py": "#!/usr/bin/env python3\nimport socket,base64\nfrom Crypto.Cipher import AES\nfrom elliptic import *\nfrom finitefield.finitefield import FiniteField\n\nimport os\n\n\ndef generate_private_key(numBits):\n    return int.from_bytes(os.urandom(numBits // 8), byteorder='big')\n\n\ndef generate_public_key(privateKey, generator, pubFunction):\n    return pubFunction(privateKey * generator)\n\n\ndef generate_shared_secret(privateKey, sharedFunction):\n    return privateKey * sharedFunction()\n\nif __name__ == \"__main__\":\n    #TCP_IP = 'localhost'\n    TCP_IP = '192.168.11.4'\n    TCP_PORT = 5005\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((TCP_IP,TCP_PORT))\n\n    with open('cert','r') as cert:\n        data = cert.read()\n    encodeddata = \"-----BEGIN CERTIFICATE-----\\n\" + str(base64.b64encode(data.encode('utf-8')).decode('utf-8')) + \"\\n-----END CERTIFICATE-----\"\n    #Curve Exchange info\n    F = FiniteField(412220184797, 1)\n    curve = EllipticCurve(a=F(10717230661382162362098424417014722231813), b=F(22043581253918959176184702399480186312))\n    G = Point(curve, F(56797798272), F(349018778637))\n    s.recv(1024)\n    s.close()\n    s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s1.connect((TCP_IP,TCP_PORT))\n    s1.sendall(encodeddata.encode('utf-8'))\n    s1.close()\n\n    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s2.connect((TCP_IP,TCP_PORT))\n\n    #Private key:\n    private_key = 6895697291\n\n    #Public key: (196393473219,35161195210) order 137406875064\n    public_key = generate_public_key(private_key, G, lambda x:x)\n\n    #Key exchange\n    peer_public_key = Point(curve,F(61801292647),F(228288385004))\n\n    #Generate shared key\n    shared_secret = generate_shared_secret(private_key, lambda: peer_public_key)\n    print(str(shared_secret))\n    secret_password = str(shared_secret.x.n) + str(shared_secret.y.n)\n    print(secret_password)\n\n    #Receive encrypted file and decrypt it\n    with open('flag.txt.aes', 'wb') as f:\n        while True:\n            data = s2.recv(1024)\n            if not data:\n                break\n            # write data to a file\n            f.write(data)\n    f.close()\n    s2.close()\n    print('connection closed')\n    with open('flag.txt.aes','rb') as encrypted_file:\n        encrypted_flag = encrypted_file.read()\n    decryption_suite = AES.new(secret_password,AES.MODE_CBC,'0000000000000000')\n    flag = decryption_suite.decrypt(encrypted_flag)\n    with open('flag.txt','wb') as flag_file:\n        flag_file.write(flag)\n",
    "client\\Dockerfile": "FROM python:3.6.6-stretch\n\nRUN apt-get update && apt-get install -y \\\n    apt-utils \\\n    build-essential\nRUN pip install pyAesCrypt\nCOPY ./cert ./cert\nCOPY ./client.py ./client.py\nCOPY ./elliptic.py ./elliptic.py\nCOPY ./finitefield ./finitefield\nCOPY ./__pycache__ ./__pycache__\nEXPOSE 5005\nENTRYPOINT [\"python\",\"./client.py\"]\n",
    "client\\elliptic.py": "\nclass EllipticCurve(object):\n   def __init__(self, a, b):\n      # assume we're already in the Weierstrass form\n      self.a = a\n      self.b = b\n\n      self.discriminant = -16 * (4 * a*a*a + 27 * b * b)\n      if not self.isSmooth():\n         raise Exception(\"The curve %s is not smooth!\" % self)\n\n\n   def isSmooth(self):\n      return self.discriminant != 0\n\n\n   def testPoint(self, x, y):\n      return y*y == x*x*x + self.a * x + self.b\n\n\n   def __str__(self):\n      return 'y^2 = x^3 + %sx + %s' % (self.a, self.b)\n\n\n   def __repr__(self):\n      return str(self)\n\n\n   def __eq__(self, other):\n      return (self.a, self.b) == (other.a, other.b)\n\n\n\nclass Point(object):\n   def __init__(self, curve, x, y):\n      self.curve = curve # the curve containing this point\n      self.x = x\n      self.y = y\n\n      if not curve.testPoint(x,y):\n         raise Exception(\"The point %s is not on the given curve %s!\" % (self, curve))\n\n\n   def __str__(self):\n      return \"(%r, %r)\" % (self.x, self.y)\n\n\n   def __repr__(self):\n      return str(self)\n\n\n   def __neg__(self):\n      return Point(self.curve, self.x, -self.y)\n\n\n   def __add__(self, Q):\n      if self.curve != Q.curve:\n         raise Exception(\"Can't add points on different curves!\")\n      if isinstance(Q, Ideal):\n         return self\n\n      x_1, y_1, x_2, y_2 = self.x, self.y, Q.x, Q.y\n\n      if (x_1, y_1) == (x_2, y_2):\n         if y_1 == 0:\n            return Ideal(self.curve)\n\n         # slope of the tangent line\n         m = (3 * x_1 * x_1 + self.curve.a) / (2 * y_1)\n      else:\n         if x_1 == x_2:\n            return Ideal(self.curve)\n\n         # slope of the secant line\n         m = (y_2 - y_1) / (x_2 - x_1)\n\n      x_3 = m*m - x_2 - x_1\n      y_3 = m*(x_3 - x_1) + y_1\n\n      return Point(self.curve, x_3, -y_3)\n\n\n   def __sub__(self, Q):\n      return self + -Q\n\n   def __mul__(self, n):\n      if not isinstance(n, int):\n         raise Exception(\"Can't scale a point by something which isn't an int!\")\n      else:\n         if n < 0:\n             return -self * -n\n         if n == 0:\n             return Ideal(self.curve)\n         else:\n             Q = self\n             R = self if n & 1 == 1 else Ideal(self.curve)\n\n             i = 2\n             while i <= n:\n                 Q = Q + Q\n\n                 if n & i == i:\n                     R = Q + R\n\n                 i = i << 1\n\n             return R\n\n\n   def __rmul__(self, n):\n      return self * n\n\n   def __list__(self):\n      return [self.x, self.y]\n\n   def __eq__(self, other):\n      if type(other) is Ideal:\n         return False\n\n      return (self.x, self.y) == (other.x, other.y)\n\n   def __ne__(self, other):\n      return not self == other\n\n   def __getitem__(self, index):\n      return [self.x, self.y][index]\n\n\nclass Ideal(Point):\n   def __init__(self, curve):\n      self.curve = curve\n\n   def __neg__(self):\n      return self\n\n   def __str__(self):\n      return \"Ideal\"\n\n   def __add__(self, Q):\n      if self.curve != Q.curve:\n         raise Exception(\"Can't add points on different curves!\")\n      return Q\n\n   def __mul__(self, n):\n      if not isinstance(n, int):\n         raise Exception(\"Can't scale a point by something which isn't an int!\")\n      else:\n         return self\n\n   def __eq__(self, other):\n      return type(other) is Ideal\n\n",
    "client\\finitefield\\euclidean.py": "\n# a general Euclidean algorithm for any number type with\n# a divmod and a valuation abs() whose minimum value is zero\ndef gcd(a, b):\n   if abs(a) < abs(b):\n      return gcd(b, a)\n\n   while abs(b) > 0:\n      _,r = divmod(a,b)\n      a,b = b,r\n\n   return a\n\n\n# extendedEuclideanAlgorithm: int, int -> int, int, int\n# input (a,b) and output three numbers x,y,d such that ax + by = d = gcd(a,b).\n# Works for any number type with a divmod and a valuation abs()\n# whose minimum value is zero\ndef extendedEuclideanAlgorithm(a, b):\n   if abs(b) > abs(a):\n      (x,y,d) = extendedEuclideanAlgorithm(b, a)\n      return (y,x,d)\n\n   if abs(b) == 0:\n      return (1, 0, a)\n\n   x1, x2, y1, y2 = 0, 1, 1, 0\n   while abs(b) > 0:\n      q, r = divmod(a,b)\n      x = x2 - q*x1\n      y = y2 - q*y1\n      a, b, x2, x1, y2, y1 = b, r, x1, x, y1, y\n\n   return (x2, y2, a)\n\n",
    "client\\finitefield\\finitefield.py": "import random\nfrom .polynomial import polynomialsOver\nfrom .modp import *\n\n\n\n# isIrreducible: Polynomial, int -> bool\n# determine if the given monic polynomial with coefficients in Z/p is\n# irreducible over Z/p where p is the given integer\n# Algorithm 4.69 in the Handbook of Applied Cryptography\ndef isIrreducible(polynomial, p):\n   ZmodP = IntegersModP(p)\n   if polynomial.field is not ZmodP:\n      raise TypeError(\"Given a polynomial that's not over %s, but instead %r\" %\n                        (ZmodP.__name__, polynomial.field.__name__))\n\n   poly = polynomialsOver(ZmodP).factory\n   x = poly([0,1])\n   powerTerm = x\n   isUnit = lambda p: p.degree() == 0\n\n   for _ in range(int(polynomial.degree() / 2)):\n      powerTerm = powerTerm.powmod(p, polynomial)\n      gcdOverZmodp = gcd(polynomial, powerTerm - x)\n      if not isUnit(gcdOverZmodp):\n         return False\n\n   return True\n\n\n# generateIrreduciblePolynomial: int, int -> Polynomial\n# generate a random irreducible polynomial of a given degree over Z/p, where p\n# is given by the integer 'modulus'. This algorithm is expected to terminate\n# after 'degree' many irreducilibity tests. By Chernoff bounds the probability\n# it deviates from this by very much is exponentially small.\ndef generateIrreduciblePolynomial(modulus, degree):\n   Zp = IntegersModP(modulus)\n   Polynomial = polynomialsOver(Zp)\n\n   while True:\n      coefficients = [Zp(random.randint(0, modulus-1)) for _ in range(degree)]\n      randomMonicPolynomial = Polynomial(coefficients + [Zp(1)])\n      print(randomMonicPolynomial)\n\n      if isIrreducible(randomMonicPolynomial, modulus):\n         return randomMonicPolynomial\n\n\n# create a type constructor for the finite field of order p^m for p prime, m >= 1\n@memoize\ndef FiniteField(p, m, polynomialModulus=None):\n   Zp = IntegersModP(p)\n   if m == 1:\n      return Zp\n\n   Polynomial = polynomialsOver(Zp)\n   if polynomialModulus is None:\n      polynomialModulus = generateIrreduciblePolynomial(modulus=p, degree=m)\n\n   class Fq(FieldElement):\n      fieldSize = int(p ** m)\n      primeSubfield = Zp\n      idealGenerator = polynomialModulus\n      operatorPrecedence = 3\n\n      def __init__(self, poly):\n         if type(poly) is Fq:\n            self.poly = poly.poly\n         elif type(poly) is int or type(poly) is Zp:\n            self.poly = Polynomial([Zp(poly)])\n         elif isinstance(poly, Polynomial):\n            self.poly = poly % polynomialModulus\n         else:\n            self.poly = Polynomial([Zp(x) for x in poly]) % polynomialModulus\n\n         self.field = Fq\n\n      @typecheck\n      def __add__(self, other): return Fq(self.poly + other.poly)\n      @typecheck\n      def __sub__(self, other): return Fq(self.poly - other.poly)\n      @typecheck\n      def __mul__(self, other): return Fq(self.poly * other.poly)\n      @typecheck\n      def __eq__(self, other): return isinstance(other, Fq) and self.poly == other.poly\n\n      def __pow__(self, n): return Fq(pow(self.poly, n))\n      def __neg__(self): return Fq(-self.poly)\n      def __abs__(self): return abs(self.poly)\n      def __repr__(self): return repr(self.poly) + ' \\u2208 ' + self.__class__.__name__\n\n      @typecheck\n      def __divmod__(self, divisor):\n         q,r = divmod(self.poly, divisor.poly)\n         return (Fq(q), Fq(r))\n\n\n      def inverse(self):\n         if self == Fq(0):\n            raise ZeroDivisionError\n\n         x,y,d = extendedEuclideanAlgorithm(self.poly, self.idealGenerator)\n         if d.degree() != 0:\n            raise Exception('Somehow, this element has no inverse! Maybe intialized with a non-prime?')\n\n         return Fq(x) * Fq(d.coefficients[0].inverse())\n\n\n   Fq.__name__ = 'F_{%d^%d}' % (p,m)\n   return Fq\n\n\nif __name__ == \"__main__\":\n   F23 = FiniteField(2,3)\n   x = F23([1,1])\n\n   F35 = FiniteField(3,5)\n   y = F35([1,1,2])\n",
    "client\\finitefield\\modp.py": "\nfrom .euclidean import *\nfrom .numbertype import *\n\n# so all IntegersModP are instances of the same base class\nclass _Modular(FieldElement):\n   pass\n\n\n@memoize\ndef IntegersModP(p):\n   # assume p is prime\n\n   class IntegerModP(_Modular):\n      def __init__(self, n):\n         try:\n            self.n = int(n) % IntegerModP.p\n         except:\n            raise TypeError(\"Can't cast type %s to %s in __init__\" % (type(n).__name__, type(self).__name__))\n\n         self.field = IntegerModP\n\n      @typecheck\n      def __add__(self, other):\n         return IntegerModP(self.n + other.n)\n\n      @typecheck\n      def __sub__(self, other):\n         return IntegerModP(self.n - other.n)\n\n      @typecheck\n      def __mul__(self, other):\n         return IntegerModP(self.n * other.n)\n\n      def __neg__(self):\n         return IntegerModP(-self.n)\n\n      @typecheck\n      def __eq__(self, other):\n         return isinstance(other, IntegerModP) and self.n == other.n\n\n      @typecheck\n      def __ne__(self, other):\n         return isinstance(other, IntegerModP) is False or self.n != other.n\n\n      @typecheck\n      def __divmod__(self, divisor):\n         q,r = divmod(self.n, divisor.n)\n         return (IntegerModP(q), IntegerModP(r))\n\n      def inverse(self):\n         # need to use the division algorithm *as integers* because we're\n         # doing it on the modulus itself (which would otherwise be zero)\n         x,y,d = extendedEuclideanAlgorithm(self.n, self.p)\n\n         if d != 1:\n            raise Exception(\"Error: p is not prime in %s!\" % (self.__name__))\n\n         return IntegerModP(x)\n\n      def __abs__(self):\n         return abs(self.n)\n\n      def __str__(self):\n         return str(self.n)\n\n      def __repr__(self):\n         return '%d (mod %d)' % (self.n, self.p)\n\n      def __int__(self):\n         return self.n\n\n   IntegerModP.p = p\n   IntegerModP.__name__ = 'Z/%d' % (p)\n   IntegerModP.englishName = 'IntegersMod%d' % (p)\n   return IntegerModP\n\n\nif __name__ == \"__main__\":\n   mod7 = IntegersModP(7)\n",
    "client\\finitefield\\numbertype.py": "# memoize calls to the class constructors for fields\n# this helps typechecking by never creating two separate\n# instances of a number class.\ndef memoize(f):\n   cache = {}\n\n   def memoizedFunction(*args, **kwargs):\n      argTuple = args + tuple(kwargs)\n      if argTuple not in cache:\n         cache[argTuple] = f(*args, **kwargs)\n      return cache[argTuple]\n\n   memoizedFunction.cache = cache\n   return memoizedFunction\n\n\n# type check a binary operation, and silently typecast 0 or 1\ndef typecheck(f):\n   def newF(self, other):\n      if (hasattr(other.__class__, 'operatorPrecedence') and\n            other.__class__.operatorPrecedence > self.__class__.operatorPrecedence):\n         return NotImplemented\n\n      if type(self) is not type(other):\n         try:\n            other = self.__class__(other)\n         except TypeError:\n            message = 'Not able to typecast %s of type %s to type %s in function %s'\n            raise TypeError(message % (other, type(other).__name__, type(self).__name__, f.__name__))\n         except Exception as e:\n            message = 'Type error on arguments %r, %r for functon %s. Reason:%s'\n            raise TypeError(message % (self, other, f.__name__, type(other).__name__, type(self).__name__, e))\n\n      return f(self, other)\n\n   return newF\n\n\n\n# require a subclass to implement +-* neg and to perform typechecks on all of\n# the binary operations finally, the __init__ must operate when given a single\n# argument, provided that argument is the int zero or one\nclass DomainElement(object):\n   operatorPrecedence = 1\n\n   # the 'r'-operators are only used when typecasting ints\n   def __radd__(self, other): return self + other\n   def __rsub__(self, other): return -self + other\n   def __rmul__(self, other): return self * other\n\n   # square-and-multiply algorithm for fast exponentiation\n   def __pow__(self, n):\n      if type(n) is not int:\n         raise TypeError\n\n      Q = self\n      R = self if n & 1 else self.__class__(1)\n\n      i = 2\n      while i <= n:\n         Q = (Q * Q)\n\n         if n & i == i:\n            R = (Q * R)\n\n         i = i << 1\n\n      return R\n\n\n   # requires the additional % operator (i.e. a Euclidean Domain)\n   def powmod(self, n, modulus):\n      if type(n) is not int:\n         raise TypeError\n\n      Q = self\n      R = self if n & 1 else self.__class__(1)\n\n      i = 2\n      while i <= n:\n         Q = (Q * Q) % modulus\n\n         if n & i == i:\n            R = (Q * R) % modulus\n\n         i = i << 1\n\n      return R\n\n\n\n# additionally require inverse() on subclasses\nclass FieldElement(DomainElement):\n   def __truediv__(self, other): return self * other.inverse()\n   def __rtruediv__(self, other): return self.inverse() * other\n   def __div__(self, other): return self.__truediv__(other)\n   def __rdiv__(self, other): return self.__rtruediv__(other)\n\n",
    "client\\finitefield\\polynomial.py": "try:\n    from itertools import zip_longest\nexcept ImportError:\n    from itertools import izip_longest as zip_longest\nimport fractions\n\nfrom .numbertype import *\n\n# strip all copies of elt from the end of the list\ndef strip(L, elt):\n   if len(L) == 0: return L\n\n   i = len(L) - 1\n   while i >= 0 and L[i] == elt:\n      i -= 1\n\n   return L[:i+1]\n\n\n# create a polynomial with coefficients in a field; coefficients are in\n# increasing order of monomial degree so that, for example, [1,2,3]\n# corresponds to 1 + 2x + 3x^2\n@memoize\ndef polynomialsOver(field=fractions.Fraction):\n\n   class Polynomial(DomainElement):\n      operatorPrecedence = 2\n\n      @classmethod\n      def factory(cls, L):\n         return Polynomial([cls.field(x) for x in L])\n\n      def __init__(self, c):\n         if type(c) is Polynomial:\n            self.coefficients = c.coefficients\n         elif isinstance(c, field):\n            self.coefficients = [c]\n         elif not hasattr(c, '__iter__') and not hasattr(c, 'iter'):\n            self.coefficients = [field(c)]\n         else:\n            self.coefficients = c\n\n         self.coefficients = strip(self.coefficients, field(0))\n         self.indeterminate = 't'\n\n\n      def isZero(self): return self.coefficients == []\n\n      def __repr__(self):\n         if self.isZero():\n            return '0'\n\n         return ' + '.join(['%s %s^%d' % (a, self.indeterminate, i) if i > 0 else '%s'%a\n                              for i,a in enumerate(self.coefficients)])\n\n\n      def __abs__(self): return len(self.coefficients) # the valuation only gives 0 to the zero polynomial, i.e. 1+degree\n      def __len__(self): return len(self.coefficients)\n      def __sub__(self, other): return self + (-other)\n      def __iter__(self): return iter(self.coefficients)\n      def __neg__(self): return Polynomial([-a for a in self])\n\n      def iter(self): return self.__iter__()\n      def leadingCoefficient(self): return self.coefficients[-1]\n      def degree(self): return abs(self) - 1\n\n      @typecheck\n      def __eq__(self, other):\n         return self.degree() == other.degree() and all([x==y for (x,y) in zip(self, other)])\n\n      @typecheck\n      def __ne__(self, other):\n          return self.degree() != other.degree() or any([x!=y for (x,y) in zip(self, other)])\n\n      @typecheck\n      def __add__(self, other):\n         newCoefficients = [sum(x) for x in zip_longest(self, other, fillvalue=self.field(0))]\n         return Polynomial(newCoefficients)\n\n\n      @typecheck\n      def __mul__(self, other):\n         if self.isZero() or other.isZero():\n            return Zero()\n\n         newCoeffs = [self.field(0) for _ in range(len(self) + len(other) - 1)]\n\n         for i,a in enumerate(self):\n            for j,b in enumerate(other):\n               newCoeffs[i+j] += a*b\n\n         return Polynomial(newCoeffs)\n\n\n      @typecheck\n      def __divmod__(self, divisor):\n         quotient, remainder = Zero(), self\n         divisorDeg = divisor.degree()\n         divisorLC = divisor.leadingCoefficient()\n\n         while remainder.degree() >= divisorDeg:\n            monomialExponent = remainder.degree() - divisorDeg\n            monomialZeros = [self.field(0) for _ in range(monomialExponent)]\n            monomialDivisor = Polynomial(monomialZeros + [remainder.leadingCoefficient() / divisorLC])\n\n            quotient += monomialDivisor\n            remainder -= monomialDivisor * divisor\n\n         return quotient, remainder\n\n\n      @typecheck\n      def __truediv__(self, divisor):\n         if divisor.isZero():\n            raise ZeroDivisionError\n         return divmod(self, divisor)[0]\n\n\n      @typecheck\n      def __mod__(self, divisor):\n         if divisor.isZero():\n            raise ZeroDivisionError\n         return divmod(self, divisor)[1]\n\n\n   def Zero():\n      return Polynomial([])\n\n\n   Polynomial.field = field\n   Polynomial.__name__ = '(%s)[x]' % field.__name__\n   Polynomial.englishName = 'Polynomials in one variable over %s' % field.__name__\n   return Polynomial\n\n",
    "server\\cert": "Certificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number:\n            b9:59:da:c4:d7:3f:bc:31\n    Signature Algorithm: base64\n        Issuer: C = US, ST = Texas, L = College Station, O = Texas A&M University, OU = tamuCTF, CN = Alice, emailAddress = alice@tamuctf.edu\n        Validity\n            Not Before: Oct  9 13:08:12 2018 GMT\n            Not After : Nov  8 13:08:12 2018 GMT\n        Subject: C = US, ST = Texas, L = College Station, O = Texas A&M University, OU = tamuCTF, CN = Alice, emailAddress = alice@tamuctf.edu\n        Subject Public Key Info:\n            Public Key Algorithm: id-ecPublicKey\n                Public-Key:\n                    61801292647\n                    228288385004\n                ASN1 OID: badPrime96v4\n                CURVE: JustNo\n                    Field Type: prime-field\n                    Prime:\n                        412220184797\n                    A:   \n                        10717230661382162362098424417014722231813\n                    B:   \n                        22043581253918959176184702399480186312\n                    Generator:\n                        56797798272\n                        349018778637\n        X509v3 extensions:\n            X509v3 Subject Key Identifier: \n                F0:4E:BF:87:92:16:9B:D6:53:DA:CC:6D:AB:22:0E:40:25:41:C5:CC\n            X509v3 Authority Key Identifier: \n                keyid:F0:4E:BF:87:92:16:9B:D6:53:DA:CC:6D:AB:22:0E:40:25:41:C5:CC\n\n            X509v3 Basic Constraints: critical\n                CA:TRUE\n    Signature Algorithm: ecdsa-with-SHA256\n         30:46:02:21:00:cc:3c:84:eb:19:73:e1:62:7f:81:78:99:c6:\n         26:b8:86:9e:61:7e:82:87:f1:85:5c:75:e1:2d:60:37:55:b6:\n         09:02:21:00:85:33:af:dc:34:0f:e5:13:8e:26:88:06:a3:13:\n         d1:a2:ed:d5:04:cb:9c:50:d1:c4:a4:4d:42:92:bd:69:56:1a\n",
    "server\\Dockerfile": "FROM python:3.6.6-stretch\n\nRUN apt-get update && apt-get install -y \\\n    apt-utils \\\n    build-essential\nRUN pip install pyAesCrypt\nCOPY ./cert ./cert\nCOPY ./server.py ./server.py\nCOPY ./elliptic.py ./elliptic.py\nCOPY ./flag.txt ./flag.txt\nCOPY ./finitefield ./finitefield\nCOPY ./__pycache__ ./__pycache__\nEXPOSE 5005\nENTRYPOINT [\"python\",\"./server.py\"]\n",
    "server\\elliptic.py": "\nclass EllipticCurve(object):\n   def __init__(self, a, b):\n      # assume we're already in the Weierstrass form\n      self.a = a\n      self.b = b\n\n      self.discriminant = -16 * (4 * a*a*a + 27 * b * b)\n      if not self.isSmooth():\n         raise Exception(\"The curve %s is not smooth!\" % self)\n\n\n   def isSmooth(self):\n      return self.discriminant != 0\n\n\n   def testPoint(self, x, y):\n      return y*y == x*x*x + self.a * x + self.b\n\n\n   def __str__(self):\n      return 'y^2 = x^3 + %sx + %s' % (self.a, self.b)\n\n\n   def __repr__(self):\n      return str(self)\n\n\n   def __eq__(self, other):\n      return (self.a, self.b) == (other.a, other.b)\n\n\n\nclass Point(object):\n   def __init__(self, curve, x, y):\n      self.curve = curve # the curve containing this point\n      self.x = x\n      self.y = y\n\n      if not curve.testPoint(x,y):\n         raise Exception(\"The point %s is not on the given curve %s!\" % (self, curve))\n\n\n   def __str__(self):\n      return \"(%r, %r)\" % (self.x, self.y)\n\n\n   def __repr__(self):\n      return str(self)\n\n\n   def __neg__(self):\n      return Point(self.curve, self.x, -self.y)\n\n\n   def __add__(self, Q):\n      if self.curve != Q.curve:\n         raise Exception(\"Can't add points on different curves!\")\n      if isinstance(Q, Ideal):\n         return self\n\n      x_1, y_1, x_2, y_2 = self.x, self.y, Q.x, Q.y\n\n      if (x_1, y_1) == (x_2, y_2):\n         if y_1 == 0:\n            return Ideal(self.curve)\n\n         # slope of the tangent line\n         m = (3 * x_1 * x_1 + self.curve.a) / (2 * y_1)\n      else:\n         if x_1 == x_2:\n            return Ideal(self.curve)\n\n         # slope of the secant line\n         m = (y_2 - y_1) / (x_2 - x_1)\n\n      x_3 = m*m - x_2 - x_1\n      y_3 = m*(x_3 - x_1) + y_1\n\n      return Point(self.curve, x_3, -y_3)\n\n\n   def __sub__(self, Q):\n      return self + -Q\n\n   def __mul__(self, n):\n      if not isinstance(n, int):\n         raise Exception(\"Can't scale a point by something which isn't an int!\")\n      else:\n         if n < 0:\n             return -self * -n\n         if n == 0:\n             return Ideal(self.curve)\n         else:\n             Q = self\n             R = self if n & 1 == 1 else Ideal(self.curve)\n\n             i = 2\n             while i <= n:\n                 Q = Q + Q\n\n                 if n & i == i:\n                     R = Q + R\n\n                 i = i << 1\n\n             return R\n\n\n   def __rmul__(self, n):\n      return self * n\n\n   def __list__(self):\n      return [self.x, self.y]\n\n   def __eq__(self, other):\n      if type(other) is Ideal:\n         return False\n\n      return (self.x, self.y) == (other.x, other.y)\n\n   def __ne__(self, other):\n      return not self == other\n\n   def __getitem__(self, index):\n      return [self.x, self.y][index]\n\n\nclass Ideal(Point):\n   def __init__(self, curve):\n      self.curve = curve\n\n   def __neg__(self):\n      return self\n\n   def __str__(self):\n      return \"Ideal\"\n\n   def __add__(self, Q):\n      if self.curve != Q.curve:\n         raise Exception(\"Can't add points on different curves!\")\n      return Q\n\n   def __mul__(self, n):\n      if not isinstance(n, int):\n         raise Exception(\"Can't scale a point by something which isn't an int!\")\n      else:\n         return self\n\n   def __eq__(self, other):\n      return type(other) is Ideal\n\n",
    "server\\flag.txt": "Slartibartfast's study was a total mess, like the results  of  an\nexplosion  in  a  public  library.  The  old  man frowned as they\nstepped in.\n\n\"Terribly unfortunate,\" he said, \"a diode  blew  in  one  of  the\nlife-support  computers.  When  we  tried  to revive our cleaning\nstaff we discovered they'd been dead for nearly  thirty  thousand\nyears.  Who's  going to clear away the bodies, that's what I want\nto know. Look why don't you sit yourself down over there and  let\nme plug you in?\"\n\nHe gestured Arthur towards a chair which looked as if it had been\nmade out of the rib cage of a stegosaurus.\n\n\"It was made out of the rib cage of a stegosaurus,\" explained the\nold  man as he pottered about fishing bits of wire out from under\ntottering piles of paper  and  drawing  instruments.  \"Here,\"  he\nsaid,  \"hold  these,\" and passed a couple of stripped wire end to\nArthur.\n\nThe instant he took hold of them a  bird  flew  straight  through\nhim.\n\nHe was suspended in mid-air and  totally  invisible  to  himself.\nBeneath him was a pretty treelined city square, and all around it\nas far as the eye could see were white concrete buildings of airy\nspacious  design  but  somewhat  the  worse  for wear - many were\ncracked and stained with rain. Today however the sun was shining,\na  fresh  breeze  danced lightly through the trees, and the odd\nsensation that all the buildings were quietly humming was\nprobably caused by the fact that the square and all the streets\naround it were thronged with cheerful excited people. Somewhere a\nband  was playing, brightly coloured flags were fluttering in the\nbreeze and the spirit of carnival was in the air.\n\nArthur felt extraordinarily lonely stuck up in the air  above  it\nall without so much as a body to his name, but before he had time\nto reflect on this a voice rang out across the square and  called\nfor everyone's attention.\n\nA man standing on a brightly dressed  dais  before  the  building\nwhich  clearly dominated the square was addressing the crowd over\na Tannoy.\n\n\"O people waiting in the Shadow of Deep Thought!\" he  cried  out.\n\"Honoured Descendants of Vroomfondel and Majikthise, the Greatest\nand Most Truly Interesting Pundits the Universe  has  ever  known\n... The Time of Waiting is over!\"\n\nWild cheers broke out amongst the  crowd.  Flags,  streamers  and\nwolf whistles sailed through the air. The narrower streets looked\nrather like centipedes rolled over on their backs and frantically\nwaving their legs in the air.\n\n\"Seven and a half million years our  race  has  waited  for  this\nGreat  and  Hopefully  Enlightening Day!\" cried the cheer leader.\n\"The Day of the Answer!\"\n\nHurrahs burst from the ecstatic crowd.\n\n\"Never again,\" cried the man, \"never again will we wake up in the\nmorning  and  think Who am I? What is my purpose in life? Does it\nreally, cosmically speaking, matter if I don't get up and  go  to\nwork?  For today we will finally learn once and for all the plain\nand simple answer to all these nagging little problems  of  Life,\nthe Universe and Everything!\"\n\nAs the crowd erupted once again,  Arthur  found  himself  gliding\nthrough the air and down towards one of the large stately windows\non the first floor of the building behind the dais from which the\nspeaker was addressing the crowd.\n\nHe experienced a moment's panic as  he  sailed  straight  through\ntowards  the  window,  which  passed when a second or so later he\nfound  he  had  gone  right  through  the  solid  glass   without\napparently touching it.\n\nNo one in the room remarked on his  peculiar  arrival,  which  is\nhardly  surprising  as  he wasn't there. He began to realize that\nthe whole experience  was  merely  a  recorded  projection  which\nknocked six-track seventy-millimetre into a cocked hat.\n\nThe room was much as Slartibartfast had described  it.  In  seven\nand  a  half  million  years  it  had  been well looked after and\ncleaned regularly every century or so. The ultramahagony desk was\nworn  at  the edges, the carpet a little faded now, but the large\ncomputer terminal sat in sparkling glory on  the  desk's  leather\ntop, as bright as if it had been constructed yesterday.\nTwo severely dressed men sat respectfully before the terminal and\nwaited.\n\n\"The time is nearly upon us,\" said one, and Arthur was  surprised\nto  see a word suddenly materialize in thin air just by the man's\nneck. The word was Loonquawl, and it flashed a  couple  of  times\nand  the  disappeared again. Before Arthur was able to assimilate\nthis the other man spoke and the word  Phouchg  appeared  by  his\nneck.\n\n\"Seventy-five thousand generations ago, our  ancestors  set  this\nprogram in motion,\" the second man said, \"and in all that time we\nwill be the first to hear the computer speak.\"\n\n\"An awesome prospect, Phouchg,\" agreed the first man, and  Arthur\nsuddenly   realized   that  he  was  watching  a  recording  with\nsubtitles.\n\n\"We are the ones who will hear,\" said Phouchg, \"the answer to the\ngreat question of Life ...!\"\n\n\"The Universe ...!\" said Loonquawl.\n\n\"And Everything ...!\"\n\n\"Shhh,\" said Loonquawl with  a  slight  gesture,  \"I  think  Deep\nThought is preparing to speak!\"\n\nThere was a moment's expectant pause whilst panels slowly came to\nlife  on  the  front  of  the  console. Lights flashed on and off\nexperimentally and settled down into a  businesslike  pattern.  A\nsoft low hum came from the communication channel.\n\n\"Good morning,\" said Deep Thought at last.\n\n\"Er ... Good morning, O Deep Thought,\" said Loonquawl  nervously,\n\"do you have ... er, that is ...\"\n\n\"An answer for you?\" interrupted Deep Thought majestically. \"Yes.\nI have.\"\n\nThe two men shivered with expectancy. Their waiting had not  been\nin vain.\n\n\"There really is one?\" breathed Phouchg.\n\n\"There really is one,\" confirmed Deep Thought.\n\n\"To Everything? To the great Question of Life, the  Universe  and\nEverything?\"\n\n\"Yes.\"\n\nBoth of the men had been trained for this moment, their lives had\nbeen  a  preparation  for  it, they had been selected at birth as\nthose who would witness  the  answer,  but  even  so  they  found\nthemselves gasping and squirming like excited children.\n\n\"And you're ready to give it to us?\" urged Loonquawl.\n\"I am.\"\n\n\"Now?\"\n\n\"Now,\" said Deep Thought.\n\nThey both licked their dry lips.\n\n\"Though I don't think,\" added Deep Thought, \"that you're going to\nlike it.\"\n\n\"Doesn't matter!\" said Phouchg. \"We must know it! Now!\"\n\n\"Now?\" inquired Deep Thought.\n\n\"Yes! Now ...\"\n\n\"Alright,\" said the computer and settled into silence again.  The\ntwo men fidgeted. The tension was unbearable.\n\n\"You're really not going to like it,\" observed Deep Thought.\n\n\"Tell us!\"\n\n\"Alright,\" said Deep Thought. \"The Answer to the  Great  Question\n...\"\n\n\"Yes ...!\"\n\n\"Of Life, the Universe and Everything ...\" said Deep Thought.\n\n\"Yes ...!\"\n\n\"Is ...\" said Deep Thought, and paused.\n\n\"Yes ...!\"\n\n\"Is ...\"\n\n\"Yes ...!!!...?\"\n\ngigem{Forty-two_said_Deep_Thought}, with infinite majesty and calm.\n\n\n\n\nIt was a long time before anyone spoke.\n\nOut of the corner of his eye Phouchg could see the sea  of  tense\nexpectant faces down in the square outside.\n\n\"We're going to get lynched aren't we?\" he whispered.\n\n\"It was a tough assignment,\" said Deep Thought mildly.\n\n\"Forty-two!\" yelled Loonquawl. \"Is that all you've  got  to  show\nfor seven and a half million years' work?\"\n\"I checked it very thoroughly,\"  said  the  computer,  \"and  that\nquite  definitely is the answer. I think the problem, to be quite\nhonest with you, is that you've never  actually  known  what  the\nquestion is.\"\n\n\"But it was the Great Question! The Ultimate  Question  of  Life,\nthe Universe and Everything!\" howled Loonquawl.\n\n\"Yes,\" said Deep Thought with the air of one  who  suffers  fools\ngladly, \"but what actually is it?\"\n\nA slow stupefied silence crept over the men as they stared at the\ncomputer and then at each other.\n\n\"Well, you know, it's just Everything ... Everything ...\" offered\nPhouchg weakly.\n\n\"Exactly!\" said Deep Thought. \"So  once  you  do  know  what  the\nquestion actually is, you'll know what the answer means.\"\n\n\"Oh terrific,\" muttered Phouchg flinging aside his  notebook  and\nwiping away a tiny tear.\n\n\"Look, alright, alright,\" said Loonquawl, \"can  you  just  please\ntell us the Question?\"\n\n\"The Ultimate Question?\"\n\n\"Yes!\"\n\n\"Of Life, the Universe, and Everything?\"\n\n\"Yes!\"\n\nDeep Thought pondered this for a moment.\n\n\"Tricky,\" he said.\n\n\"But can you do it?\" cried Loonquawl.\n\nDeep Thought pondered this for another long moment.\n\nFinally: \"No,\" he said firmly.\n\nBoth men collapsed on to their chairs in despair.\n\n\"But I'll tell you who can,\" said Deep Thought.\n\nThey both looked up sharply.\n\n\"Who?\" \"Tell us!\"\n\nSuddenly Arthur began to feel his apparently  non-existent  scalp\nbegin  to  crawl as he found himself moving slowly but inexorably\nforward towards the console, but it was only a dramatic  zoom  on\nthe part of whoever had made the recording he assumed.\n\n\"I speak of none other than the computer that is  to  come  after\nme,\"  intoned  Deep  Thought,  his voice regaining its accustomed\ndeclamatory  tones.  \"A   computer   whose   merest   operational\nparameters  I  am not worthy to calculate - and yet I will design\nit for you. A computer which can calculate the  Question  to  the\nUltimate   Answer,   a  computer  of  such  infinite  and  subtle\ncomplexity that organic  life  itself  shall  form  part  of  its\noperational  matrix.  And  you yourselves shall take on new forms\nand go down into the computer to  navigate  its  ten-million-year\nprogram!  Yes!  I shall design this computer for you. And I shall\nname it also unto you. And it shall be called ... The Earth.\"\n\nPhouchg gaped at Deep Thought.\n\n\"What a dull name,\" he said and great incisions appeared down the\nlength  of  his  body.  Loonquawl too suddenly sustained horrific\ngashed from nowhere. The Computer console blotched  and  cracked,\nthe  walls  flickered  and  crumbled and the room crashed upwards\ninto its own ceiling ...\n\nSlartibartfast was standing in front of Arthur  holding  the  two\nwires.\n\n\"End of the tape,\" he explained.\n",
    "server\\server.py": "#!/usr/bin/env python3\nimport socket,base64\nfrom Crypto.Cipher import AES\nfrom elliptic import *\nfrom finitefield.finitefield import FiniteField\n\nimport os\n\n\ndef generate_private_key(numBits):\n    return int.from_bytes(os.urandom(numBits // 8), byteorder='big')\n\n\ndef generate_public_key(privateKey, generator, pubFunction):\n    return pubFunction(privateKey * generator)\n\n\ndef generate_shared_secret(privateKey, sharedFunction):\n    return privateKey * sharedFunction()\n\nif __name__ == \"__main__\":\n\n    TCP_IP = '0.0.0.0'\n    TCP_PORT = 5005\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind((TCP_IP,TCP_PORT))\n    s.listen(1)\n\n    c, addr = s.accept()\n    with open('cert','r') as cert:\n        data = cert.read()\n    encodeddata = \"-----BEGIN CERTIFICATE-----\\n\" + str(base64.b64encode(data.encode('utf-8')).decode('utf-8')) + \"\\n-----END CERTIFICATE-----\"\n\n    #Curve Exchange info\n    F = FiniteField(412220184797, 1)\n    curve = EllipticCurve(a=F(10717230661382162362098424417014722231813), b=F(22043581253918959176184702399480186312))\n    G = Point(curve, F(56797798272), F(349018778637))\n    c.sendall(encodeddata.encode('utf-8'))\n    c.close()\n    c1, addr = s.accept()\n    c1.recv(1024)\n    c1.close()\n    c2, addr = s.accept()\n\n    #Private key:\n    private_key = 54628069049\n\n    #Public key: (61801292647, 228288385004) order 137406875064\n    public_key = generate_public_key(private_key, G, lambda x:x)\n\n    #Key exchange\n    peer_public_key = Point(curve,F(196393473219),F(35161195210))\n\n    #Generate shared key\n    shared_secret = generate_shared_secret(private_key, lambda: peer_public_key)\n    secret_password = str(shared_secret.x.n) + str(shared_secret.y.n)\n    print(secret_password)\n\n    #Encrypt file with shared key and send it over\n    encryption_suite = AES.new(secret_password,AES.MODE_CBC, 'yoyoyoyoyoyoyoyo')\n    filename='flag.txt.aes'\n    try:\n        with open('flag.txt','rb') as flag_file:\n            flag = flag_file.read()\n        print(flag)\n        flag_file.close()\n        f = open(filename,'wb')\n        f.write(encryption_suite.encrypt(flag))\n        f.close()\n\n\n        f = open(filename,'rb')\n        l = f.read(1024)\n        while (l):\n           c2.send(l)\n           l = f.read(1024)\n        f.close()\n        print('Done sending')\n    finally:\n        c2.close()\n    os.remove('flag.txt.aes')\n",
    "server\\finitefield\\euclidean.py": "\n# a general Euclidean algorithm for any number type with\n# a divmod and a valuation abs() whose minimum value is zero\ndef gcd(a, b):\n   if abs(a) < abs(b):\n      return gcd(b, a)\n\n   while abs(b) > 0:\n      _,r = divmod(a,b)\n      a,b = b,r\n\n   return a\n\n\n# extendedEuclideanAlgorithm: int, int -> int, int, int\n# input (a,b) and output three numbers x,y,d such that ax + by = d = gcd(a,b).\n# Works for any number type with a divmod and a valuation abs()\n# whose minimum value is zero\ndef extendedEuclideanAlgorithm(a, b):\n   if abs(b) > abs(a):\n      (x,y,d) = extendedEuclideanAlgorithm(b, a)\n      return (y,x,d)\n\n   if abs(b) == 0:\n      return (1, 0, a)\n\n   x1, x2, y1, y2 = 0, 1, 1, 0\n   while abs(b) > 0:\n      q, r = divmod(a,b)\n      x = x2 - q*x1\n      y = y2 - q*y1\n      a, b, x2, x1, y2, y1 = b, r, x1, x, y1, y\n\n   return (x2, y2, a)\n\n",
    "server\\finitefield\\finitefield.py": "import random\nfrom .polynomial import polynomialsOver\nfrom .modp import *\n\n\n\n# isIrreducible: Polynomial, int -> bool\n# determine if the given monic polynomial with coefficients in Z/p is\n# irreducible over Z/p where p is the given integer\n# Algorithm 4.69 in the Handbook of Applied Cryptography\ndef isIrreducible(polynomial, p):\n   ZmodP = IntegersModP(p)\n   if polynomial.field is not ZmodP:\n      raise TypeError(\"Given a polynomial that's not over %s, but instead %r\" %\n                        (ZmodP.__name__, polynomial.field.__name__))\n\n   poly = polynomialsOver(ZmodP).factory\n   x = poly([0,1])\n   powerTerm = x\n   isUnit = lambda p: p.degree() == 0\n\n   for _ in range(int(polynomial.degree() / 2)):\n      powerTerm = powerTerm.powmod(p, polynomial)\n      gcdOverZmodp = gcd(polynomial, powerTerm - x)\n      if not isUnit(gcdOverZmodp):\n         return False\n\n   return True\n\n\n# generateIrreduciblePolynomial: int, int -> Polynomial\n# generate a random irreducible polynomial of a given degree over Z/p, where p\n# is given by the integer 'modulus'. This algorithm is expected to terminate\n# after 'degree' many irreducilibity tests. By Chernoff bounds the probability\n# it deviates from this by very much is exponentially small.\ndef generateIrreduciblePolynomial(modulus, degree):\n   Zp = IntegersModP(modulus)\n   Polynomial = polynomialsOver(Zp)\n\n   while True:\n      coefficients = [Zp(random.randint(0, modulus-1)) for _ in range(degree)]\n      randomMonicPolynomial = Polynomial(coefficients + [Zp(1)])\n      print(randomMonicPolynomial)\n\n      if isIrreducible(randomMonicPolynomial, modulus):\n         return randomMonicPolynomial\n\n\n# create a type constructor for the finite field of order p^m for p prime, m >= 1\n@memoize\ndef FiniteField(p, m, polynomialModulus=None):\n   Zp = IntegersModP(p)\n   if m == 1:\n      return Zp\n\n   Polynomial = polynomialsOver(Zp)\n   if polynomialModulus is None:\n      polynomialModulus = generateIrreduciblePolynomial(modulus=p, degree=m)\n\n   class Fq(FieldElement):\n      fieldSize = int(p ** m)\n      primeSubfield = Zp\n      idealGenerator = polynomialModulus\n      operatorPrecedence = 3\n\n      def __init__(self, poly):\n         if type(poly) is Fq:\n            self.poly = poly.poly\n         elif type(poly) is int or type(poly) is Zp:\n            self.poly = Polynomial([Zp(poly)])\n         elif isinstance(poly, Polynomial):\n            self.poly = poly % polynomialModulus\n         else:\n            self.poly = Polynomial([Zp(x) for x in poly]) % polynomialModulus\n\n         self.field = Fq\n\n      @typecheck\n      def __add__(self, other): return Fq(self.poly + other.poly)\n      @typecheck\n      def __sub__(self, other): return Fq(self.poly - other.poly)\n      @typecheck\n      def __mul__(self, other): return Fq(self.poly * other.poly)\n      @typecheck\n      def __eq__(self, other): return isinstance(other, Fq) and self.poly == other.poly\n\n      def __pow__(self, n): return Fq(pow(self.poly, n))\n      def __neg__(self): return Fq(-self.poly)\n      def __abs__(self): return abs(self.poly)\n      def __repr__(self): return repr(self.poly) + ' \\u2208 ' + self.__class__.__name__\n\n      @typecheck\n      def __divmod__(self, divisor):\n         q,r = divmod(self.poly, divisor.poly)\n         return (Fq(q), Fq(r))\n\n\n      def inverse(self):\n         if self == Fq(0):\n            raise ZeroDivisionError\n\n         x,y,d = extendedEuclideanAlgorithm(self.poly, self.idealGenerator)\n         if d.degree() != 0:\n            raise Exception('Somehow, this element has no inverse! Maybe intialized with a non-prime?')\n\n         return Fq(x) * Fq(d.coefficients[0].inverse())\n\n\n   Fq.__name__ = 'F_{%d^%d}' % (p,m)\n   return Fq\n\n\nif __name__ == \"__main__\":\n   F23 = FiniteField(2,3)\n   x = F23([1,1])\n\n   F35 = FiniteField(3,5)\n   y = F35([1,1,2])\n",
    "server\\finitefield\\modp.py": "\nfrom .euclidean import *\nfrom .numbertype import *\n\n# so all IntegersModP are instances of the same base class\nclass _Modular(FieldElement):\n   pass\n\n\n@memoize\ndef IntegersModP(p):\n   # assume p is prime\n\n   class IntegerModP(_Modular):\n      def __init__(self, n):\n         try:\n            self.n = int(n) % IntegerModP.p\n         except:\n            raise TypeError(\"Can't cast type %s to %s in __init__\" % (type(n).__name__, type(self).__name__))\n\n         self.field = IntegerModP\n\n      @typecheck\n      def __add__(self, other):\n         return IntegerModP(self.n + other.n)\n\n      @typecheck\n      def __sub__(self, other):\n         return IntegerModP(self.n - other.n)\n\n      @typecheck\n      def __mul__(self, other):\n         return IntegerModP(self.n * other.n)\n\n      def __neg__(self):\n         return IntegerModP(-self.n)\n\n      @typecheck\n      def __eq__(self, other):\n         return isinstance(other, IntegerModP) and self.n == other.n\n\n      @typecheck\n      def __ne__(self, other):\n         return isinstance(other, IntegerModP) is False or self.n != other.n\n\n      @typecheck\n      def __divmod__(self, divisor):\n         q,r = divmod(self.n, divisor.n)\n         return (IntegerModP(q), IntegerModP(r))\n\n      def inverse(self):\n         # need to use the division algorithm *as integers* because we're\n         # doing it on the modulus itself (which would otherwise be zero)\n         x,y,d = extendedEuclideanAlgorithm(self.n, self.p)\n\n         if d != 1:\n            raise Exception(\"Error: p is not prime in %s!\" % (self.__name__))\n\n         return IntegerModP(x)\n\n      def __abs__(self):\n         return abs(self.n)\n\n      def __str__(self):\n         return str(self.n)\n\n      def __repr__(self):\n         return '%d (mod %d)' % (self.n, self.p)\n\n      def __int__(self):\n         return self.n\n\n   IntegerModP.p = p\n   IntegerModP.__name__ = 'Z/%d' % (p)\n   IntegerModP.englishName = 'IntegersMod%d' % (p)\n   return IntegerModP\n\n\nif __name__ == \"__main__\":\n   mod7 = IntegersModP(7)\n",
    "server\\finitefield\\numbertype.py": "# memoize calls to the class constructors for fields\n# this helps typechecking by never creating two separate\n# instances of a number class.\ndef memoize(f):\n   cache = {}\n\n   def memoizedFunction(*args, **kwargs):\n      argTuple = args + tuple(kwargs)\n      if argTuple not in cache:\n         cache[argTuple] = f(*args, **kwargs)\n      return cache[argTuple]\n\n   memoizedFunction.cache = cache\n   return memoizedFunction\n\n\n# type check a binary operation, and silently typecast 0 or 1\ndef typecheck(f):\n   def newF(self, other):\n      if (hasattr(other.__class__, 'operatorPrecedence') and\n            other.__class__.operatorPrecedence > self.__class__.operatorPrecedence):\n         return NotImplemented\n\n      if type(self) is not type(other):\n         try:\n            other = self.__class__(other)\n         except TypeError:\n            message = 'Not able to typecast %s of type %s to type %s in function %s'\n            raise TypeError(message % (other, type(other).__name__, type(self).__name__, f.__name__))\n         except Exception as e:\n            message = 'Type error on arguments %r, %r for functon %s. Reason:%s'\n            raise TypeError(message % (self, other, f.__name__, type(other).__name__, type(self).__name__, e))\n\n      return f(self, other)\n\n   return newF\n\n\n\n# require a subclass to implement +-* neg and to perform typechecks on all of\n# the binary operations finally, the __init__ must operate when given a single\n# argument, provided that argument is the int zero or one\nclass DomainElement(object):\n   operatorPrecedence = 1\n\n   # the 'r'-operators are only used when typecasting ints\n   def __radd__(self, other): return self + other\n   def __rsub__(self, other): return -self + other\n   def __rmul__(self, other): return self * other\n\n   # square-and-multiply algorithm for fast exponentiation\n   def __pow__(self, n):\n      if type(n) is not int:\n         raise TypeError\n\n      Q = self\n      R = self if n & 1 else self.__class__(1)\n\n      i = 2\n      while i <= n:\n         Q = (Q * Q)\n\n         if n & i == i:\n            R = (Q * R)\n\n         i = i << 1\n\n      return R\n\n\n   # requires the additional % operator (i.e. a Euclidean Domain)\n   def powmod(self, n, modulus):\n      if type(n) is not int:\n         raise TypeError\n\n      Q = self\n      R = self if n & 1 else self.__class__(1)\n\n      i = 2\n      while i <= n:\n         Q = (Q * Q) % modulus\n\n         if n & i == i:\n            R = (Q * R) % modulus\n\n         i = i << 1\n\n      return R\n\n\n\n# additionally require inverse() on subclasses\nclass FieldElement(DomainElement):\n   def __truediv__(self, other): return self * other.inverse()\n   def __rtruediv__(self, other): return self.inverse() * other\n   def __div__(self, other): return self.__truediv__(other)\n   def __rdiv__(self, other): return self.__rtruediv__(other)\n\n",
    "server\\finitefield\\polynomial.py": "try:\n    from itertools import zip_longest\nexcept ImportError:\n    from itertools import izip_longest as zip_longest\nimport fractions\n\nfrom .numbertype import *\n\n# strip all copies of elt from the end of the list\ndef strip(L, elt):\n   if len(L) == 0: return L\n\n   i = len(L) - 1\n   while i >= 0 and L[i] == elt:\n      i -= 1\n\n   return L[:i+1]\n\n\n# create a polynomial with coefficients in a field; coefficients are in\n# increasing order of monomial degree so that, for example, [1,2,3]\n# corresponds to 1 + 2x + 3x^2\n@memoize\ndef polynomialsOver(field=fractions.Fraction):\n\n   class Polynomial(DomainElement):\n      operatorPrecedence = 2\n\n      @classmethod\n      def factory(cls, L):\n         return Polynomial([cls.field(x) for x in L])\n\n      def __init__(self, c):\n         if type(c) is Polynomial:\n            self.coefficients = c.coefficients\n         elif isinstance(c, field):\n            self.coefficients = [c]\n         elif not hasattr(c, '__iter__') and not hasattr(c, 'iter'):\n            self.coefficients = [field(c)]\n         else:\n            self.coefficients = c\n\n         self.coefficients = strip(self.coefficients, field(0))\n         self.indeterminate = 't'\n\n\n      def isZero(self): return self.coefficients == []\n\n      def __repr__(self):\n         if self.isZero():\n            return '0'\n\n         return ' + '.join(['%s %s^%d' % (a, self.indeterminate, i) if i > 0 else '%s'%a\n                              for i,a in enumerate(self.coefficients)])\n\n\n      def __abs__(self): return len(self.coefficients) # the valuation only gives 0 to the zero polynomial, i.e. 1+degree\n      def __len__(self): return len(self.coefficients)\n      def __sub__(self, other): return self + (-other)\n      def __iter__(self): return iter(self.coefficients)\n      def __neg__(self): return Polynomial([-a for a in self])\n\n      def iter(self): return self.__iter__()\n      def leadingCoefficient(self): return self.coefficients[-1]\n      def degree(self): return abs(self) - 1\n\n      @typecheck\n      def __eq__(self, other):\n         return self.degree() == other.degree() and all([x==y for (x,y) in zip(self, other)])\n\n      @typecheck\n      def __ne__(self, other):\n          return self.degree() != other.degree() or any([x!=y for (x,y) in zip(self, other)])\n\n      @typecheck\n      def __add__(self, other):\n         newCoefficients = [sum(x) for x in zip_longest(self, other, fillvalue=self.field(0))]\n         return Polynomial(newCoefficients)\n\n\n      @typecheck\n      def __mul__(self, other):\n         if self.isZero() or other.isZero():\n            return Zero()\n\n         newCoeffs = [self.field(0) for _ in range(len(self) + len(other) - 1)]\n\n         for i,a in enumerate(self):\n            for j,b in enumerate(other):\n               newCoeffs[i+j] += a*b\n\n         return Polynomial(newCoeffs)\n\n\n      @typecheck\n      def __divmod__(self, divisor):\n         quotient, remainder = Zero(), self\n         divisorDeg = divisor.degree()\n         divisorLC = divisor.leadingCoefficient()\n\n         while remainder.degree() >= divisorDeg:\n            monomialExponent = remainder.degree() - divisorDeg\n            monomialZeros = [self.field(0) for _ in range(monomialExponent)]\n            monomialDivisor = Polynomial(monomialZeros + [remainder.leadingCoefficient() / divisorLC])\n\n            quotient += monomialDivisor\n            remainder -= monomialDivisor * divisor\n\n         return quotient, remainder\n\n\n      @typecheck\n      def __truediv__(self, divisor):\n         if divisor.isZero():\n            raise ZeroDivisionError\n         return divmod(self, divisor)[0]\n\n\n      @typecheck\n      def __mod__(self, divisor):\n         if divisor.isZero():\n            raise ZeroDivisionError\n         return divmod(self, divisor)[1]\n\n\n   def Zero():\n      return Polynomial([])\n\n\n   Polynomial.field = field\n   Polynomial.__name__ = '(%s)[x]' % field.__name__\n   Polynomial.englishName = 'Polynomials in one variable over %s' % field.__name__\n   return Polynomial\n\n",
    "solution\\aesDecrypter.py": "#!/usr/bin/env python3\nfrom Crypto.Cipher import AES\nsecret_password = \"130222573707242246159397\" \n\nwith open('flag.txt.aes','rb') as encrypted_file:\n        encrypted_flag = encrypted_file.read()\ndecryption_suite = AES.new(secret_password,AES.MODE_CBC,'0000000000000000')\nflag = decryption_suite.decrypt(encrypted_flag)\nwith open('flag.txt','wb') as flag_file:\n    flag_file.write(flag)\n",
    "solution\\flag.txt": "\u001a3(-=6+>;+/>:+n, study was a total mess, like the results  of  an\nexplosion  in  a  public  library.  The  old  man frowned as they\nstepped in.\n\n\"Terribly unfortunate,\" he said, \"a diode  blew  in  one  of  the\nlife-support  computers.  When  we  tried  to revive our cleaning\nstaff we discovered they'd been dead for nearly  thirty  thousand\nyears.  Who's  going to clear away the bodies, that's what I want\nto know. Look why don't you sit yourself down over there and  let\nme plug you in?\"\n\nHe gestured Arthur towards a chair which looked as if it had been\nmade out of the rib cage of a stegosaurus.\n\n\"It was made out of the rib cage of a stegosaurus,\" explained the\nold  man as he pottered about fishing bits of wire out from under\ntottering piles of paper  and  drawing  instruments.  \"Here,\"  he\nsaid,  \"hold  these,\" and passed a couple of stripped wire end to\nArthur.\n\nThe instant he took hold of them a  bird  flew  straight  through\nhim.\n\nHe was suspended in mid-air and  totally  invisible  to  himself.\nBeneath him was a pretty treelined city square, and all around it\nas far as the eye could see were white concrete buildings of airy\nspacious  design  but  somewhat  the  worse  for wear - many were\ncracked and stained with rain. Today however the sun was shining,\na  fresh  breeze  danced lightly through the trees, and the odd\nsensation that all the buildings were quietly humming was\nprobably caused by the fact that the square and all the streets\naround it were thronged with cheerful excited people. Somewhere a\nband  was playing, brightly coloured flags were fluttering in the\nbreeze and the spirit of carnival was in the air.\n\nArthur felt extraordinarily lonely stuck up in the air  above  it\nall without so much as a body to his name, but before he had time\nto reflect on this a voice rang out across the square and  called\nfor everyone's attention.\n\nA man standing on a brightly dressed  dais  before  the  building\nwhich  clearly dominated the square was addressing the crowd over\na Tannoy.\n\n\"O people waiting in the Shadow of Deep Thought!\" he  cried  out.\n\"Honoured Descendants of Vroomfondel and Majikthise, the Greatest\nand Most Truly Interesting Pundits the Universe  has  ever  known\n... The Time of Waiting is over!\"\n\nWild cheers broke out amongst the  crowd.  Flags,  streamers  and\nwolf whistles sailed through the air. The narrower streets looked\nrather like centipedes rolled over on their backs and frantically\nwaving their legs in the air.\n\n\"Seven and a half million years our  race  has  waited  for  this\nGreat  and  Hopefully  Enlightening Day!\" cried the cheer leader.\n\"The Day of the Answer!\"\n\nHurrahs burst from the ecstatic crowd.\n\n\"Never again,\" cried the man, \"never again will we wake up in the\nmorning  and  think Who am I? What is my purpose in life? Does it\nreally, cosmically speaking, matter if I don't get up and  go  to\nwork?  For today we will finally learn once and for all the plain\nand simple answer to all these nagging little problems  of  Life,\nthe Universe and Everything!\"\n\nAs the crowd erupted once again,  Arthur  found  himself  gliding\nthrough the air and down towards one of the large stately windows\non the first floor of the building behind the dais from which the\nspeaker was addressing the crowd.\n\nHe experienced a moment's panic as  he  sailed  straight  through\ntowards  the  window,  which  passed when a second or so later he\nfound  he  had  gone  right  through  the  solid  glass   without\napparently touching it.\n\nNo one in the room remarked on his  peculiar  arrival,  which  is\nhardly  surprising  as  he wasn't there. He began to realize that\nthe whole experience  was  merely  a  recorded  projection  which\nknocked six-track seventy-millimetre into a cocked hat.\n\nThe room was much as Slartibartfast had described  it.  In  seven\nand  a  half  million  years  it  had  been well looked after and\ncleaned regularly every century or so. The ultramahagony desk was\nworn  at  the edges, the carpet a little faded now, but the large\ncomputer terminal sat in sparkling glory on  the  desk's  leather\ntop, as bright as if it had been constructed yesterday.\nTwo severely dressed men sat respectfully before the terminal and\nwaited.\n\n\"The time is nearly upon us,\" said one, and Arthur was  surprised\nto  see a word suddenly materialize in thin air just by the man's\nneck. The word was Loonquawl, and it flashed a  couple  of  times\nand  the  disappeared again. Before Arthur was able to assimilate\nthis the other man spoke and the word  Phouchg  appeared  by  his\nneck.\n\n\"Seventy-five thousand generations ago, our  ancestors  set  this\nprogram in motion,\" the second man said, \"and in all that time we\nwill be the first to hear the computer speak.\"\n\n\"An awesome prospect, Phouchg,\" agreed the first man, and  Arthur\nsuddenly   realized   that  he  was  watching  a  recording  with\nsubtitles.\n\n\"We are the ones who will hear,\" said Phouchg, \"the answer to the\ngreat question of Life ...!\"\n\n\"The Universe ...!\" said Loonquawl.\n\n\"And Everything ...!\"\n\n\"Shhh,\" said Loonquawl with  a  slight  gesture,  \"I  think  Deep\nThought is preparing to speak!\"\n\nThere was a moment's expectant pause whilst panels slowly came to\nlife  on  the  front  of  the  console. Lights flashed on and off\nexperimentally and settled down into a  businesslike  pattern.  A\nsoft low hum came from the communication channel.\n\n\"Good morning,\" said Deep Thought at last.\n\n\"Er ... Good morning, O Deep Thought,\" said Loonquawl  nervously,\n\"do you have ... er, that is ...\"\n\n\"An answer for you?\" interrupted Deep Thought majestically. \"Yes.\nI have.\"\n\nThe two men shivered with expectancy. Their waiting had not  been\nin vain.\n\n\"There really is one?\" breathed Phouchg.\n\n\"There really is one,\" confirmed Deep Thought.\n\n\"To Everything? To the great Question of Life, the  Universe  and\nEverything?\"\n\n\"Yes.\"\n\nBoth of the men had been trained for this moment, their lives had\nbeen  a  preparation  for  it, they had been selected at birth as\nthose who would witness  the  answer,  but  even  so  they  found\nthemselves gasping and squirming like excited children.\n\n\"And you're ready to give it to us?\" urged Loonquawl.\n\"I am.\"\n\n\"Now?\"\n\n\"Now,\" said Deep Thought.\n\nThey both licked their dry lips.\n\n\"Though I don't think,\" added Deep Thought, \"that you're going to\nlike it.\"\n\n\"Doesn't matter!\" said Phouchg. \"We must know it! Now!\"\n\n\"Now?\" inquired Deep Thought.\n\n\"Yes! Now ...\"\n\n\"Alright,\" said the computer and settled into silence again.  The\ntwo men fidgeted. The tension was unbearable.\n\n\"You're really not going to like it,\" observed Deep Thought.\n\n\"Tell us!\"\n\n\"Alright,\" said Deep Thought. \"The Answer to the  Great  Question\n...\"\n\n\"Yes ...!\"\n\n\"Of Life, the Universe and Everything ...\" said Deep Thought.\n\n\"Yes ...!\"\n\n\"Is ...\" said Deep Thought, and paused.\n\n\"Yes ...!\"\n\n\"Is ...\"\n\n\"Yes ...!!!...?\"\n\ngigem{Forty-two_said_Deep_Thought}, with infinite majesty and calm.\n\n\n\n\nIt was a long time before anyone spoke.\n\nOut of the corner of his eye Phouchg could see the sea  of  tense\nexpectant faces down in the square outside.\n\n\"We're going to get lynched aren't we?\" he whispered.\n\n\"It was a tough assignment,\" said Deep Thought mildly.\n\n\"Forty-two!\" yelled Loonquawl. \"Is that all you've  got  to  show\nfor seven and a half million years' work?\"\n\"I checked it very thoroughly,\"  said  the  computer,  \"and  that\nquite  definitely is the answer. I think the problem, to be quite\nhonest with you, is that you've never  actually  known  what  the\nquestion is.\"\n\n\"But it was the Great Question! The Ultimate  Question  of  Life,\nthe Universe and Everything!\" howled Loonquawl.\n\n\"Yes,\" said Deep Thought with the air of one  who  suffers  fools\ngladly, \"but what actually is it?\"\n\nA slow stupefied silence crept over the men as they stared at the\ncomputer and then at each other.\n\n\"Well, you know, it's just Everything ... Everything ...\" offered\nPhouchg weakly.\n\n\"Exactly!\" said Deep Thought. \"So  once  you  do  know  what  the\nquestion actually is, you'll know what the answer means.\"\n\n\"Oh terrific,\" muttered Phouchg flinging aside his  notebook  and\nwiping away a tiny tear.\n\n\"Look, alright, alright,\" said Loonquawl, \"can  you  just  please\ntell us the Question?\"\n\n\"The Ultimate Question?\"\n\n\"Yes!\"\n\n\"Of Life, the Universe, and Everything?\"\n\n\"Yes!\"\n\nDeep Thought pondered this for a moment.\n\n\"Tricky,\" he said.\n\n\"But can you do it?\" cried Loonquawl.\n\nDeep Thought pondered this for another long moment.\n\nFinally: \"No,\" he said firmly.\n\nBoth men collapsed on to their chairs in despair.\n\n\"But I'll tell you who can,\" said Deep Thought.\n\nThey both looked up sharply.\n\n\"Who?\" \"Tell us!\"\n\nSuddenly Arthur began to feel his apparently  non-existent  scalp\nbegin  to  crawl as he found himself moving slowly but inexorably\nforward towards the console, but it was only a dramatic  zoom  on\nthe part of whoever had made the recording he assumed.\n\n\"I speak of none other than the computer that is  to  come  after\nme,\"  intoned  Deep  Thought,  his voice regaining its accustomed\ndeclamatory  tones.  \"A   computer   whose   merest   operational\nparameters  I  am not worthy to calculate - and yet I will design\nit for you. A computer which can calculate the  Question  to  the\nUltimate   Answer,   a  computer  of  such  infinite  and  subtle\ncomplexity that organic  life  itself  shall  form  part  of  its\noperational  matrix.  And  you yourselves shall take on new forms\nand go down into the computer to  navigate  its  ten-million-year\nprogram!  Yes!  I shall design this computer for you. And I shall\nname it also unto you. And it shall be called ... The Earth.\"\n\nPhouchg gaped at Deep Thought.\n\n\"What a dull name,\" he said and great incisions appeared down the\nlength  of  his  body.  Loonquawl too suddenly sustained horrific\ngashed from nowhere. The Computer console blotched  and  cracked,\nthe  walls  flickered  and  crumbled and the room crashed upwards\ninto its own ceiling ...\n\nSlartibartfast was standing in front of Arthur  holding  the  two\nwires.\n\n\"End of the tape,\" he explained.\n",
    "solution\\flag.txt.aes": "[Binary file or unsupported type: aes]",
    "solution\\sharedKeySolver.py": "#!/usr/bin/env python\nimport sys\nsys.path.append('./PohligHellman')\nfrom ec import *\nfrom dlog import pohlighellman\nprint(\"Enter elliptic curve parameters in the form y^2 = x^3 + ax + b on the finite field F\")\na = int(input(\"a: \"))\nb = int(input(\"b: \"))\nF = int(input(\"F: \"))\ncurve = EC(0,a,b,F)\n\nprint(\"Enter the agreed starting point on the curve as follows.\")\nGx = int(input(\"Gx: \"))\nGy = int(input(\"Gy: \"))\nG = ECPt(curve,Gx,Gy)\n\nprint(\"Enter the first public key point Qa\")\nQax = int(input(\"Qax: \"))\nQay = int(input(\"Qay: \"))\nQa = ECPt(curve,Qax,Qay)\n\nprint(\"Enter the second public key point Qb\")\nQbx = int(input(\"Qbx: \"))\nQby = int(input(\"Qby: \"))\nQb = ECPt(curve,Qbx,Qby)\n\norder = Qa.computeOrder()\nprint(\"Order:\",order)\n\nprint(\"----------------------------------------\")\nprivate_key_a = pohlighellman(G,Qa,order)\n#private_key_b = pohlighellman(G,Qb,order)\nprint(\"Private Key:\",private_key_a)\nprint(\"----------------------------------------\")\n\nshared_key = private_key_a * Qb\n#shared_key = private_key_b * Qa\nprint(\"Shared Key:\",str(shared_key))\nprint(\"----------------------------------------\")\n",
    "solution\\PohligHellman\\bigrange.py": "\"\"\"\nbigrange - big ranges. Really.\n\nOnly one cool iterator in Python that supports big integers.\n\"\"\"\ndef bigrange(a,b,step=1):\n    \"\"\"\n    A replacement for the xrange iterator; the builtin class\n    doesn't handle arbitrarely large numbers.\n\n    Input:\n        a           First numeric output\n        b           Lower (or upper) bound, never yield\n        step        Defaults to 1\n    \"\"\"\n    i=a\n    while cmp(i,b)==cmp(0,step):\n        yield i\n        i+=step",
    "solution\\PohligHellman\\dlog.py": "\"\"\"\ndlog module - Shanks and Pohlig-Hellman algorithms for DLOG\n\ndlog modules provides\n\n    * Shank's algorithm.\n    * Pohlig-Hellman algorithm.\n\n    * Fast functions for inserting/searching for elements in sorted lists\n\nand requires ent and bigrange.\n\"\"\"\n\nimport ent as ent\nimport math\nfrom bigrange import bigrange\n\n\ndef shanks(a, b, bscount, gscount):\n    \"\"\"\n    Performs Shank's algorithm to solve the discrete logarithm.\n\n    Input:\n        a           'Base' of the discrete logarithm\n        b           'Argument' of the discrete logarithm\n        bscount     Number of baby steps to precompute\n        gscount     Number of giant steps to perform\n\n    Output:\n        An integer l such that a*l=b (the smallest in the range\n        0...bscount*gscount-1).\n\n    Remarks:\n        With a multiplicative notation, l is l=log_a b.\n        Nevertheless, the algorithm uses additive notation and therefore\n        a and b must implement the operations +, -, * (multiplication\n        with an int), as well as unary - and +.\n    \"\"\"\n    # precompute the baby steps\n    step=0*a\n    babysteps=[(step, 0)]\n    for i in bigrange(1, bscount):\n        step=step+a\n        # insert a tuple (step, i) in babysteps.\n        # do it in such a way that the list ends up sorted\n        el=(step, i)\n        babysteps.insert(find_insertion_index(el, babysteps), el)\n\n    # go on with the giant steps\n    lookfor=b; ba=bscount*a\n\n    for j in bigrange(0, gscount):\n        # update lookfor such that is always equal to b-j*bscount*a\n        if (j>0):\n            lookfor-=ba\n\n        # search in the baby steps\n        bstep=find_tuple_by_1st_item(lookfor, babysteps)\n\n        if bstep!=None: #found!\n            return j*bscount+bstep[1]\n\n    return None\n\n\n\n\ndef autoshanks(a, b, count):\n    \"\"\"\n    Computes Shank's algorithm with giant steps & baby steps count\n    equal to ceil(sqrt(count)). These are the best values in terms\n    of complexity.\n\n    Input:\n        a           'Base' of the discrete logarithm\n        b           'Argument' of the discrete logarithm\n        count       Number of elements in the group (of a and b)\n\n    Output:\n        An integer l such that a*l=b (the smallest in the range\n        0...count-1).\n\n    Remarks:\n        With a multiplicative notation, l is l=log_a b.\n        Nevertheless, the algorithm uses additive notation and therefore\n        a and b must implement the operations +, -, * (multiplication\n        with an int), as well as unary - and +.\n    \"\"\"\n    n=long(math.ceil(math.sqrt(float(count))));\n    return shanks(a, b, n, n)\n\n\n\n\n\n\ndef pohlighellman(a, b, count, simpleDlog=autoshanks):\n    \"\"\"\n    Performs Pohlig-Hellman algorithm to solve the discrete logarithm.\n    Requires the factorization of count to be computed, and relies on\n    ent.factor(...) to achieve that.\n    The routine uses another algorithm to solve simpler DLOG problems,\n    shanks as default.\n\n    Input:\n        a           'Base' of the discrete logarithm\n        b           'Argument' of the discrete logarithm\n        count       Number of elements in the group (of a and b)\n        simpleDlog  A callable that computes DLOG in a smaller group.\n                    The signature and return value must be the same\n                    as autoshanks; actually this argument defaults to\n                    autoshanks(...).\n\n    Output:\n        An integer l such that a*l=b (the smallest in the range\n        0...count-1).\n\n    Remarks:\n        Uses chineseremainder(...) to combine the partial results.\n\n    \"\"\"\n    # first of all let's factor count\n    factorization=ent.factor(count)\n    l=range(0,len(factorization))\n    li=0\n\n    for (p, e) in factorization:\n        g=(count//p)*a\n        if g.isIdentity(): # it may happen that g=O!\n            # ..still to check, but a couple of tests showed that\n            # this works.\n            l[li]=((p**e)-1, p**e)\n            li+=1\n            continue\n        A=0*a # 0 in the G group\n        bs=range(0, e)\n\n        for i in bigrange(0, e):\n            if i>0:\n                A=A+bs[i-1]*(p**(i-1))*a\n            B=(b-A)*(count//(p**(i+1)))\n            bs[i]=simpleDlog(g, B, p)\n        \n        # compute l_k\n        l[li]=0\n        for i in bigrange(e, 0, -1):\n            l[li]*=p\n            l[li]+=bs[i-1]\n\n        # prepare l to be input for chineseremainder\n        l[li]=(l[li], p**e)\n\n        li+=1\n\n    return chineseremainder(l)\n\n\n\ndef chineseremainder(eqs):\n    \"\"\"\n    Solves simultaneous congruences using Gauss's algorithm.\n    The routine doesn't check if all the n are pairwise coprime.\n\n    Input:\n        eqs         A list of tuples (a, n)\n\n    Output:\n        The solution x as in CRT, congruent to a mod n for each (a, n).\n    \"\"\"\n    N=1\n    x=0\n    for (a, n) in eqs:\n        N*=n\n    for (a, n) in eqs:\n        l=N/n\n        m=ent.inversemod(l, n)\n        x+=a*l*m\n\n    return x%N\n\n\n\n###########################################################\n# Fast auxiliary routines for sorted lists manipulation.\n###########################################################\n\n\n\ndef find_insertion_index(el, list):\n    \"\"\"\n    Assuming list is a sorted list, looks for the right index where\n    el should be inserted. The search is exaustive for lists with less\n    than 6 elements, otherwise it's done with a bisection algorithm.\n\n    Input:\n        el          The element to look the insertion index for\n        list        An already sorted list (eventually [])\n\n    Output:\n        An integer in the range 0...len(list)\n\n    Remarks:\n        Used by shanks, autoshanks, pohlighellman.\n    \"\"\"\n    if len(list)==0: return 0\n    if len(list)==1:\n        if el<list[0]: return 0\n        return 1\n    if len(list)<=5:\n        candidate=len(list)\n        while el<list[candidate-1] and candidate>0:\n            candidate-=1\n        return candidate\n    # binary search\n    a=0; b=len(list); m=b//2\n    while True:\n        # compare with the middle element\n        if el<list[m]:\n            b=m\n        else:\n            a=m+1\n        m=(a+b)//2\n\n        if a==b:\n            if a==len(list) or el<list[a]:\n                return a\n            return a+1\n        elif a+1==b:\n            if el<list[a]: return a\n            if b==len(list) or el<list[b]:\n                return b\n            return b+1\n\n\n\n\ndef find_item(item, list):\n    \"\"\"\n    Assuming list is a sorted list of items, looks with a bisection\n    algorithm for the index of that item. The search is exaustive for\n    lists with less than 6 elements. If not found, returns None.\n\n    Input:\n        item        The item to look for\n        list        A sorted list\n\n    Output:\n        An integer in the range 0...len(list)-1 or None.\n    \"\"\"\n    if len(list)==0: return None\n    if len(list)<=5:\n        for i in bigrange(0, len(list)):\n            if list[i]==item:\n                return i\n        return None\n    # binary search\n    a=0; b=len(list); m=b//2\n    while True:\n        # compare with the middle element\n        if list[m]==item:\n            return m\n\n        if item<list[m]:\n            b=m\n        else:\n            a=m+1\n        m=(a+b)//2\n\n        if a==b:\n            if a==len(list):\n                return None\n\n            if item==list[a]:\n                return a\n\n            return None\n        elif a+1==b:\n            if item==list[a]:\n                return a\n\n            if b==len(list):\n                return None\n\n            if item==list[b]:\n                return b\n\n            return None\n\n\n\n\ndef find_tuple_by_1st_item(stItem, list):\n    \"\"\"\n    Assuming list is a sorted list of tuples, looks with a bisection\n    algorithm for the a tuple with stItem at index 0, and\n    returns the whole tuple. The search is exhaustive for lists with \n    less than 6 elements. If not found, returns None.\n\n    Input:\n        stItem      The first item of the tuple we're looking for\n        list        A sorted list of tuples\n\n    Output:\n        A tuple with stItem as the first element or None.\n\n    Remarks:\n        Used by shanks, autoshanks, pohlighellman.\n    \"\"\"\n    if len(list)==0: return None\n    if len(list)<=5:\n        for i in bigrange(0, len(list)):\n            if list[i][0]==stItem:\n                return list[i]\n        return None\n    # binary search\n    a=0; b=len(list); m=b//2\n    while True:\n        # compare with the middle element\n        if list[m][0]==stItem:\n            return list[m]\n\n        if stItem<list[m][0]:\n            b=m\n        else:\n            a=m+1\n        m=(a+b)//2\n\n        if a==b:\n            if a==len(list):\n                return None\n\n            if stItem==list[a][0]:\n                return list[a]\n\n            return None\n        elif a+1==b:\n            if stItem==list[a][0]:\n                return list[a]\n\n            if b==len(list):\n                return None\n\n            if stItem==list[b][0]:\n                return list[b]\n\n            return None\n",
    "solution\\PohligHellman\\ec.py": "\"\"\"\nec module - Elliptic curves over finite fields class implementation\n\nec provides two base classes, EC and ECPt, that can be used to perform operations on the\ngroup of rational points of an elliptic curve over a finite field.\nThe classes provide also some \"introspective\" methods to compute orders of points,\ncardinality of the rational points group.\n\nec relies on ent, dlog and bigrange.\n\"\"\"\n\nimport os\nimport struct\nimport math\n\nimport ent as ent\nimport dlog\n\nfrom bigrange import bigrange\nfrom sets import Set\n\nclass EC(object):\n    \"\"\"\n    This class represents an elliptic curve of equation y^2==x^3+ax^2+bx+c over a\n    finite field F_p.\n    \"\"\"\n\n    def __init__(self, a, b, c, p):\n        \"\"\"\n        Defines a new elliptic curve. The routine performs pseudoprimality test on\n        p and checks whether the curve is singular or not.\n\n        Input:\n            a           Coefficient. Will be normalized modulo p\n            b           Same as a.\n            c           Same as b.\n            p           Prime number. Must be !=2,3. Defines the finite field to which\n                        the rational points belong.\n\n        Remarks:\n            Might raise an AssertionError.\n            Check before calling EC(...) that the parameters are valid by testing\n            whether EC.computeDiscriminant(a, b, c, p)!=0 .\n            \n            Pseudoprimality test is Fermat's, just for safety... You should be sure\n            of having generated a true prime before trying to build a finite field.\n            Checking primality is not the purpose of the class.\n\n        \"\"\"\n        super(EC, self).__init__()\n        # ensure char != 2,3\n        assert p!=2 and p!=3, \"char F_p must be != 2, 3.\"\n        # ensure p is a valid prime\n        assert p>3 and ent.is_pseudoprime(p), \"p must be a valid (pseudo)prime.\"\n        # reduce args mod p\n        a%=p; b%=p; c%=p\n        # compute discriminant\n        self._discriminant=EC.computeDiscriminant(a,b,c,p);\n        assert self._discriminant!=0, \"EC is singular.\"\n        #save everything\n        self._a=a; self._b=b; self._c=c; self._p=p\n        self._cardinality=-1\n\n\n\n\n\n\n    def __repr__(self):\n        return \"EC({},{},{},{})\".format(self._a, self._b, self._c, self._p)\n\n    def __str__(self):\n        retval=\"y^2==x^3\"\n        if self._a>0:\n            retval+=\"+\"+str(self._a)+\"x^2\"\n        elif self._a<0:\n            retval+=str(self._a)+\"x^2\"\n        if self._b>0:\n            retval+=\"+\"+str(self._b)+\"x\"\n        elif self._b<0:\n            retval+=str(self._a)+\"x\"\n        if self._c>0:\n            retval+=\"+\"+str(self._c)\n        elif self._c<0:\n            retval+=str(self._c)\n        retval+=\" over F_\"+str(self._p)\n\n        return retval\n\n\n\n\n\n    def __eq__(self, other):\n        \"\"\"\n        Two elliptic curves are equals if they're defined by the same equation over the\n        same finite field. Checks whether a, b, c, p are equal.\n        \"\"\"\n        if not isinstance(other, EC): return NotImplemented\n        return self._a==other._a and self._b==other._b and self._c==other._c and self._p==other._p\n\n    def __ne__(self, other):\n        if not isinstance(other, EC): return NotImplemented\n        return self._a!=other._a or self._b!=other._b or self._c!=other._c or self._p!=other._p\n\n\n\n\n    def enumerateAllPoints(self):\n        \"\"\"\n        Picks points randomly, then computes the generated group and stores it; the\n        routine exits when has computed exactly .cardinality() distinct points.\n\n        Output:\n            A list of ECPt objects. The identity is included.\n\n        Remarks:\n            The routine performs a call to cardinality(), therefore might be computationally\n            expensive.\n            Besides, enumerateAllPoints must store all the points computed, so it's also\n            expensive in terms of memory.\n        \"\"\"\n        extractedPts=Set()\n        while True:\n            P=self.pickPoint()\n            coords=(P._x, P._y)\n\n            if coords in extractedPts:\n                continue\n\n            extractedPts.add(coords)\n\n            # add all the multiples of P\n            Q=P\n            while True:\n                Q+=P\n\n                if Q.isIdentity(): break\n\n                coords=(Q._x, Q._y)\n                extractedPts.add(coords)\n\n            if len(extractedPts)==self.cardinality()-1:\n                retval=range(0, self.cardinality()) # prealloc\n                #convert to a list of ECPts\n                i=1\n                for (x, y) in extractedPts:\n                    retval[i]=ECPt(self, x, y)\n                    i+=1\n                \n                retval[0]=ECPt.identity()\n\n                return retval\n\n\n\n\n    def pickGenerator(self):\n        \"\"\"\n        Picks points over the elliptic curve randomly and computes their order, until\n        finds one with order equal to self.cardinality(); that is, a generator of the \n        group of rational points.\n\n        Output:\n            An ECPt object over the elliptic curve defined by self. If no point generates\n            the whole group, None is returned.\n\n        Remarks:\n            The routine performs a call to cardinality(). See cardinality for details;\n            computing cardinality might require a lot of time.\n            To make the routine significantly faster on some curves, for each point that\n            fails the test, the whole group it generates is stored in memory.\n            Because of this pickGenerator(...) can be memory expensive too.\n        \"\"\"\n        extractedPts=Set()\n        while True:\n            P=self.pickPoint()\n            coords=(P._x, P._y)\n\n            if coords in extractedPts:\n                continue\n\n            extractedPts.add(coords)\n\n            order=P.computeOrder()\n\n            if order==self.cardinality():\n                return P\n\n            # add all the mutiples of P\n            Q=P\n            for i in bigrange(2,order):\n                Q+=P\n                coords=(Q._x, Q._y)\n                extractedPts.add(coords)\n\n            if len(extractedPts)==self.cardinality()-1:\n                return None\n            \n\n    def pickPoint(self):\n        \"\"\"\n        Randomly picks a point on the elliptic curve defined by self.\n\n        Output:\n            An ECPt object over \"self\".\n\n        Remarks:\n            The routine simply chooses randomly a x in 0...p-1, then  finds a suitable\n            y for it using ent.sqrtmod(...).\n        \"\"\"\n        while True:\n            # choose a random x!=0\n            x=1+(EC._randomLong()%(self._p-1))\n            # compute fx\n            fx=self.computeFx(x)\n            # make sure sqrtmod won't fail\n            if ent.legendre(fx, self._p)==1:\n                return ECPt(self, x, ent.sqrtmod(fx, self._p))\n\n    def cardinality(self):\n        \"\"\"\n        This routine computes the exact cardinality of the group of rational points over\n        the elliptic curve. The result is cached, the computation is done only once.\n\n        Output:\n            The cardinality.\n\n        Remarks:\n            The routine uses ECPt.minOrderWithConstraints(...), ECPt.orderInFactorGroup\n            and ent.factor, therefore might be really expensive in terms of efficiency.\n        \"\"\"\n        if self._cardinality>=0:\n            return self._cardinality\n\n        P=self.pickPoint()\n\n        # try to get order\n        b=self._p+1-int(math.floor(2*math.sqrt(self._p)))\n        c=self._p+1+int(math.ceil(2*math.sqrt(self._p)))\n\n        result=P.minOrderWithConstraints(b, c, 0, 1)\n        if not isinstance(result, tuple):\n            # we've finished!\n            self._cardinality=result\n            return result\n\n        # we have the order of P\n        lp=result[1]\n\n        while True:\n            # let's pick another point\n            Q=self.pickPoint()\n            while Q==P: Q=self.pickPoint() # different, please\n\n            # another run of minOrder...\n            result=Q.minOrderWithConstraints(b, c, 0, lp)\n\n            if not isinstance(result, tuple):\n                # we've finished\n                self._cardinality=result\n                return result\n\n            lqp=result[1]\n\n            # we need l_Q\n            lq=lqp*lp\n            factorization=ent.factor(lq)\n\n            for (p, e) in factorization:\n                while ((lq//p)*Q).isIdentity():\n                    lq=lq//p\n\n            # we have P, l_P, Q, l_Q, we can run another algorithm\n            t=ECPt.orderInFactorGroup(P, lp, Q, lq)\n            # let's check if it's ok\n            if lp*t>2*int(math.floor(2*math.sqrt(p))):\n                # #C_K is the only number in [b,c] divisible by lpt\n                temp=math.ceil(b/float(lp*t))\n                self._cardinality=int(temp)*lp*t\n                return self._cardinality\n\n\n\n    def computeFx(self, x):\n        \"\"\"\n        Computes x^3+ax^2+bx+c in F_p using repeated modulo operations.\n\n        Input:\n            x           x.\n\n        Output:\n            A number in the range 0...p-1.\n\n        Remarks:\n            Considering the arbitrary length of Python's integers, maybe a unique big\n            modulo operation may be faster. Benchmark needed.\n        \"\"\"\n        x2=(x*x)  %self._p\n        x3=(x2*x) %self._p\n        fx=(x3+self._a*x2) %self._p\n        fx+=(self._b*x)    %self._p\n        fx+=self._c\n        return fx %self._p\n\n    def isPointOnEC(self, pt):\n        \"\"\"\n        Checks if the equation defining the elliptic curve vanises at the given\n        coordinates.\n\n        Input:\n            pt          An ECPt, or a tuple/list (x,y)/[x,y]\n\n        Output:\n            Boolean.\n        \"\"\"\n        x=y=0\n        if isinstance(pt, ECPt):\n            x=pt._x; y=pt._y\n        if isinstance(pt, tuple) or isinstance(pt, list):\n            x=pt[0]; y=pt[1]\n\n        if  x==0 and y==0: return True\n        y2=y*y  %self._p\n        return y2==self.computeFx(x)\n\n    @staticmethod\n    def computeDiscriminant(a,b,c,p):\n        \"\"\"\n        Computes the discriminant of an elliptic curve using repeatedly the modulo operator.\n    \n        Input:\n            a           Coefficient. Will be normalized modulo p\n            b           Same as a.\n            c           Same as b.\n            p           Number.\n\n        Output:\n            An integer in the range 0...p-1.\n\n        Remarks:\n            In this routine it's not relevant whether p is prime or not; it just computes\n\n                a^2 b^2 - 4b^3 - 4a^3 c + 18abc - 27c^2     (mod p)\n        \"\"\"\n        a2=(a*a)  %p\n        b2=(b*b)  %p\n        c2=(c*c)  %p\n        a3=(a2*a) %p\n        b3=(b2*b) %p\n        result=(a2*b2)      %p\n        result+=(-4*b3)     %p\n        result+=(-4*a3*c)   %p\n        result+=(18*a*b*c)  %p\n        result+=(-27*c2)    %p\n        return result %p;\n\n    @staticmethod\n    def _randomLong():\n        return struct.unpack(\"L\", os.urandom(8))[0]\n\n\n\n\nclass ECPt(object):\n    \"\"\"\n    This class represents a rational point on an elliptic curve.\n    \"\"\"\n\n    def __init__(self, ec, x, y):\n        \"\"\"\n        Initializes a new instance of a point over an elliptic curve.\n\n        Input:\n            ec          An instance of EC(...), the elliptic curve to which the point belongs\n            x           The x coordinate of the point\n            y           The y coordinate of the point\n\n        Remarks:\n            The routine checks if the point actually lies on the curve. The identity has coordinates\n            0, 0, but you should use isIdentity() to check and ECPt.identity() to create it.\n            If the point is not on the EC, it raises AssertionError; see EC.pickPoint() and\n            EC.pickGenerator() which are safe methods to generate rational points.\n        \"\"\"\n        super(ECPt, self).__init__()\n\n        if ec!=None:\n            x%=ec._p\n            y%=ec._p\n            # make sure the point is on the ec\n            assert ec.isPointOnEC((x, y)), \"The point doesn't lie on the EC.\"\n            # ok\n            self._EC=ec\n            self._x=x; self._y=y\n        else:\n            self._EC=None\n            self._x=0; self._y=0\n\n\n\n\n    def __str__(self):\n        if self.isIdentity(): return \"O\"\n        return str([int(self._x), int(self._y)])\n\n    def __repr__(self):\n        if self.isIdentity(): return \"ECPt.identity()\"\n        return \"ECPt({},{},{})\".format(repr(self._EC), self._x, self._y)\n\n\n\n\n\n\n    def __eq__(self, other):\n        \"\"\"\n        Two points are equals if they have the same coordinates and elliptic curve.\n        \"\"\"\n        if not isinstance(other, ECPt): return NotImplemented\n        if other._EC!=self._EC: return False\n        return self._x==other._x and self._y==other._y\n\n    def __ne__(self, other):\n        if not isinstance(other, ECPt): return NotImplemented\n        if other._EC!=self._EC: return True\n        return self._x!=other._x or self._y!=other._y\n\n\n\n\n\n\n\n\n    def __add__(self, other):\n        \"\"\"\n        Performs addition between two points of the same EC using the group operation.\n\n        Output:\n            Another instance of an ECPt on the same elliptic curve.\n        \"\"\"\n        # we can add only points on the same curve\n        if not isinstance(other, ECPt): return NotImplemented\n\n        # perform addition\n        if self.isIdentity(): return other\n        if other.isIdentity(): return self\n\n        if self._EC!=other._EC: return NotImplemented\n\n        if self._x==other._x and (self._y+other._y)%self._EC._p==0: return ECPt.identity()\n\n        # define all the necessary coefficient\n        if self==other:\n            l=(3*self._x*self._x) %self._EC._p\n            l+=(2*self._EC._a*self._x) %self._EC._p\n            l+=self._EC._b\n            # find 1/2y\n            l*=ent.inversemod(2*self._y, self._EC._p)\n        else:\n            l=(other._y-self._y) %self._EC._p\n            # find 1/(other._x-self._x)\n            l*=ent.inversemod(other._x-self._x, self._EC._p)\n\n        # clamp in 0...p-1 and square\n        l%=self._EC._p\n        l2=(l*l) %self._EC._p\n\n        # define nu\n        n=(self._y-l*self._x) %self._EC._p\n\n        #ready to build the added point\n        newX=(l2-self._EC._a-self._x-other._x) %self._EC._p\n        newY=(-l*newX-n) %self._EC._p\n\n        #finished\n        return ECPt(self._EC, newX, newY)\n\n    def __sub__(self, other):\n        # we can add only points on the same curve\n        if not isinstance(other, ECPt): return NotImplemented\n\n        if self.isIdentity(): return -other\n        if other.isIdentity(): return self\n\n        if self._EC!=other._EC: return NotImplemented\n\n        # negate other and add\n        other=-other\n        return self+other\n\n    def __neg__(self):\n        \"\"\"\n        Gives the opposite of the point (by negating the y-coordinate).\n        \"\"\"\n        if self.isIdentity(): return self\n        return ECPt(self._EC, self._x, -self._y)\n\n    def __pos__(self):\n        return self\n\n    def __mul__(self, m):\n        \"\"\"\n        Computes the m-th multiple of 'self' using double-and-add algorithm.\n        \"\"\"\n        if not isinstance(m, int) and not isinstance(m, long): return NotImplemented\n\n        if m==0: return ECPt.identity()\n\n        # use double and add\n        negateAfter=False\n        if m<0:\n            negateAfter=True\n            m=-m\n\n        if m==1:\n            P=self\n        elif m==2:\n            P=self+self\n        else:\n            # compute first the index of MSB\n            msb=0; mm=m\n            while mm>0:\n                msb+=1\n                mm=mm>>1\n\n            P=ECPt.identity()\n            for i in bigrange(msb, 0, -1):\n                # double and add\n                P=P+P\n                if (m & (1<<(i-1))): P=P+self\n\n        if negateAfter: P=-P\n\n        return P\n\n    def __rmul__(self, m):\n        if not isinstance(m, int) and not isinstance(m, long): return NotImplemented\n        return self*m\n\n    def __lt__(self, other):\n        \"\"\"\n        The order on the set of rational points is given by the lexicographic order of the \n        couples (x, y). (x, y)<(x', y') if x<x' or if x=x' and y<y'.\n        \"\"\"     \n        if not isinstance(other, ECPt): return NotImplemented\n        if self._x<other._x: return True\n        if self._x==other._x: return self._y<other._y\n        return False\n\n    def __le__(self, other):\n        if not isinstance(other, ECPt): return NotImplemented\n        if self._x<other._x: return True\n        if self._x==other._x: return self._y<=other._y\n        return False\n\n    def __gt__(self, other):\n        if not isinstance(other, ECPt): return NotImplemented\n        if self._x>other._x: return True\n        if self._x==other._y: return self._y>other._y\n        return False\n\n    def __ge__(self, other):\n        if not isinstance(other, ECPt): return NotImplemented\n        if self._x>other._x: return True\n        if self._x==other._x: return self._y>=other._y\n        return False\n\n\n\n    @staticmethod\n    def orderInFactorGroup(P, lp, Q, lq):\n        \"\"\"\n        This routine computes the order of Q's equivalence class in the quotient group C_K/<P>.\n\n        Input:\n            P       A rational point\n            lp      The order of P\n            Q       Another rational point\n            lq      The order of Q\n\n        Output:\n            Integer m such that m*[Q]=[O] in C_K/<P>.\n\n        Remarks:\n            The routine doesn't check if P and Q are either the identity, or if they belong to\n            the same group (although the algorithm should fail in that case, because addition\n            and equality are not defined).\n            This can be a quite expensive routine, and makes use of the factorization of lq\n            (achieved through ent.factor(...)).\n            It is essentially intended to be called from inside EC.cardinality().\n        \"\"\"\n        h=int(math.ceil(math.sqrt(lp)))\n\n        # precompute baby steps\n        step=ECPt.identity()\n        babysteps=[step]\n        for i in bigrange(1, h):\n            step=step+P\n            babysteps.insert(dlog.find_insertion_index(step, babysteps), step)\n\n        # precompute giant steps\n        hP=h*P\n        step=ECPt.identity()\n        giantsteps=[step]\n        for i in bigrange(1, h):\n            step=step+hP\n            giantsteps.insert(dlog.find_insertion_index(step, giantsteps), step)\n\n        # let's factor l_Q\n        factorization=ent.factor(lq)\n        d=lq\n\n        # for each prime factor in the factorization\n        for (p,e) in factorization:\n            QQ=Q*(d//p)\n            nextFactor=False\n\n            while not nextFactor:\n\n                # look for each QQ-R in babysteps.\n                # if found, update d and try again with\n                # the same factor. Otherwise, next prime\n                found=False\n                for (R, i) in giantsteps:\n                    lookfor=QQ-R\n                    if dlog.find_item(lookfor, babysteps)!=None:\n                        d=d//p\n                        found=True\n                        break\n\n                if not found:\n                    nextFactor=True\n\n        return d # the needed integer\n\n\n\n    def computeOrder(self):\n        \"\"\"\n        Computes the order of the point solving a discrete logarithm.\n\n        Output:\n            Integer m such that (m*self).isIdentity()==True.\n            Outputs None if self is identity.\n\n        Remarks:\n            This routine uses Shank's algorithm (dlog.autoshanks(...)).\n        \"\"\"\n        if self.isIdentity(): return None\n        ub=self._EC._p+1+2*int(math.ceil(math.sqrt(self._EC._p)))\n        return 1+dlog.autoshanks(self, -self, ub)\n\n\n\n\n    def minOrderWithConstraints(self,b,c,ls,L):\n        \"\"\"\n        This routine computes the minimum integer l such that l*self=O, with the\n        following conditions:\n            * l = ls   (mod L)\n            * b <= l <= c\n        It's essentially a modified baby-step giant-step algorithm.\n\n        Input:\n            b           The lower bound of the search interval\n            c           The upper bound of the search interval\n            ls          The output will be congruent to ls modulo L\n            L           See ls.\n\n        Output:\n            An integer satisfying the conditions given above if found; None otherwise.\n\n        Remarks:\n            This routine is intended to be called by EC.cardinality().\n        \"\"\"\n        bs=L*((b-ls)//L)+ls\n        if bs<b: bs+=L\n        if bs>c: return None\n\n        cs=L*((c-ls)//L)+ls\n        if cs>c:\n            cs-=L\n        elif cs+L<=c:\n            cs+=L\n        if cs<b: return None\n\n        if bs==cs:\n            # compute bs*P and check\n            if (bs*self).isIdentity(): \n                return bs\n            return None\n\n        h=int(math.ceil(math.sqrt((cs-bs)/L+1)))\n\n        # let's precompute small steps\n        LP=L*self\n        hLP=h*LP\n\n        step=ECPt.identity()\n        babysteps=[(step, 0)]\n\n        for i in bigrange(1, h):\n            step=step+LP\n            # insert a tuple (step, i) in babysteps.\n            # do it in such a way that the list ends up sorted\n            el=(step, i)\n            babysteps.insert(dlog.find_insertion_index(el, babysteps), el)\n\n        solutions=[]\n        # giant steps\n        Q=-bs*self\n        for i in bigrange(0, h):\n            # look up in the babysteps\n            found=dlog.find_tuple_by_1st_item(Q, babysteps)\n\n            if found!=None:\n                solutions.append((i,found[1]))\n                if len(solutions)==2:\n                    break\n\n            # update Q value\n            Q=Q-hLP\n\n        #check if the solution has been found\n        if len(solutions)==0: return None\n        l=bs+L*(solutions[0][0]*h+solutions[0][1])\n        if len(solutions)==2:\n            m=(solutions[1][0]-solutions[0][0])*h+solutions[1][1]-solutions[0][1]\n            return (l, m)\n\n        return l\n        \n\n\n\n    def isIdentity(self):\n        \"\"\"\n        Identity element has x=y=0 and None as EC. You should always use this function to\n        check if an element is identity.\n\n        Output:\n            Boolean.\n\n        Remarks:\n            The fact that the identity element has None as EC is not mathematically precise,\n            since this allows the addition of the identity to any point from any rational\n            point group; in other words, all the identities in all the rational points groups\n            are the same. On the other side, the identity is not an affine point, and therefore\n            should be distinguished in some way; and it is the same point at infinity for all\n            the elliptic curves. Besides, using a null elliptic curve as a \"flag\" to distinguish\n            the identity has the advantage that, in case of elliptic curves with c==0, the point\n            (0,0) is actually a point different from O (the identity); in this way we obtain\n            the result we want without the need of subclassing ECPt.\n\n        \"\"\"\n        return self._x==0 and self._y==0 and self._EC==None\n\n    @staticmethod\n    def identity():\n        \"\"\"\n        Returns \"the\" identity element.\n\n        Output:\n            ECPt instance.\n\n        Remarks:\n            See ECPt.isIdentity(...) for details about the inner structure of the identity.\n        \"\"\"\n        return ECPt(None, 0, 0)\n",
    "solution\\PohligHellman\\ent.py": "##################################################\n# ent.py -- Elementary Number Theory \n# (c) William Stein, 2004\n##################################################\n\n\n\n\nfrom random import randrange\nfrom math import log, sqrt\n\n\n\n\n##################################################\n## Greatest Common Divisors\n##################################################\n\ndef gcd(a, b):                                        # (1)\n    \"\"\"\n    Returns the greatest commond divisor of a and b.\n    Input:\n        a -- an integer\n        b -- an integer\n    Output:\n        an integer, the gcd of a and b\n    Examples:\n    >>> gcd(97,100)\n    1\n    >>> gcd(97 * 10**15, 19**20 * 97**2)              # (2)\n    97L\n    \"\"\"\n    if a < 0:  a = -a\n    if b < 0:  b = -b\n    if a == 0: return b\n    if b == 0: return a\n    while b != 0: \n        (a, b) = (b, a%b)\n    return a\n\n\n\n##################################################\n## Enumerating Primes\n##################################################\n\ndef primes(n):\n    \"\"\"\n    Returns a list of the primes up to n, computed \n    using the Sieve of Eratosthenes.\n    Input:\n        n -- a positive integer\n    Output:\n        list -- a list of the primes up to n\n    Examples:\n    >>> primes(10)\n    [2, 3, 5, 7]\n    >>> primes(45)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    \"\"\"\n    if n <= 1: return []\n    X = [i for i in range(3,n+1) if i%2 != 0]     # (1)\n    P = [2]                                       # (2)\n    sqrt_n = sqrt(n)                              # (3)\n    while len(X) > 0 and X[0] <= sqrt_n:          # (4)\n        p = X[0]                                  # (5)\n        P.append(p)                               # (6)\n        X = [a for a in X if a%p != 0]            # (7)\n    return P + X                                  # (8)\n\n\n\n\n##################################################\n## Integer Factorization\n##################################################\n\ndef trial_division(n, bound=None):\n    \"\"\"\n    Return the smallest prime divisor <= bound of the \n    positive integer n, or n if there is no such prime.  \n    If the optional argument bound is omitted, then bound=n.\n    Input:\n        n -- a positive integer\n        bound - (optional) a positive integer\n    Output:\n        int -- a prime p<=bound that divides n, or n if\n               there is no such prime.\n    Examples:\n    >>> trial_division(15)\n    3\n    >>> trial_division(91)\n    7\n    >>> trial_division(11)\n    11\n    >>> trial_division(387833, 300)   \n    387833\n    >>> # 300 is not big enough to split off a \n    >>> # factor, but 400 is.\n    >>> trial_division(387833, 400)  \n    389\n    \"\"\"\n    if n == 1: return 1\n    for p in [2, 3, 5]:\n        if n%p == 0: return p\n    if bound == None: bound = n\n    dif = [6, 4, 2, 4, 2, 4, 6, 2]\n    m = 7; i = 1\n    while m <= bound and m*m <= n:\n        if n%m == 0:\n            return m\n        m += dif[i%8]\n        i += 1\n    return n\n\ndef factor(n):\n    \"\"\"\n    Returns the factorization of the integer n as \n    a sorted list of tuples (p,e), where the integers p\n    are output by the split algorithm.  \n    Input:\n        n -- an integer\n    Output:\n        list -- factorization of n\n    Examples:\n    >>> factor(500)\n    [(2, 2), (5, 3)]\n    >>> factor(-20)\n    [(2, 2), (5, 1)]\n    >>> factor(1)\n    []\n    >>> factor(2004)\n    [(2, 2), (3, 1), (167, 1)]\n    \"\"\"\n    if n in [-1, 0, 1]: return []\n    if n < 0: n = -n\n    F = []\n    while n != 1:\n        p = trial_division(n)\n        e = 1\n        n /= p\n        while n%p == 0:\n            e += 1; n /= p\n        F.append((p,e))\n    F.sort()\n    return F\n\ndef is_squarefree(n):\n    \"\"\"\n    Returns True if and only if n is not divisible by the square of an integer > 1.\n    \"\"\"\n    if n==0:\n        return False\n    for p, r in factor(n):\n        if r>1:\n            return False\n    return True\n\n\n##################################################\n## Linear Equations Modulo $n$\n##################################################\n\ndef xgcd(a, b):\n    \"\"\"\n    Returns g, x, y such that g = x*a + y*b = gcd(a,b).\n    Input:\n        a -- an integer\n        b -- an integer\n    Output:\n        g -- an integer, the gcd of a and b\n        x -- an integer\n        y -- an integer\n    Examples:\n    >>> xgcd(2,3)\n    (1, -1, 1)\n    >>> xgcd(10, 12)\n    (2, -1, 1)\n    >>> g, x, y = xgcd(100, 2004)\n    >>> print g, x, y\n    4 -20 1\n    >>> print x*100 + y*2004\n    4\n    \"\"\"\n    if a == 0 and b == 0: return (0, 0, 1)\n    if a == 0: return (abs(b), 0, b/abs(b))\n    if b == 0: return (abs(a), a/abs(a), 0)\n    x_sign = 1; y_sign = 1\n    if a < 0: a = -a; x_sign = -1\n    if b < 0: b = -b; y_sign = -1\n    x = 1; y = 0; r = 0; s = 1\n    while b != 0:\n        (c, q) = (a%b, a/b)\n        (a, b, r, s, x, y) = (b, c, x-q*r, y-q*s, r, s)\n    return (a, x*x_sign, y*y_sign)\n\ndef inversemod(a, n):\n    \"\"\"\n    Returns the inverse of a modulo n, normalized to\n    lie between 0 and n-1.  If a is not coprime to n,\n    raise an exception (this will be useful later for \n    the elliptic curve factorization method).\n    Input:\n        a -- an integer coprime to n\n        n -- a positive integer\n    Output:\n        an integer between 0 and n-1.\n    Examples:\n    >>> inversemod(1,1)\n    0\n    >>> inversemod(2,5)\n    3\n    >>> inversemod(5,8)\n    5\n    >>> inversemod(37,100)\n    73\n    \"\"\"\n    g, x, y = xgcd(a, n)\n    if g != 1:\n        raise ZeroDivisionError, (a,n)\n    assert g == 1, \"a must be coprime to n.\"\n    return x%n\n\ndef solve_linear(a,b,n):\n    \"\"\"\n    If the equation ax = b (mod n) has a solution, return a \n    solution normalized to lie between 0 and n-1, otherwise\n    returns None.\n    Input:\n        a -- an integer\n        b -- an integer\n        n -- an integer\n    Output:\n        an integer or None\n    Examples:\n    >>> solve_linear(4, 2, 10)\n    8\n    >>> solve_linear(2, 1, 4) == None\n    True\n    \"\"\"\n    g, c, _ = xgcd(a,n)                 # (1)\n    if b%g != 0: return None\n    return ((b/g)*c) % n                \n\ndef crt(a, b, m, n):\n    \"\"\"\n    Return the unique integer between 0 and m*n - 1 \n    that reduces to a modulo n and b modulo m, where\n    the integers m and n are coprime. \n    Input:\n        a, b, m, n -- integers, with m and n coprime\n    Output:\n        int -- an integer between 0 and m*n - 1.\n    Examples:\n    >>> crt(1, 2, 3, 4)\n    10\n    >>> crt(4, 5, 10, 3)\n    14\n    >>> crt(-1, -1, 100, 101)\n    10099\n    \"\"\"\n    g, c, _ = xgcd(m, n)                       \n    assert g == 1, \"m and n must be coprime.\"\n    return (a + (b-a)*c*m) % (m*n)\n\n\n##################################################\n## Computation of Powers\n##################################################\n\ndef powermod(a, m, n):\n    \"\"\"\n    The m-th power of a modulo n.\n    Input:\n        a -- an integer\n        m -- a nonnegative integer\n        n -- a positive integer\n    Output:\n        int -- an integer between 0 and n-1\n    Examples:\n    >>> powermod(2,25,30)\n    2\n    >>> powermod(19,12345,100)\n    99\n    \"\"\"\n    assert m >= 0, \"m must be nonnegative.\"   # (1)\n    assert n >= 1, \"n must be positive.\"      # (2)\n    ans = 1\n    apow = a\n    while m != 0:\n        if m%2 != 0:\n            ans = (ans * apow) % n            # (3)\n        apow = (apow * apow) % n              # (4)\n        m /= 2   \n    return ans % n\n\n\n##################################################\n## Finding a Primitive Root\n##################################################\n\ndef primitive_root(p):\n    \"\"\"\n    Returns first primitive root modulo the prime p.\n    (If p is not prime, this return value of this function\n    is not meaningful.)\n    Input:\n        p -- an integer that is assumed prime\n    Output:\n        int -- a primitive root modulo p\n    Examples:\n    >>> primitive_root(7)\n    3\n    >>> primitive_root(389)\n    2\n    >>> primitive_root(5881)\n    31\n    \"\"\"\n    if p == 2: return 1\n    F = factor(p-1)\n    a = 2\n    while a < p:\n        generates = True\n        for q, _ in F:\n            if powermod(a, (p-1)/q, p) == 1:\n                generates = False\n                break\n        if generates: return a\n        a += 1\n    assert False, \"p must be prime.\"\n\n\n##################################################\n## Determining Whether a Number is Prime\n##################################################\n\ndef is_pseudoprime(n, bases = [2,3,5,7]):\n    \"\"\"\n    Returns True if n is a pseudoprime to the given bases,\n    in the sense that n>1 and b**(n-1) = 1 (mod n) for each \n    elements b of bases, with b not a multiple of n, and \n    False otherwise.   \n    Input:\n        n -- an integer\n        bases -- a list of integers\n    Output:\n        bool \n    Examples:\n    >>> is_pseudoprime(91)\n    False\n    >>> is_pseudoprime(97)\n    True\n    >>> is_pseudoprime(1)\n    False\n    >>> is_pseudoprime(-2)\n    True\n    >>> s = [x for x in range(10000) if is_pseudoprime(x)]\n    >>> t = primes(10000)\n    >>> s == t \n    True\n    >>> is_pseudoprime(29341) # first non-prime pseudoprime\n    True\n    >>> factor(29341)\n    [(13, 1), (37, 1), (61, 1)]\n    \"\"\"\n    if n < 0: n = -n                                \n    if n <= 1: return False\n    for b in bases:                       \n        if b%n != 0 and powermod(b, n-1, n) != 1:       \n            return False\n    return True\n\n\ndef miller_rabin(n, num_trials=4):\n    \"\"\"\n    True if n is likely prime, and False if n \n    is definitely not prime.  Increasing num_trials\n    increases the probability of correctness.\n    (One can prove that the probability that this \n    function returns True when it should return\n    False is at most (1/4)**num_trials.)\n    Input:\n        n -- an integer\n        num_trials -- the number of trials with the \n                      primality test.   \n    Output:\n        bool -- whether or not n is probably prime.\n    Examples:    \n    >>> miller_rabin(91)\n    False                         #rand\n    >>> miller_rabin(97)\n    True                          #rand\n    >>> s = [x for x in range(1000) if miller_rabin(x, 1)]\n    >>> t = primes(1000)\n    >>> print len(s), len(t)  # so 1 in 25 wrong\n    175 168                       #rand\n    >>> s = [x for x in range(1000) if miller_rabin(x)]\n    >>> s == t                    \n    True                          #rand\n    \"\"\"\n    if n < 0: n = -n\n    if n in [2,3]: return True\n    if n <= 4: return False\n    m = n - 1\n    k = 0\n    while m%2 == 0:\n        k += 1; m /= 2\n    # Now n - 1 = (2**k) * m with m odd\n    for i in range(num_trials):\n        a = randrange(2,n-1)                  # (1)\n        apow = powermod(a, m, n)\n        if not (apow in [1, n-1]):            \n            some_minus_one = False\n            for r in range(k-1):              # (2)\n                apow = (apow**2)%n\n                if apow == n-1:\n                    some_minus_one = True\n                    break                     # (3)\n        if (apow in [1, n-1]) or some_minus_one:\n            prob_prime = True\n        else:\n            return False\n    return True\n\n\n##################################################\n## The Diffie-Hellman Key Exchange\n##################################################\n\ndef random_prime(num_digits, is_prime = miller_rabin):\n    \"\"\"\n    Returns a random prime with num_digits digits.\n    Input:\n        num_digits -- a positive integer\n        is_prime -- (optional argment)\n                    a function of one argument n that\n                    returns either True if n is (probably)\n                    prime and False otherwise.\n    Output:\n        int -- an integer\n    Examples:\n    >>> random_prime(10)\n    8599796717L              #rand\n    >>> random_prime(40)\n    1311696770583281776596904119734399028761L  #rand\n    \"\"\" \n    n = randrange(10**(num_digits-1), 10**num_digits)\n    if n%2 == 0: n += 1\n    while not is_prime(n): n += 2\n    return n\n\ndef dh_init(p):\n    \"\"\"\n    Generates and returns a random positive\n    integer n < p and the power 2^n (mod p). \n    Input:\n        p -- an integer that is prime\n    Output:\n        int -- a positive integer < p,  a secret\n        int -- 2^n (mod p), send to other user\n    Examples:\n    >>> p = random_prime(20)\n    >>> dh_init(p)\n    (15299007531923218813L, 4715333264598442112L)   #rand\n    \"\"\"\n    n = randrange(2,p)\n    return n, powermod(2,n,p)\n\ndef dh_secret(p, n, mpow):\n    \"\"\"\n    Computes the shared Diffie-Hellman secret key.\n    Input:\n        p -- an integer that is prime\n        n -- an integer: output by dh_init for this user\n        mpow-- an integer: output by dh_init for other user\n    Output:\n        int -- the shared secret key.\n    Examples:\n    >>> p = random_prime(20)\n    >>> n, npow = dh_init(p)    \n    >>> m, mpow = dh_init(p)\n    >>> dh_secret(p, n, mpow) \n    15695503407570180188L      #rand\n    >>> dh_secret(p, m, npow)    \n    15695503407570180188L      #rand\n    \"\"\"\n    return powermod(mpow,n,p)\n\n\n\n\n\n\n##################################################\n## Encoding Strings as Lists of Integers\n##################################################\n\ndef str_to_numlist(s, bound):\n    \"\"\"\n    Returns a sequence of integers between 0 and bound-1 \n    that encodes the string s.   Randomization is included, \n    so the same string is very likely to encode differently \n    each time this function is called. \n    Input:\n        s -- a string\n        bound -- an integer >= 256\n    Output:\n        list -- encoding of s as a list of integers \n    Examples:\n    >>> str_to_numlist(\"Run!\", 1000)\n    [82, 117, 110, 33]               #rand\n    >>> str_to_numlist(\"TOP SECRET\", 10**20)\n    [4995371940984439512L, 92656709616492L]   #rand\n    \"\"\"\n    assert bound >= 256, \"bound must be at least 256.\"\n    n = int(log(bound) / log(256))          # (1)\n    salt = min(int(n/8) + 1, n-1)           # (2)\n    i = 0; v = []\n    while i < len(s):                       # (3)\n        c = 0; pow = 1\n        for j in range(n):                  # (4)\n            if j < salt:\n                c += randrange(1,256)*pow   # (5)\n            else:\n                if i >= len(s): break \n                c += ord(s[i])*pow          # (6)\n                i += 1\n            pow *= 256                      \n        v.append(c)\n    return v\n\ndef numlist_to_str(v, bound):\n    \"\"\"\n    Returns the string that the sequence v of \n    integers encodes. \n    Input:\n        v -- list of integers between 0 and bound-1\n        bound -- an integer >= 256\n    Output:\n        str -- decoding of v as a string\n    Examples:\n    >>> print numlist_to_str([82, 117, 110, 33], 1000)\n    Run!\n    >>> x = str_to_numlist(\"TOP SECRET MESSAGE\", 10**20)\n    >>> print numlist_to_str(x, 10**20)\n    TOP SECRET MESSAGE\n    \"\"\"\n    assert bound >= 256, \"bound must be at least 256.\"\n    n = int(log(bound) / log(256))\n    s = \"\"\n    salt = min(int(n/8) + 1, n-1)\n    for x in v:\n        for j in range(n):\n            y = x%256\n            if y > 0 and j >= salt:\n                s += chr(y)\n            x /= 256\n    return s\n\n\n##################################################\n## The RSA Cryptosystem\n##################################################\n\ndef rsa_init(p, q):\n    \"\"\"\n    Returns defining parameters (e, d, n) for the RSA\n    cryptosystem defined by primes p and q.  The\n    primes p and q may be computed using the \n    random_prime functions.\n    Input:\n        p -- a prime integer\n        q -- a prime integer\n    Output:\n        Let m be (p-1)*(q-1). \n        e -- an encryption key, which is a randomly\n             chosen integer between 2 and m-1\n        d -- the inverse of e modulo eulerphi(p*q), \n             as an integer between 2 and m-1\n        n -- the product p*q.\n    Examples:\n    >>> p = random_prime(20); q = random_prime(20)\n    >>> print p, q\n    37999414403893878907L 25910385856444296437L #rand\n    >>> e, d, n = rsa_init(p, q)\n    >>> e\n    5                                           #rand\n    >>> d\n    787663591619054108576589014764921103213L    #rand\n    >>> n\n    984579489523817635784646068716489554359L    #rand\n    \"\"\"\n    m = (p-1)*(q-1)\n    e = 3\n    while gcd(e, m) != 1: e += 1\n    d = inversemod(e, m)                  \n    return e, d, p*q\n\ndef rsa_encrypt(plain_text, e, n):\n    \"\"\"\n    Encrypt plain_text using the encrypt\n    exponent e and modulus n.  \n    Input:\n        plain_text -- arbitrary string\n        e -- an integer, the encryption exponent\n        n -- an integer, the modulus\n    Output:\n        str -- the encrypted cipher text\n    Examples:\n    >>> e = 1413636032234706267861856804566528506075\n    >>> n = 2109029637390047474920932660992586706589\n    >>> rsa_encrypt(\"Run Nikita!\", e, n)\n    [78151883112572478169375308975376279129L]    #rand\n    >>> rsa_encrypt(\"Run Nikita!\", e, n)\n    [1136438061748322881798487546474756875373L]  #rand\n    \"\"\"\n    plain = str_to_numlist(plain_text, n)\n    return [powermod(x, e, n) for x in plain]\n\ndef rsa_decrypt(cipher, d, n):\n    \"\"\"\n    Decrypt the cipher_text using the decryption\n    exponent d and modulus n.\n    Input:\n        cipher_text -- list of integers output \n                       by rsa_encrypt\n    Output:\n        str -- the unencrypted plain text\n    Examples:\n    >>> d = 938164637865370078346033914094246201579\n    >>> n = 2109029637390047474920932660992586706589\n    >>> msg1 = [1071099761433836971832061585353925961069]\n    >>> msg2 = [1336506586627416245118258421225335020977]\n    >>> rsa_decrypt(msg1, d, n)\n    'Run Nikita!'\n    >>> rsa_decrypt(msg2, d, n)\n    'Run Nikita!'\n    \"\"\"\n    plain = [powermod(x, d, n) for x in cipher]\n    return numlist_to_str(plain, n)\n\n\n##################################################\n## Computing the Legendre Symbol\n##################################################\n\ndef legendre(a, p):\n    \"\"\"\n    Returns the Legendre symbol a over p, where\n    p is an odd prime.\n    Input:\n        a -- an integer\n        p -- an odd prime (primality not checked)\n    Output:\n        int: -1 if a is not a square mod p,\n              0 if gcd(a,p) is not 1\n              1 if a is a square mod p.\n    Examples:\n    >>> legendre(2, 5)\n    -1\n    >>> legendre(3, 3)\n    0\n    >>> legendre(7, 2003)\n    -1\n    \"\"\"\n    assert p%2 == 1, \"p must be an odd prime.\"\n    b = powermod(a, (p-1)/2, p)\n    if b == 1: return 1\n    elif b == p-1: return -1\n    return 0\n\n\n##################################################\n## In this section we implement the algorithm\n##################################################\n\ndef sqrtmod(a, p):\n    \"\"\"\n    Returns a square root of a modulo p.\n    Input:\n        a -- an integer that is a perfect \n             square modulo p (this is checked)\n        p -- a prime\n    Output:\n        int -- a square root of a, as an integer\n               between 0 and p-1.\n    Examples:\n    >>> sqrtmod(4, 5)              # p == 1 (mod 4)\n    3              #rand\n    >>> sqrtmod(13, 23)            # p == 3 (mod 4)\n    6              #rand\n    >>> sqrtmod(997, 7304723089)   # p == 1 (mod 4)\n    761044645L     #rand\n    \"\"\"\n    a %= p\n    if p == 2: return a \n    assert legendre(a, p) == 1, \"a must be a square mod p.\"\n    if p%4 == 3: return powermod(a, (p+1)/4, p)\n\n    def mul(x, y):   # multiplication in R       # (1)\n        return ((x[0]*y[0] + a*y[1]*x[1]) % p, \\\n                (x[0]*y[1] + x[1]*y[0]) % p)\n    def pow(x, n):   # exponentiation in R       # (2)\n        ans = (1,0)\n        xpow = x\n        while n != 0:\n           if n%2 != 0: ans = mul(ans, xpow)\n           xpow = mul(xpow, xpow)\n           n /= 2\n        return ans\n\n    while True:\n        z = randrange(2,p)\n        u, v = pow((1,z), (p-1)/2)\n        if v != 0:\n            vinv = inversemod(v, p)\n            for x in [-u*vinv, (1-u)*vinv, (-1-u)*vinv]:\n                if (x*x)%p == a: return x%p\n            assert False, \"Bug in sqrtmod.\"\n\n\n##################################################\n## Continued Fractions\n##################################################\n\ndef convergents(v):\n    \"\"\"\n    Returns the partial convergents of the continued \n    fraction v.\n    Input:\n        v -- list of integers [a0, a1, a2, ..., am]\n    Output:\n        list -- list [(p0,q0), (p1,q1), ...] \n                of pairs (pm,qm) such that the mth \n                convergent of v is pm/qm.\n    Examples:\n    >>> convergents([1, 2])\n    [(1, 1), (3, 2)]\n    >>> convergents([3, 7, 15, 1, 292])\n    [(3, 1), (22, 7), (333, 106), (355, 113), (103993, 33102)]\n    \"\"\"\n    w = [(0,1), (1,0)]\n    for n in range(len(v)):\n        pn = v[n]*w[n+1][0] + w[n][0]\n        qn = v[n]*w[n+1][1] + w[n][1]\n        w.append((pn, qn))\n    del w[0]; del w[0]  # remove first entries of w\n    return w\n\ndef contfrac_rat(numer, denom):\n    \"\"\"\n    Returns the continued fraction of the rational \n    number numer/denom.\n    Input:\n        numer -- an integer\n        denom -- a positive integer coprime to num\n    Output\n        list -- the continued fraction [a0, a1, ..., am]\n                of the rational number num/denom.\n    Examples:\n    >>> contfrac_rat(3, 2)\n    [1, 2]\n    >>> contfrac_rat(103993, 33102)\n    [3, 7, 15, 1, 292]\n    \"\"\"\n    assert denom > 0, \"denom must be positive\"\n    a = numer; b = denom\n    v = []\n    while b != 0:\n        v.append(a/b)\n        (a, b) = (b, a%b)\n    return v\n\ndef contfrac_float(x):\n    \"\"\"\n    Returns the continued fraction of the floating\n    point number x, computed using the continued\n    fraction procedure, and the sequence of partial\n    convergents.\n    Input:\n        x -- a floating point number (decimal)\n    Output:\n        list -- the continued fraction [a0, a1, ...]\n                obtained by applying the continued \n                fraction procedure to x to the \n                precision of this computer.\n        list -- the list [(p0,q0), (p1,q1), ...] \n                of pairs (pm,qm) such that the mth \n                convergent of continued fraction \n                is pm/qm.\n    Examples:\n    >>> v, w = contfrac_float(3.14159); print v\n    [3, 7, 15, 1, 25, 1, 7, 4]\n    >>> v, w = contfrac_float(2.718); print v\n    [2, 1, 2, 1, 1, 4, 1, 12]\n    >>> contfrac_float(0.3)\n    ([0, 3, 2, 1], [(0, 1), (1, 3), (2, 7), (3, 10)])\n    \"\"\"\n    v = []\n    w = [(0,1), (1,0)] # keep track of convergents\n    start = x\n    while True:\n        a = int(x)                                  # (1)\n        v.append(a)\n        n = len(v)-1\n        pn = v[n]*w[n+1][0] + w[n][0]\n        qn = v[n]*w[n+1][1] + w[n][1]\n        w.append((pn, qn))\n        x -= a\n        if abs(start - float(pn)/float(qn)) == 0:    # (2)\n            del w[0]; del w[0]                       # (3)\n            return v, w\n        x = 1/x\n\ndef sum_of_two_squares(p):\n    \"\"\"\n    Uses continued fractions to efficiently compute \n    a representation of the prime p as a sum of\n    two squares.   The prime p must be 1 modulo 4.\n    Input:\n        p -- a prime congruent 1 modulo 4.\n    Output:\n        integers a, b such that p is a*a + b*b\n    Examples:\n    >>> sum_of_two_squares(5)\n    (1, 2)\n    >>> sum_of_two_squares(389)\n    (10, 17)\n    >>> sum_of_two_squares(86295641057493119033)\n    (789006548L, 9255976973L)\n    \"\"\"\n    assert p%4 == 1, \"p must be 1 modulo 4\"\n    r = sqrtmod(-1, p)                                # (1)\n    v = contfrac_rat(-r, p)                           # (2)\n    n = int(sqrt(p))                          \n    for a, b in convergents(v):                       # (3)\n        c = r*b + p*a                                 # (4)\n        if -n <= c and c <= n: return (abs(b),abs(c))\n    assert False, \"Bug in sum_of_two_squares.\"        # (5)\n\n\n##################################################\n## Arithmetic\n##################################################\n\ndef ellcurve_add(E, P1, P2):\n    \"\"\"\n    Returns the sum of P1 and P2 on the elliptic \n    curve E.\n    Input:\n         E -- an elliptic curve over Z/pZ, given by a \n              triple of integers (a, b, p), with p odd.\n         P1 --a pair of integers (x, y) or the \n              string \"Identity\".\n         P2 -- same type as P1\n    Output:\n         R -- same type as P1\n    Examples:\n    >>> E = (1, 0, 7)   # y**2 = x**3 + x over Z/7Z\n    >>> P1 = (1, 3); P2 = (3, 3)\n    >>> ellcurve_add(E, P1, P2)\n    (3, 4)\n    >>> ellcurve_add(E, P1, (1, 4))\n    'Identity'\n    >>> ellcurve_add(E, \"Identity\", P2)\n    (3, 3)\n    \"\"\" \n    a, b, p = E\n    assert p > 2, \"p must be odd.\"\n    if P1 == \"Identity\": return P2\n    if P2 == \"Identity\": return P1\n    x1, y1 = P1; x2, y2 = P2\n    x1 %= p; y1 %= p; x2 %= p; y2 %= p\n    if x1 == x2 and y1 == p-y2: return \"Identity\"\n    if P1 == P2:\n        if y1 == 0: return \"Identity\"\n        lam = (3*x1**2+a) * inversemod(2*y1,p)\n    else:\n        lam = (y1 - y2) * inversemod(x1 - x2, p)\n    x3 = lam**2 - x1 - x2\n    y3 = -lam*x3 - y1 + lam*x1\n    return (x3%p, y3%p)\n\ndef ellcurve_mul(E, m, P):\n    \"\"\"\n    Returns the multiple m*P of the point P on \n    the elliptic curve E.\n    Input:\n        E -- an elliptic curve over Z/pZ, given by a \n             triple (a, b, p).\n        m -- an integer\n        P -- a pair of integers (x, y) or the \n             string \"Identity\"\n    Output:\n        A pair of integers or the string \"Identity\".\n    Examples:\n    >>> E = (1, 0, 7)\n    >>> P = (1, 3)\n    >>> ellcurve_mul(E, 5, P)\n    (1, 3)\n    >>> ellcurve_mul(E, 9999, P)\n    (1, 4)\n    \"\"\"   \n    assert m >= 0, \"m must be nonnegative.\"\n    power = P\n    mP = \"Identity\"\n    while m != 0:\n        if m%2 != 0: mP = ellcurve_add(E, mP, power)\n        power = ellcurve_add(E, power, power)\n        m /= 2\n    return mP\n\n\n##################################################\n## Integer Factorization\n##################################################\n\ndef lcm_to(B):\n    \"\"\"\n    Returns the least common multiple of all \n    integers up to B.\n    Input:\n        B -- an integer\n    Output:\n        an integer\n    Examples:\n    >>> lcm_to(5)\n    60\n    >>> lcm_to(20)\n    232792560\n    >>> lcm_to(100)\n    69720375229712477164533808935312303556800L\n    \"\"\"\n    ans = 1\n    logB = log(B)\n    for p in primes(B):\n        ans *= p**int(logB/log(p))\n    return ans\n\ndef pollard(N, m):\n    \"\"\"\n    Use Pollard's (p-1)-method to try to find a\n    nontrivial divisor of N.\n    Input:\n        N -- a positive integer\n        m -- a positive integer, the least common\n             multiple of the integers up to some \n             bound, computed using lcm_to.\n    Output:\n        int -- an integer divisor of n\n    Examples:\n    >>> pollard(5917, lcm_to(5))\n    61\n    >>> pollard(779167, lcm_to(5))\n    779167\n    >>> pollard(779167, lcm_to(15))\n    2003L\n    >>> pollard(187, lcm_to(15))\n    11\n    >>> n = random_prime(5)*random_prime(5)*random_prime(5)\n    >>> pollard(n, lcm_to(100))\n    315873129119929L     #rand\n    >>> pollard(n, lcm_to(1000))\n    3672986071L          #rand\n    \"\"\"\n    for a in [2, 3]:\n        x = powermod(a, m, N) - 1\n        g = gcd(x, N)\n        if g != 1 and g != N:\n            return g\n    return N\n\ndef randcurve(p):\n    \"\"\"\n    Construct a somewhat random elliptic curve \n    over Z/pZ and a random point on that curve.\n    Input:\n        p -- a positive integer\n    Output:\n        tuple -- a triple E = (a, b, p) \n        P -- a tuple (x,y) on E\n    Examples:\n    >>> p = random_prime(20); p\n    17758176404715800329L    #rand\n    >>> E, P = randcurve(p)\n    >>> print E\n    (15299007531923218813L, 1, 17758176404715800329L)  #rand\n    >>> print P\n    (0, 1)\n    \"\"\"\n    assert p > 2, \"p must be > 2.\"\n    a = randrange(p)\n    while gcd(4*a**3 + 27, p) != 1:\n        a = randrange(p)\n    return (a, 1, p), (0,1)\n\ndef elliptic_curve_method(N, m, tries=5):\n    \"\"\"\n    Use the elliptic curve method to try to find a\n    nontrivial divisor of N.\n    Input:\n        N -- a positive integer\n        m -- a positive integer, the least common\n             multiple of the integers up to some\n             bound, computed using lcm_to.\n        tries -- a positive integer, the number of\n             different elliptic curves to try\n    Output:\n        int -- a divisor of n\n    Examples:\n    >>> elliptic_curve_method(5959, lcm_to(20))\n    59L       #rand\n    >>> elliptic_curve_method(10007*20011, lcm_to(100))\n    10007L   #rand\n    >>> p = random_prime(9); q = random_prime(9)\n    >>> n = p*q; n\n    117775675640754751L   #rand\n    >>> elliptic_curve_method(n, lcm_to(100))\n    117775675640754751L   #rand\n    >>> elliptic_curve_method(n, lcm_to(500))\n    117775675640754751L   #rand\n    \"\"\"\n    for _ in range(tries):                     # (1)\n        E, P = randcurve(N)                    # (2)\n        try:                                   # (3)\n            Q = ellcurve_mul(E, m, P)          # (4)\n        except ZeroDivisionError, x:           # (5)\n            g = gcd(x[0],N)                    # (6)\n            if g != 1 or g != N: return g      # (7)\n    return N             \n\n\n##################################################\n## ElGamal Elliptic Curve Cryptosystem\n##################################################\n\ndef elgamal_init(p):\n    \"\"\"\n    Constructs an ElGamal cryptosystem over Z/pZ, by\n    choosing a random elliptic curve E over Z/pZ, a \n    point B in E(Z/pZ), and a random integer n.  This\n    function returns the public key as a 4-tuple \n    (E, B, n*B) and the private key n.\n    Input:\n        p -- a prime number\n    Output:\n        tuple -- the public key as a 3-tuple\n                 (E, B, n*B), where E = (a, b, p) is an \n                 elliptic curve over Z/pZ, B = (x, y) is\n                 a point on E, and n*B = (x',y') is\n                 the sum of B with itself n times.\n        int -- the private key, which is the pair (E, n)\n    Examples:\n    >>> p = random_prime(20); p\n    17758176404715800329L    #rand\n    >>> public, private = elgamal_init(p)\n    >>> print \"E =\", public[0]\n    E = (15299007531923218813L, 1, 17758176404715800329L)   #rand\n    >>> print \"B =\", public[1]\n    B = (0, 1)\n    >>> print \"nB =\", public[2]\n    nB = (5619048157825840473L, 151469105238517573L)   #rand\n    >>> print \"n =\", private[1]\n    n = 12608319787599446459    #rand\n    \"\"\"\n    E, B = randcurve(p)\n    n = randrange(2,p)    \n    nB = ellcurve_mul(E, n, B)\n    return (E, B, nB), (E, n)\n\ndef elgamal_encrypt(plain_text, public_key):\n    \"\"\"\n    Encrypt a message using the ElGamal cryptosystem\n    with given public_key = (E, B, n*B).\n    Input:\n       plain_text -- a string\n       public_key -- a triple (E, B, n*B), as output\n                     by elgamal_init.\n    Output:\n       list -- a list of pairs of points on E that \n               represent the encrypted message\n    Examples:\n    >>> public, private = elgamal_init(random_prime(20))\n    >>> elgamal_encrypt(\"RUN\", public)\n    [((6004308617723068486L, 15578511190582849677L), \\ #rand\n     (7064405129585539806L, 8318592816457841619L))]    #rand\n    \"\"\"\n    E, B, nB = public_key\n    a, b, p = E \n    assert p > 10000, \"p must be at least 10000.\"\n    v = [1000*x for x in \\\n           str_to_numlist(plain_text, p/1000)]       # (1)\n    cipher = []\n    for x in v:\n        while not legendre(x**3+a*x+b, p)==1:        # (2)\n            x = (x+1)%p  \n        y = sqrtmod(x**3+a*x+b, p)                   # (3)\n        P = (x,y)    \n        r = randrange(1,p)\n        encrypted = (ellcurve_mul(E, r, B), \\\n                ellcurve_add(E, P, ellcurve_mul(E,r,nB)))\n        cipher.append(encrypted)\n    return cipher   \n\ndef elgamal_decrypt(cipher_text, private_key):\n    \"\"\"\n    Encrypt a message using the ElGamal cryptosystem\n    with given public_key = (E, B, n*B).\n    Input:\n        cipher_text -- list of pairs of points on E output\n                       by elgamal_encrypt.\n    Output:\n        str -- the unencrypted plain text\n    Examples:\n    >>> public, private = elgamal_init(random_prime(20))\n    >>> v = elgamal_encrypt(\"TOP SECRET MESSAGE!\", public)\n    >>> print elgamal_decrypt(v, private)\n    TOP SECRET MESSAGE!\n    \"\"\"\n    E, n = private_key\n    p = E[2]\n    plain = []\n    for rB, P_plus_rnB in cipher_text:\n        nrB = ellcurve_mul(E, n, rB)\n        minus_nrB = (nrB[0], -nrB[1])\n        P = ellcurve_add(E, minus_nrB, P_plus_rnB)\n        plain.append(P[0]/1000)\n    return numlist_to_str(plain, p/1000)\n\n\n##################################################\n## Associativity of the Group Law\n##################################################\n\n# The variable order is x1, x2, x3, y1, y2, y3, a, b\nclass Poly:                                     # (1)\n    def __init__(self, d):                      # (2)\n        self.v = dict(d)                        \n    def __cmp__(self, other):                   # (3)\n        self.normalize(); other.normalize()     # (4)\n        if self.v == other.v: return 0\n        return -1\n\n    def __add__(self, other):                   # (5)\n        w = Poly(self.v)\n        for m in other.monomials():\n            w[m] += other[m]\n        return w\n    def __sub__(self, other):\n        w = Poly(self.v)\n        for m in other.monomials():\n            w[m] -= other[m]\n        return w\n    def __mul__(self, other):\n        if len(self.v) == 0 or len(other.v) == 0: \n            return Poly([])\n        m1 = self.monomials(); m2 = other.monomials()\n        r = Poly([])\n        for m1 in self.monomials():\n            for m2 in other.monomials():\n                z = [m1[i] + m2[i] for i in range(8)]\n                r[z] += self[m1]*other[m2]\n        return r\n    def __neg__(self):\n        v = {}\n        for m in self.v.keys():\n            v[m] = -self.v[m]\n        return Poly(v)\n    def __div__(self, other):\n        return Frac(self, other)\n\n    def __getitem__(self, m):                   # (6)\n        m = tuple(m)\n        if not self.v.has_key(m): self.v[m] = 0\n        return self.v[m]\n    def __setitem__(self, m, c):\n        self.v[tuple(m)] = c\n    def __delitem__(self, m):\n        del self.v[tuple(m)]\n\n    def monomials(self):                        # (7)\n        return self.v.keys()\n    def normalize(self):                        # (8)\n        while True:\n            finished = True\n            for m in self.monomials():\n                if self[m] == 0:\n                    del self[m]\n                    continue\n                for i in range(3):\n                    if m[3+i] >= 2:  \n                        finished = False\n                        nx0 = list(m); nx0[3+i] -= 2; \n                        nx0[7] += 1\n                        nx1 = list(m); nx1[3+i] -= 2; \n                        nx1[i] += 1; nx1[6] += 1\n                        nx3 = list(m); nx3[3+i] -= 2; \n                        nx3[i] += 3\n                        c = self[m]\n                        del self[m]\n                        self[nx0] += c; \n                        self[nx1] += c; \n                        self[nx3] += c\n                # end for\n            # end for\n            if finished: return\n        # end while\n\none = Poly({(0,0,0,0,0,0,0,0):1})               # (9)\n\nclass Frac:                                     # (10)\n    def __init__(self, num, denom=one):         \n        self.num = num; self.denom = denom\n    def __cmp__(self, other):                   # (11)\n        if self.num * other.denom == self.denom * other.num:\n            return 0\n        return -1\n\n    def __add__(self, other):                   # (12)\n        return Frac(self.num*other.denom + \\\n                    self.denom*other.num, \n                    self.denom*other.denom)\n    def __sub__(self, other):\n        return Frac(self.num*other.denom - \\\n                    self.denom*other.num,\n                    self.denom*other.denom)\n    def __mul__(self, other):\n        return Frac(self.num*other.num, \\\n                    self.denom*other.denom)\n    def __div__(self, other):\n        return Frac(self.num*other.denom, \\\n                    self.denom*other.num)\n    def __neg__(self):\n        return Frac(-self.num,self.denom)\n\ndef var(i):                                     # (14)\n    v = [0,0,0,0,0,0,0,0]; v[i]=1; \n    return Frac(Poly({tuple(v):1}))\n\ndef prove_associative():                        # (15)\n    x1 = var(0); x2 = var(1); x3 = var(2)\n    y1 = var(3); y2 = var(4); y3 = var(5)\n    a  = var(6); b  = var(7)\n    \n    lambda12 = (y1 - y2)/(x1 - x2)              \n    x4       = lambda12*lambda12 - x1 - x2\n    nu12     = y1 - lambda12*x1   \n    y4       = -lambda12*x4 - nu12\n    lambda23 = (y2 - y3)/(x2 - x3)\n    x5       = lambda23*lambda23 - x2 - x3\n    nu23     = y2 - lambda23*x2\n    y5       = -lambda23*x5 - nu23\n    s1 = (x1 - x5)*(x1 - x5)*((y3 - y4)*(y3 - y4) \\\n                   - (x3 + x4)*(x3 - x4)*(x3 - x4))\n    s2 = (x3 - x4)*(x3 - x4)*((y1 - y5)*(y1 - y5) \\\n                   - (x1 + x5)*(x1 - x5)*(x1 - x5))\n    print \"Associative?\"\n    print s1 == s2                              # (17)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n##########################################################\n# The following are all the examples not in functions.   #\n##########################################################\n\ndef examples():\n    \"\"\"\n    >>> from ent import *\n    >>> 7/5\n    1\n    >>> -2/3\n    -1\n    >>> 1.0/3\n    0.33333333333333331\n    >>> float(2)/3\n    0.66666666666666663\n    >>> 100**2\n    10000\n    >>> 10**20\n    100000000000000000000L\n    >>> range(10)            # range(n) is from 0 to n-1       \n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> range(3,10)          # range(a,b) is from a to b-1\n    [3, 4, 5, 6, 7, 8, 9]\n    >>> [x**2 for x in range(10)]\n    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n    >>> [x**2 for x in range(10) if x%4 == 1]\n    [1, 25, 81]\n    >>> [1,2,3] + [5,6,7]    # concatenation\n    [1, 2, 3, 5, 6, 7]\n    >>> len([1,2,3,4,5])     # length of a list\n    5\n    >>> x = [4,7,10,'gcd']   # mixing types is fine\n    >>> x[0]                 # 0-based indexing\n    4\n    >>> x[3]\n    'gcd'\n    >>> x[3] = 'lagrange'    # assignment\n    >>> x.append(\"fermat\")   # append to end of list\n    >>> x\n    [4, 7, 10, 'lagrange', 'fermat']\n    >>> del x[3]             # delete entry 3 from list\n    >>> x\n    [4, 7, 10, 'fermat']\n    >>> v = primes(10000)\n    >>> len(v)    # this is pi(10000)\n    1229\n    >>> len([x for x in v if x < 1000])   # pi(1000)\n    168\n    >>> len([x for x in v if x < 5000])   # pi(5000)\n    669\n    >>> x=(1, 2, 3)       # creation\n    >>> x[1]\n    2\n    >>> (1, 2, 3) + (4, 5, 6)  # concatenation\n    (1, 2, 3, 4, 5, 6)\n    >>> (a, b) = (1, 2)        # assignment assigns to each member\n    >>> print a, b\n    1 2\n    >>> for (c, d) in [(1,2), (5,6)]:   \n    ...     print c, d\n    1 2\n    5 6\n    >>> x = 1, 2          # parentheses optional in creation\n    >>> x\n    (1, 2)\n    >>> c, d = x          # parentheses also optional \n    >>> print c, d\n    1 2\n    >>> P = [p for p in range(200000) if is_pseudoprime(p)]\n    >>> Q = primes(200000)\n    >>> R = [x for x in P if not (x in Q)]; print R\n    [29341, 46657, 75361, 115921, 162401]\n    >>> [n for n in R if is_pseudoprime(n,[2,3,5,7,11,13])]\n    [162401]\n    >>> factor(162401)\n    [(17, 1), (41, 1), (233, 1)]\n    >>> p = random_prime(50)\n    >>> p\n    13537669335668960267902317758600526039222634416221L #rand\n    >>> n, npow = dh_init(p)\n    >>> n\n    8520467863827253595224582066095474547602956490963L  #rand\n    >>> npow\n    3206478875002439975737792666147199399141965887602L  #rand\n    >>> m, mpow = dh_init(p)\n    >>> m\n    3533715181946048754332697897996834077726943413544L  #rand\n    >>> mpow\n    3465862701820513569217254081716392362462604355024L  #rand\n    >>> dh_secret(p, n, mpow)\n    12931853037327712933053975672241775629043437267478L #rand\n    >>> dh_secret(p, m, npow)\n    12931853037327712933053975672241775629043437267478L #rand\n    >>> prove_associative()\n    Associative?\n    True\n    >>> len(primes(10000))\n    1229\n    >>> 10000/log(10000)\n    1085.73620476\n    >>> powermod(3,45,100)\n    43\n    >>> inversemod(37, 112)\n    109\n    >>> powermod(102, 70, 113)\n    98\n    >>> powermod(99, 109, 113)\n    60\n    >>> P = primes(1000)\n    >>> Q = [p for p in P if primitive_root(p) == 2]\n    >>> print len(Q), len(P)\n    67 168\n    >>> P = primes(50000)\n    >>> Q = [primitive_root(p) for p in P]\n    >>> Q.index(37)\n    3893\n    >>> P[3893]\n    36721\n    >>> for n in range(97):\n    ...     if powermod(5,n,97)==3: print n\n    70\n    >>> factor(5352381469067)\n    [(141307, 1), (37877681L, 1)]\n    >>> d=inversemod(4240501142039, (141307-1)*(37877681-1))\n    >>> d\n    5195621988839L\n    >>> convergents([-3,1,1,1,1,3])\n    [(-3, 1), (-2, 1), (-5, 2), (-7, 3), \\\n              (-12, 5), (-43, 18)]\n    >>> convergents([0,2,4,1,8,2])\n    [(0, 1), (1, 2), (4, 9), (5, 11), \\\n              (44, 97), (93, 205)]\n    >>> import math\n    >>> e = math.exp(1)\n    >>> v, convs = contfrac_float(e)\n    >>> [(a,b) for a, b in convs if \\\n           abs(e - a*1.0/b) < 1/(math.sqrt(5)*b**2)]\n    [(3, 1), (19, 7), (193, 71), (2721, 1001),\\\n     (49171, 18089), (1084483, 398959),\\\n     (28245729, 10391023), (325368125, 119696244)]\n    >>> factor(12345)\n    [(3, 1), (5, 1), (823, 1)]\n    >>> factor(729)\n    [(3, 6)]\n    >>> factor(5809961789)\n    [(5809961789L, 1)]\n    >>> 5809961789 % 4\n    1L\n    >>> sum_of_two_squares(5809961789)\n    (51542L, 56155L)\n    >>> N = [60 + s for s in range(-15,16)]\n    >>> def is_powersmooth(B, x):\n    ...     for p, e in factor(x):\n    ...         if p**e > B: return False\n    ...     return True\n    >>> Ns = [x for x in N if is_powersmooth(20, x)]\n    >>> print len(Ns), len(N), len(Ns)*1.0/len(N)\n    14 31 0.451612903226\n    >>> P = [x for x in range(10**12, 10**12+1000)\\\n             if miller_rabin(x)]\n    >>> Ps = [x for x in P if \\\n             is_powersmooth(10000, x-1)]  \n    >>> print len(Ps), len(P), len(Ps)*1.0/len(P)\n    2 37 0.0540540540541\n    \n    \"\"\"\n\n\nif __name__ ==  '__main__':\n    import doctest, sys\n    doctest.testmod(sys.modules[__name__])\n",
    "solution\\PohligHellman\\LICENSE": "Copyright (c) 2013, Pietro Saccardi\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met: \n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer. \n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution. \n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies, \neither expressed or implied, of the FreeBSD Project.",
    "category": "Crypto"
}