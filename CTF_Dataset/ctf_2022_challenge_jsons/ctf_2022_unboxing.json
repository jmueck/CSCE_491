{
    "chall.py": "#!/usr/bin/python3\n\nfrom random import randint, shuffle\nfrom keystone import *\nfrom os import urandom\nfrom subprocess import run, check_output\nimport binascii\nimport atexit\n\ncreated_challenges = []\n\n@atexit.register\ndef cleanup():\n\t# we clean up files at the end of each round but to prevent accumulation over time lets also do it onexit in case of exceptions and the like\n\tglobal created_challenges\n\tfor chall in created_challenges:\n\t\trun(f\"rm -f /tmp/{chall}*\",shell=True)\n\ndef make_challenge():\n\tdef make_unpack(remaining_count, xor_num):\n\t\treturn \"\"\"\n\t\tlea rax, [rip+after]\n\t\tmov rcx, {}\n\t\tloop:\n\t\txor byte ptr [rax], {}\n\t\tinc rax\n\t\tdec rcx\n\t\tjnz loop\n\t\tafter:\n\t\t\"\"\".format(remaining_count, xor_num)\n\n\n\tdef make_check(flag_idx, output_idx, compare_num):\n\t\treturn \"\"\"\n\t\tstart:\n\t\tlea rbx, [r8 + {}]\n\t\tmov bl, [rbx]\n\t\txor bl, {}\n\t\tlea rcx, [r9 + {}]\n\t\tmov byte ptr [rcx], bl\n\t\tlea rax, [rip+start]\n\t\tmov rcx, 13\n\t\tloop:\n\t\tmov byte ptr [rax], 0\n\t\tinc rax\n\t\tdec rcx\n\t\tjnz loop\n\t\t\"\"\".format(flag_idx, compare_num, output_idx)\n\n\tdef xor_repeated(string, operand):\n\t\treturn [x^operand for x in string]\n\n\n\tPAD_LEN = 1024\n\n\tflag = binascii.b2a_hex(urandom(32))\n\n\tbytecode = []\n\n\tflag = [(flag[x], x, True) if x < len(flag) else (0, randint(0,64), False) for x in range(PAD_LEN)]\n\tshuffle(flag)\n\tchecks = []\n\tks = Ks(KS_ARCH_X86, KS_MODE_64)\n\tfor (output_idx, (char, idx, isRealChar)) in enumerate(flag):\n\t\tif isRealChar:\n\t\t\tchecks += [f\"output[{output_idx}] == 0\"]\n\t\txor_op = randint(0, 255)\n\t\tbytecode = xor_repeated(list(bytes(ks.asm(make_check(idx,output_idx,char))[0]).ljust(43,b'\\x90')) + bytecode, xor_op)\n\t\tbytecode = ks.asm(make_unpack(len(bytecode), xor_op))[0] + bytecode\n\tbytecode += [0xc3]\n\n\tc_src = \"\"\"\n\t#include <sys/mman.h>\n\t#include <stdio.h>\n\t#include <string.h>\n\t#include <stdlib.h>\n\n\textern char __executable_start;\n\textern char __etext;\n\tchar check[] = {{{}}};\n\n\tchar input[64];\n\tchar output[{}];\n\n\tvoid main() {{\n\t\tvoid* code = mmap(NULL, sizeof(check), PROT_WRITE | PROT_READ | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\t\tmemcpy(code, &check, sizeof(check));\n\t\tread(0, input, 64);\n\t\tmemset(output, 0, 256);\n\t\t__asm__ __volatile__ ( \n\t\t\t\"movq %0, %%r8\"\n\t\t\t: : \"r\"(input) : \"memory\"\n\t\t);\n\t\t__asm__ __volatile__ ( \n\t\t\t\"movq %0, %%r9\"\n\t\t\t: : \"r\"(output) : \"memory\"\n\t\t);\n\t\t((void (*)()) code)();\n\t\tif({}) {{\n\t\t\tputs(\"correct :)\");\n\t\t\texit(0);\n\t\t}} else {{\n\t\t\tputs(\"wrong :(\");\n\t\t\texit(1);\n\t\t}}\n\t}}\n\n\t\"\"\".format(\", \".join([str(x) for x in bytecode]), PAD_LEN, \" && \".join(checks))\n\treturn c_src\n\nfor i in range(5):\n\tcode = make_challenge()\n\tname = binascii.b2a_hex(urandom(15)).decode()\n\tcreated_challenges.append(name)\n\twith open(f\"/tmp/{name}.c\",\"w\") as f:\n\t\tf.write(code)\n\trun(f\"gcc /tmp/{name}.c -o /tmp/{name}\",shell=True, capture_output=True)\n\trun(f\"chmod +x /tmp/{name}\",shell=True, capture_output=True)\n\twith open(f\"/tmp/{name}\",\"rb\") as f:\n\t\tprint(f.read().hex())\n\n\trequest = bytes.fromhex(input().rstrip())\n\tif run(f\"/tmp/{name}\", input=request, shell=True, capture_output=True).returncode == 0:\n\t\trun(f\"rm /tmp/{name}*\",shell=True)\n\t\tcontinue\n\texit(1)\n\nwith open(\"/unboxing/flag.txt\", \"r\") as f:\n\tprint(f.read())",
    "Dockerfile": "FROM debian:buster-slim\n\nARG port\n\nRUN apt-get update -y; apt-get install python3 python3-pip socat build-essential libffi-dev -y\nRUN pip3 install --upgrade pip && pip3 install keystone-engine\nRUN mkdir /unboxing\nADD chall.py /unboxing/chall.py\nADD flag.txt /unboxing/flag.txt\n\nEXPOSE $port\n\nENTRYPOINT [\"socat\", \"-s\", \"TCP-LISTEN:11002,reuseaddr,fork\", \"EXEC:timeout 5m python3 /unboxing/chall.py,stderr\"]",
    "flag.txt": "gigem{unb0x1n6_74muc7f5_m057_3xclu51v3_fl46_ch3ck3r}\n",
    "Makefile": "NAME := unboxing\nPORT := 11002\n\ndocker: Dockerfile\n\tdocker build -t $(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --tmpfs /tmp:exec --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\n.PHONY:",
    "README.md": "# Unboxing\n\n## Description\nCrack the passwords and get the flag!\n\nThis is an automatic reversing challenge. You will be provided an ELF as a hex string. You should analyze the binary, determine the input which makes the binary respond \"correct :)\", and then respond to the server with your input in the same format. You will need to do this five times within a five minute timeout. \n\n## Solution\nSee `solve.py`.\n",
    "solve.py": "#!/usr/bin/python3\n\nfrom pwn import *\nfrom capstone import *\nfrom subprocess import run\n\nr = remote(\"tamuctf.com\", 443, ssl=True, sni=\"unboxing\")\n\nfor idx in range(5):\n\n    with open(f\"elf\", \"wb\") as file:\n        file.write(bytes.fromhex(r.recvline().rstrip().decode()))\n    exe = ELF(f\"elf\")\n\n    md = Cs(CS_ARCH_X86, CS_MODE_64)\n\n    data = exe.read(exe.symbols['check'],(43 + 25) * 1024)\n    constraints = []\n    for i in range(1024):\n        xor_remaining = int(next(x for x in md.disasm(data[:25], 0) if x.mnemonic == 'xor').op_str.split(\", \")[1],16)\n        data = bytes([x^xor_remaining for x in data[25:]])\n        instrs = list(md.disasm(data[:43], 0))\n        try:\n            flag_idx = int(instrs[0].op_str.split(\" + \")[1][:-1],16)\n        except Exception as e:\n            flag_idx = 0\n        compare = int(instrs[2].op_str.split(\", \")[1],16)\n        try:\n            out_idx = int(instrs[3].op_str.split(\" + \")[1][:-1],16)\n        except Exception as e:\n            out_idx = 0\n        constraints.append((flag_idx, compare, out_idx))\n        data = data[43:]\n\n\n    required_outputs = [0 if x == '' else int(x,16) for x in run(f\"objdump -Mintel -D ./elf | rg \\\".*?movzx.*?output(\\+?.*?)>\\\" -r '$1' \",shell=True, stdout=PIPE, stderr=PIPE).stdout.decode().split('\\n')[:-1]]\n    flag = [0 for x in range(64)]\n\n\n    map_constraints = {output_idx: (flag_idx, val) for (flag_idx, val, output_idx) in constraints}\n    for i in required_outputs:\n        flag_idx, val = map_constraints[i]\n        if flag[flag_idx] != 0:\n            print(\"overconstrained??\")\n            exit(1)\n        flag[flag_idx] = chr(val)\n    \n    flag = ''.join(flag)\n    print(f'trying {flag}')\n    r.sendline(flag.encode().hex())\nr.interactive()\n",
    "solver-template.py": "from pwn import *\n\np = remote(\"tamuctf.com\", 443, ssl=True, sni=\"unboxing\")\nfor binary in range(5):\n  with open(\"elf\", \"wb\") as file:\n    file.write(bytes.fromhex(p.recvline().rstrip().decode()))\n\n  # send whatever data you want\n  p.sendline(b\"howdy\".hex())\n  p.recvline() # receive response from the server. the binary will respond with either \"correct :)\" or \"wrong :(\" depending on the exit code\n\np.interactive()",
    "category": "reversing"
}