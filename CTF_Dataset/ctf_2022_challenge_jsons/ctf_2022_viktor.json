{
    "create.py": "import asyncio\nimport socket\nimport hashlib\n\nfrom time import sleep, time\n\n### CONSTANTS ###\nPORTNUM = 39193\nTIMEDPRINT = 0.08\nFLAG = \"gigem{l1n3ar_1nd3p3nd3nc3_0f_v3ct0rs_0xMONEY}\"\nCONSTHASH = \"667a32132baf411ebf34c81a242d9ef4bf72e288\"\n\ndef timedOutput(writer, msg, delay):\n    for c in msg:\n        try:\n            writer.write(bytes(c, \"utf-8\"))\n            sleep(delay)\n        except:\n            writer.close()\n            return\n\ndef XOR(x, y):\n    return \"\".join([str(hex(int(a, 16)^int(b, 16)))[2:] for a,b in zip(x, y)])\n\n### SERVER STUFF ###\nasync def handle_client(reader, writer):\n    timedOutput(writer, \"[==== BOOT SEQUENCE INITATED ====]\\n\", TIMEDPRINT)\n    timedOutput(writer, \"Waiting for connection\", TIMEDPRINT)\n    timedOutput(writer, \".....\", 8*TIMEDPRINT)\n    timedOutput(writer, \"\\nData transfer complete\\n\", TIMEDPRINT)\n    timedOutput(writer, \"Expected Command Sequence Hash = \", TIMEDPRINT)\n    timedOutput(writer, CONSTHASH, TIMEDPRINT)\n    timedOutput(writer, \"\\nPlease enter the commands line by line\\n\", TIMEDPRINT)\n    timedOutput(writer, \"When finished enter the command \\\"EXECUTE\\\" on the final line\\n\", TIMEDPRINT)\n\n\n    inputList = []\n    usrInput = (await reader.readline()).decode(\"utf-8\").rstrip()\n    while(usrInput != \"EXECUTE\"):\n        inputList.append(usrInput)\n        usrInput = (await reader.readline()).decode(\"utf-8\").rstrip()\n\n    hashList = [hashlib.sha1(x.encode()).hexdigest() for x in inputList]\n    hashVal = hashList[0]\n    for i in range(1, len(hashList)):\n        hashVal = XOR(hashVal, hashList[i]) \n\n    timedOutput(writer, \"\\nVerifying\", TIMEDPRINT)\n    timedOutput(writer, \".....\\n\", 8*TIMEDPRINT)\n    if(hashVal == CONSTHASH):\n        timedOutput(writer, \"Command Sequence Verified\\n\", TIMEDPRINT)\n        timedOutput(writer, \"[HAL] Authorization Code = \", TIMEDPRINT)\n        timedOutput(writer, FLAG, TIMEDPRINT)\n        timedOutput(writer, \"\\n\", TIMEDPRINT)\n    else:\n        timedOutput(writer, \"Invalid Command Sequence\\n\", TIMEDPRINT)\n\n    timedOutput(writer, \"[==== SYSTEM SHUTDOWN ====]\\n\", TIMEDPRINT)\n    writer.close()\n    return\n\nasync def handle_wrap_timed(reader, writer):\n    try:\n        await asyncio.wait_for(handle_client(reader, writer), timeout=300)\n    except asyncio.exceptions.TimeoutError:\n        return\n\nasync def run_server():\n    server = await asyncio.start_server(handle_wrap_timed, '0.0.0.0', PORTNUM)\n    async with server:\n        await server.serve_forever()\n\nasyncio.run(run_server())\n",
    "Dockerfile": "FROM debian:buster-slim\n\n# Update Items\nRUN apt-get update -y\nRUN apt-get install socat python3 python3-pip build-essential -y\n\n# Add Items\nADD create.py /chal/create.py\nADD run.sh /chal/run.sh\nWORKDIR /chal\n\n# Expose the Port\nEXPOSE 39193\n\n# Make entrypoint executable\nRUN chmod +x /chal/run.sh\n\n# Entrypoint\nENTRYPOINT [\"/chal/run.sh\"]\n",
    "Makefile": "NAME := viktor\nPORT := 39193\n\ndocker: Dockerfile\n\tdocker build -t $(NAME) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --tmpfs /tmp:exec --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\n.PHONY:\n",
    "provided.py": "import asyncio\nimport socket\nimport hashlib\n\nfrom time import sleep, time\n\n### CONSTANTS ###\nPORTNUM = 49204\nTIMEDPRINT = 0.08\nFLAG = \"[REDACTED]\"\nCONSTHASH = \"667a32132baf411ebf34c81a242d9ef4bf72e288\"\n\ndef timedOutput(writer, msg, delay):\n    for c in msg:\n        writer.write(bytes(c, \"utf-8\"))\n        sleep(delay)\n\ndef XOR(x, y):\n    return \"\".join([str(hex(int(a, 16)^int(b, 16)))[2:] for a,b in zip(x, y)])\n\n### SERVER STUFF ###\nasync def handle_client(reader, writer):\n    timedOutput(writer, \"[==== BOOT SEQUENCE INITATED ====]\\n\", TIMEDPRINT)\n    timedOutput(writer, \"Waiting for connection\", TIMEDPRINT)\n    timedOutput(writer, \".....\", 8*TIMEDPRINT)\n    timedOutput(writer, \"\\nData transfer complete\\n\", TIMEDPRINT)\n    timedOutput(writer, \"Expected Command Sequence Hash = \", TIMEDPRINT)\n    timedOutput(writer, CONSTHASH, TIMEDPRINT)\n    timedOutput(writer, \"\\nPlease enter the commands line by line\\n\", TIMEDPRINT)\n    timedOutput(writer, \"When finished enter the command \\\"EXECUTE\\\" on the final line\\n\", TIMEDPRINT)\n\n\n    inputList = []\n    usrInput = (await reader.readline()).decode(\"utf-8\").rstrip()\n    while(usrInput != \"EXECUTE\"):\n        inputList.append(usrInput)\n        usrInput = (await reader.readline()).decode(\"utf-8\").rstrip()\n\n    hashList = [hashlib.sha1(x.encode()).hexdigest() for x in inputList]\n    hashVal = hashList[0]\n    for i in range(1, len(hashList)):\n        hashVal = XOR(hashVal, hashList[i]) \n\n    timedOutput(writer, \"\\nVerifying\", TIMEDPRINT)\n    timedOutput(writer, \".....\\n\", 8*TIMEDPRINT)\n    if(hashVal == CONSTHASH):\n        timedOutput(writer, \"Command Sequence Verified\\n\", TIMEDPRINT)\n        timedOutput(writer, \"[HAL] Authorization Code = \", TIMEDPRINT)\n        timedOutput(writer, FLAG, TIMEDPRINT)\n        timedOutput(writer, \"\\n\", TIMEDPRINT)\n    else:\n        timedOutput(writer, \"Invalid Command Sequence\\n\", TIMEDPRINT)\n\n    timedOutput(writer, \"[==== SYSTEM SHUTDOWN ====]\\n\", TIMEDPRINT)\n    writer.close()\n    return\n\nasync def handle_wrap_timed(reader, writer):\n    try:\n        await asyncio.wait_for(handle_client(reader, writer), timeout=300)\n    except asyncio.exceptions.TimeoutError:\n        return\n\nasync def run_server():\n    server = await asyncio.start_server(handle_wrap_timed, '0.0.0.0', PORTNUM)\n    async with server:\n        await server.serve_forever()\n\nasyncio.run(run_server())\n",
    "README.md": "# Viktor\n\n## Description\nRemember the good old days of dial-up modems and slow terminals?\nWhy remeber it when you can live it?\nHowever there's a slight issue, you can't actually run anything unless it is validated by the system.\nCan you make it match?\n\n## Solution\nSee `solve.py`.\n",
    "run.sh": "#!/bin/bash\n\nwhile true; do\n    python3 create.py\ndone\n",
    "solve.py": "# Original code source - https://gist.github.com/LiveOverflow/104adacc8af7895a4c14cea4a5236ecc\n\n## Basically you need to find 160 linearly independent vectors since XOR is addition in GF(2)\n## and a SHA1 hash is 160 bits. Then do a Linalg solver and get the ones which are needed and QED.\n\n## Ironically the numbers 0 -> 160 act as a very good set and I believe all but 1's hashes are lin ind\n## So it ends up being like 50 or so numbers, line by line, then QED\nfrom sage.all import *\nimport hashlib\n\n# prepare a table of bits\ndef bits_of(x):\n    bits = []\n    for c in \"{:08b}\".format(x):\n        bits += [int(c)]\n    return bits\n\n# list of 8bit arrays/vectors\n# bits_table[ 0] = [0,0,0,0, 0,0,0,0]\n# bits_table[ 3] = [0,0,0,0, 0,0,1,1]\n# bits_table[86] = [0,1,0,1, 0,1,1,0]\nbits_8_table = [bits_of(x) for x in range(256)] \n\ndef mk_vector(line):\n    bits_160 = []\n    # sha256 of the filename+\"\\0\"\n    result = hashlib.sha1(line.encode())\n    # for each byte of the hash we get each bit\n    for byte in result.digest():\n        # add the next 8 bits to the bits vector\n        bits_160 += bits_8_table[int(byte)]\n    # return the bit vector\n    return bits_160\n\nGF2 = Zmod(2)\n\nvectors = []\nlines = []\n# loop over some numbers\nfor x in range(99999):\n    # generate a 160bit vector from a possible filename\n    line = f\"{x}\"\n    new_160_vector = mk_vector(line)\n    # create a matrix of all old vectors + the potential new one in GF(2)\n    m = matrix(GF2, vectors + [new_160_vector]).transpose()\n    # check the rank of this matrix\n    rank = m.rank()\n    # if rank increased, keep this file and vector because it's linear independent\n    if rank > len(vectors):\n        print(f\"line {x} is linear independent\")\n        vectors += [new_160_vector]\n        lines += [line]\n    else:\n        print(f\"line {x} is NOT linear independent\")\n    if len(vectors)==160:\n        break\n\nGOAL = []\n# the signed hash is the \"point\" that we want to get to in the vector space\nfor c in \"\\x66\\x7a\\x32\\x13\\x2b\\xaf\\x41\\x1e\\xbf\\x34\\xc8\\x1a\\x24\\x2d\\x9e\\xf4\\xbf\\x72\\xe2\\x88\":\n    GOAL += bits_8_table[ord(c)]\n\n\n# create the whole matrix in GF(2) with all 256 bit vectors\nm = matrix(GF2, vectors).transpose()\nsolved_equation = m.solve_right(vector(GOAL))\nprint(solved_equation)\nfor x, s in zip(solved_equation, lines):\n    #print x, s\n    if x:\n        print(s)\n",
    "solver-template.py": "from pwn import *\n\n# This allow for some networking magic \np = remote(\"tamuctf.com\", 443, ssl=True, sni=\"viktor\")\n\n## YOUR CODE GOES HERE\n",
    "category": "crypto"
}