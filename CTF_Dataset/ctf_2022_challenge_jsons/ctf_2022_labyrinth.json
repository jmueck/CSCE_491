{
    "chall.py": "import networkx as nx\nfrom random import randint, choice\nfrom string import hexdigits\nfrom networkx.classes.function import neighbors\nfrom subprocess import run, check_output\nimport os\nimport binascii\nfrom functools import partial\nimport asyncio, socket\n\n\nimport atexit\n\ncreated_challenges = []\n\n@atexit.register\ndef cleanup():\n\t# we clean up files at the end of each round but to prevent accumulation over time lets also do it onexit in case of exceptions and the like\n\tglobal created_challenges\n\tfor chall in created_challenges:\n\t\trun(f\"rm -f /tmp/{chall}*\",shell=True)\n\nN = 1000\nM = N * 1\n\ndef get_path(g):\n    while True:\n        start = randint(0,N - 1)\n        end = randint(0, N - 1)\n        try:\n            path = nx.algorithms.shortest_paths.generic.shortest_path(g, start, end)\n        except:\n            continue\n        if len(path) > 10:\n            return (start, end, path)\n    \ndef get_func(idx, neighbors):\n    neighbors = \"\\n\".join([f\"\\t\\tcase {i}: function_{i}(); break;\" for i in neighbors])\n    next_expr = f\"next {choice('^+-')}= {randint(0,2**32-1)};\"\n    return f\"\"\"\nvoid function_{idx}() {{\n    uint32_t next = 0;\n    scanf(\"%u\\\\n\", &next);\n    {next_expr}\n    switch(next) {{\n{neighbors}\n        default:\n            exit(1);\n            break;\n    }}\n}}\n\"\"\"\n\ndef make_c():\n    G = nx.gnm_random_graph(N, M)\n    start, end, path = get_path(G)\n    source = \"\"\n    source += \"#include <stdio.h>\\n\"\n    source += \"#include <stdlib.h>\\n\"\n    source += \"#include <stdint.h>\\n\"\n    for i in [x for x in G.nodes if x != end]:\n        source += f\"void function_{i}();\\n\"\n    source += f\"int main() {{ setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); function_{start}(); return 1; }}\"\n    source +=f\"void function_{end}() {{ exit(0); }}\"\n    for i in G.nodes:\n        if len(list(G.neighbors(i))) == 0:\n            continue\n        if i == end:\n            continue\n        source += get_func(i, list(G.neighbors(i)))\n    return source\n\n\n\nfor i in range(5):\n    name = binascii.b2a_hex(os.urandom(15)).decode()\n    created_challenges.append(name)\n    with open(f\"/tmp/{name}.c\",\"w\") as f:\n        f.write(make_c())\n    run(f\"gcc /tmp/{name}.c -o /tmp/{name}\", shell=True)\n    run(f\"chmod +x /tmp/{name}\",shell=True)\n    with open(f\"/tmp/{name}\",\"rb\") as f:\n        print(f.read().hex())\n    request = bytes.fromhex(input().rstrip())\n    if run([f\"/tmp/{name}\"],input=request).returncode == 0:\n        run(f\"rm /tmp/{name}*\",shell=True)\n    else:\n        run(f\"rm /tmp/{name}*\",shell=True)\n        exit(0)\n\nwith open(\"/labyrinth/flag.txt\", \"r\") as f:\n    print(f.read())\n",
    "Dockerfile": "FROM debian:buster-slim\n\nARG port\n\nRUN apt-get update -y; apt-get install python3 python3-pip socat -y\nRUN python3 -m pip install networkx\nRUN mkdir /labyrinth\nADD chall.py /labyrinth/chall.py\nADD flag.txt /labyrinth/flag.txt\n\nEXPOSE $port\n\nENTRYPOINT [\"socat\", \"-s\", \"TCP-LISTEN:11000,reuseaddr,fork\", \"EXEC:timeout 5m python3 /labyrinth/chall.py,stderr\"]",
    "flag.txt": "gigem{w0w_y0ur3_r34lly_600d_w17h_m4z35}",
    "Makefile": "NAME := labyrinth\nPORT := 11000\n\ndocker: Dockerfile\n\tdocker build -t $(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --tmpfs /tmp:exec --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\n.PHONY:\n",
    "README.md": "# Labyrinth\n\n## Description\nTo get the flag you'll need to get to the end of a maz- five randomly generated mazes within five minutes. \n\nThis is an automatic reversing challenge. You will be provided an ELF as a hex string.  You should analyze it, construct an input to make it terminate with exit(0), and then respond with your input in the same format. You will need to solve five binaries within a five minute timeout. \n\n## Solution\nSee `solve.py`.\n",
    "solve.py": "from pwn import *\nimport angr\nimport networkx\n\np = remote(\"tamuctf.com\", 443, ssl=True, sni=\"labyrinth\")\nfor binary in range(5):\n  with open(\"elf\", \"wb\") as file:\n    file.write(bytes.fromhex(p.recvline().rstrip().decode()))\n  proj = angr.Project(\"elf\", load_options={'auto_load_libs': False})\n  cfg = proj.analyses.CFG()\n\n  main = cfg.kb.functions.function(name='main').addr\n\n  addrs = list(cfg.kb.functions.keys())\n  target = addrs.index(main) + 1\n  target = addrs[target]\n\n  log.info(f\"finding route to {cfg.kb.functions[target]}\")\n\n  def find_viable(path):\n    next = proj.factory.call_state(path[0])\n\n    for i in range(1, len(path)):\n      simgr = proj.factory.simgr(next)\n      simgr.explore(find=path[i])\n\n      next = simgr.found[0]\n\n    return next.posix.dumps(0)\n\n  path = networkx.shortest_path(cfg.kb.callgraph, main, target)\n  res = find_viable(path)\n  p.sendline(res.hex())\n\np.interactive()\n",
    "solver-template.py": "from pwn import *\n\np = remote(\"tamuctf.com\", 443, ssl=True, sni=\"labyrinth\")\nfor binary in range(5):\n  with open(\"elf\", \"wb\") as file:\n    file.write(bytes.fromhex(p.recvline().rstrip().decode()))\n\n  # send whatever data you want\n  p.sendline(b\"howdy\".hex())\np.interactive()\n",
    "category": "reversing"
}