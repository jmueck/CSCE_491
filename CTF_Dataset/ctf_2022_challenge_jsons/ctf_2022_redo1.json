{
    "code.c": "#include <stdio.h>\n#include <string.h>\n\n#define STR_LEN 34\n\n#define EXIT printf(\"Sorry that's not the flag\\n\"); return 1;\n#define SUCCESS printf(\"THAT'S THE FLAG!\\n\"); return 0;\n#define PARAMS printf(\"Usage: ./code <flag>\\n\"); return 1;\n#define POINTER char* flag = (char*)(&a);\n\nint main(int argc, char** argv) \n{\n    int a[] = {0x65676967,0x00000000,0x34427b6d,0x5f433153,0x616c5f43,0x00000000,0x4175476e,0x525f4567,0x00000000,0x78305f45,0x53414c47,0x00007d53};\n\n    if(argc != 2){ PARAMS }\n    if(strlen(argv[1]) != STR_LEN){ EXIT }\n\n    POINTER\n\n    for(int i = 0; i < STR_LEN; i++)\n    {\n        int idx = i;\n        if(i >= 4 && i <= 15){ idx += 4; }\n        if(i >= 16 && i <= 23){ idx += 8; }\n        if(i > 23){ idx += 12; }\n\n        if(argv[1][i] != flag[idx]){ EXIT }\n    }\n\n    SUCCESS\n}\n",
    "README.md": "# RE-do 1\n\n## Challenge\nJust a basic reverse engineering challenge.\nNothing special.\nSee what you can do.\n\n# Solution\nI just compiled it up and pointed angr at it. See `solve.py`.\n\nFlag: `gigem{B4S1C_C_lanGuAgE_RE_0xGLASS}`\n",
    "solve.py": "import angr\nimport claripy\n\ndef main():\n    proj = angr.Project('./code', load_options={\"auto_load_libs\": False})\n    argv1 = claripy.BVS(\"argv1\", 34 * 8)\n    initial_state = proj.factory.entry_state(args=[\"./code\", argv1])\n\n    sm = proj.factory.simulation_manager(initial_state)\n    sm.explore(find=lambda s: b\"THAT'S THE FLAG!\" in s.posix.dumps(1))\n    found = sm.found[0]\n    return found.solver.eval(argv1, cast_to=bytes)\n\nif __name__ == '__main__':\n    print(main())\n",
    "category": "reversing"
}