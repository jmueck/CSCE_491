{
    "Dockerfile": "FROM ubuntu:16.04\n\nRUN apt update --fix-missing\nRUN apt install -y socat\n\nRUN groupadd ctf\n\nRUN mkdir /rev\n\nCOPY prodkey /rev/prodkey\nCOPY flag.txt /rev/flag.txt\n\nRUN useradd -G ctf --home=/rev revuser\nRUN useradd -G ctf --home=/rev revflag\n\nRUN chown revflag:revflag /rev/flag.txt\nRUN chown revflag:revflag /rev/prodkey\n\nRUN chmod 4755 /rev/prodkey\nRUN chmod 444 /rev/flag.txt\n\nEXPOSE 8189\n\nCMD [\"su\", \"-c\", \"exec socat TCP-LISTEN:8189,reuseaddr,fork EXEC:/rev/prodkey,stderr\", \"-\", \"revuser\"]\n",
    "flag.txt": "gigem{z3_b3st_thr33}\n",
    "Makefile": "all: rev\n\nrev: z3me.c\n\tgcc z3me.c -o prodkey",
    "prodkey": "[Binary file or unsupported type: c:\\users\\jomue\\tamuctf-2019-master\\tamuctf-2019-master\\reversing\\crackz3\\prodkey]",
    "Readme.md": "# Cr4ckZ33C0d3\n\n## Challenge\n\n`nc pwn.tamuctf.com 8189`\n\n## Setup\nBuild the container with `docker build -t revz3 .` and run it with `docker run -it --rm revz3`\n\n## Solution\nThe challenge details several constraints which should be loaded into a SMT/SAT solver such as Z3. The logic for these is detailed in the solution below. It's kind of ugly but it works.  \n```python\nfrom z3 import *\n\nk0 = Int('s[0]')\nk1 = Int('s[1]')\nk2 = Int('s[2]')\nk3 = Int('s[3]')\nk4 = Int('s[4]')\nk5 = Int('s[5]')\nk6 = Int('s[6]')\nk7 = Int('s[7]')\nk8 = Int('s[8]')\nk9 = Int('s[9]')\nk10 = Int('s[10]')\nk11 = Int('s[11]')\nk12 = Int('s[12]')\nk13 = Int('s[13]')\nk14 = Int('s[14]')\nk15 = Int('s[15]')\nk16 = Int('s[16]')\nk17 = Int('s[17]')\nk18 = Int('s[18]')\nk19 = Int('s[19]')\nk20 = Int('s[20]')\nk21 = Int('s[21]')\nk22 = Int('s[22]')\nk23 = Int('s[23]')\nk24 = Int('s[24]')\nk25 = Int('s[25]')\nk26 = Int('s[26]')\nk27 = Int('s[27]')\nk28 = Int('s[28]')\nk29 = Int('s[29]')\n\ns = Solver()\n\nz = ord('0')\n\n# Check 01\ns.add(k5 == ord('-'))\ns.add(k11 == ord('-'))\ns.add(k17 == ord('-'))\ns.add(k23 == ord('-'))\n\n# Check 02\ns.add((k1-z) >= 0); s.add((k1-z) <=9);\ns.add((k4-z) >= 0); s.add((k4-z) <=9);\ns.add((k6-z) >= 0); s.add((k6-z) <=9);\ns.add((k9-z) >= 0); s.add((k9-z) <=9);\ns.add((k15-z) >= 0); s.add((k15-z) <=9);\ns.add((k15-z) >= 0); s.add((k15-z) <=9);\ns.add((k18-z) >= 0); s.add((k18-z) <=9);\ns.add((k22-z) >= 0); s.add((k22-z) <=9);\ns.add((k27-z) >= 0); s.add((k27-z) <=9);\ns.add((k28-z) >= 0); s.add((k28-z) <=9);\n\n# check 03\ns.add((k4-z) == ((k1-z)*2+1))\ns.add((k4-z) > 7)\ns.add(k9 == ((k4-(k1-z))+2))\n\n# Check 04\ns.add((k27+k28)%13 == 8)\n\n# Check 05\ns.add((k27+k22)%22 == 18)\n\n# Check 06\ns.add((k18 + k22)%11 == 5)\n\n# Check 07\ns.add((k28+k22+k18)%26 == 4)\n\n# Check 08\ns.add((k1 + k4*k6)%41 == 5)\n\n# Check 09\ns.add((k15-k28)%4 == 1)\n\n# Check 0A\ns.add((k4+k22)%4 == 3)\n\n# Check 0B\ns.add(k20 == ord('B'))\ns.add(k21 == ord('B'))\n\n# Check 0C\ns.add((k6+k15*k9)%10 == 1)\n\n# Check 0D\ns.add((k4+k15+k27-18)%16 == 8)\n\n# Check 0F\ns.add(k0 == ord('M'))\n\nprint s.check()\nm = s.model()\nl = str(m).replace(' ', '').replace('\\n', '').split(',')\nprint l\n```\n",
    "solve.py": "from z3 import *\n\n# structure from binary\n# M#XX#-#XX#X-XXX#X-#XBB#-XX##\n# 9 integers\n\ndef m(a, b):\n  # modules z3\n  return If(a % b >= 0,\n    a % b,\n    a % b + b)\n\ns = Solver()\n\n# 15 checks\n# resource solution-36.blogspot.com/2014/08/solving-picoctf-2013-harder-serial-with.html\n# 1) every 5 characters are followed by '-'\n\n# 2) 9 input characters must be integers\n\nv = []\nfor i in range(9):\n  e = Int('v'+str(i))\n  v.append(e)\n\n  # define in numbers only\n  s.add(e >= 0)\n  s.add(e <= 9)\n\n# 3) Constraints on int(1, 2, 4)\ns.add((v[1]-1)/(2*v[0]) == 1)\ns.add(v[1] > 7)\ns.add(v[1]-v[0]+2-v[3] == 0)\n\n# 4) Constraints on int(8, 9)\n# need to add ascii offset for module math for 2 integers\ns.add(m(v[7] + v[8] + 48*2,13) == 8) \n\n# 5) Constraints on (7, 8)\ns.add(m(v[7] + v[6] + 48*2,22) == 18)\n\n# 6) Constraints on (6, 7)\ns.add(m(v[5] + v[6] + 48*2, 11) == 5)\n\n# 7) Constraints on (6, 7, 9)\ns.add(m(v[6] + v[8] + v[5] + 48*3, 26) == 4) \n\n# 8) Constraints on (1, 2, 3)\ns.add(m(v[0] + 48 +(v[1]+48)*(v[2]+48), 41) == 5)\n\n# 9) Constraints on (5, 9)\ns.add(m(v[4] + v[8] + 48*2, 4) == 1)\n\n# 10) Constraints on (2, 7)\ns.add(m(v[6] + v[1] + 48*2, 4) == 3)\n\n# 11) Middle letters are BB\n# Sturcture in final solution\n\n# 12) Constraints on (2, 4, 7)\nt4 = 9\nt3 = 7\nt2 = 8 \nprint (t2+48 + (t4+48)*(t3+48)) %  10\ns.add(m(v[2]+48 + (v[4]+48)*(v[3]+48), 10) == 5)\n\n# 13) Constraints on (2, 5, 8)\ns.add(m(v[1] + v[4] + v[7] - 18 + 48*3, 16) == 8)\n\n# 14) Constraints on (4, 9)\ns.add(m(v[3] + v[8] + 48*2, 2) == 1)\n\n# 15) First letter is M\n# Structure in final solution\n\nprint(s.check())\nm = s.model()\nprint m",
    "z3me.c": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n// Solution must be XXXXX-XXXXX-XXXXX-XXXXX-XXXXX\n_Bool check_01(char * key)                                                  {\n    if(key[5] != '-' || key[11] != '-' || \n       key[17]!= '-' || key[23] != '-')                                     {\n        //printf(\"Failed Check 1.\\n\");\n        return false;                                                       }\n    else                                                                    {\n        return true;                                                        }\n                                                                            }\n// Solution must be X#XX#-#XX#X-XXX#X-#XXX#-XXX##\n_Bool check_02(char * key)                                                  {\n    if((unsigned int)(key[1] - '0') < 10 && \n       (unsigned int)(key[4] - '0') < 10 && \n       (unsigned int)(key[6] - '0') < 10 && \n       (unsigned int)(key[9] - '0') < 10 && \n       (unsigned int)(key[15] - '0') < 10 && \n       (unsigned int)(key[18] - '0') < 10 && \n       (unsigned int)(key[22] - '0') < 10 && \n       (unsigned int)(key[27] - '0') < 10 && \n       (unsigned int)(key[28] - '0') < 10)                                   {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check2.\\n\");\n        return false;                                                       }\n                                                                            }\n\n// Solution must be X4XX9-#XX7X-XXX#X-#XXX#-XXX##\n_Bool check_03(char * key)                                                  {\n    if((key[4] - '0') == (key[1]-'0')*2+1 && \n       (key[4] - '0') > 7    && \n       (key[9] == (key[4])-(key[1]-'0')+2))                             {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check3.\\n\");\n        return false;                                                       }\n                                                                            }\n// Solution must be X4XX9-#XX7X-XXX#X-#XXX#-XXX88\n_Bool check_04(char * key)                                                  {\n    if((key[27] + key[28])%13==8)                                           {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check4.\\n\");\n        return false;                                                       }\n                                                                            }\n// Solution must be X4XX9-#XX7X-XXX#X-#XXX2-XXX88\n_Bool check_05(char * key)                                                  {\n    if((key[27] + key[22])%22==18)                                          {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check5.\\n\");\n        return false;                                                       }\n                                                                            }\n// Solution must be X4XX9-#XX7X-XXX#X-6XXX2-XXX88\n_Bool check_06(char * key)                                                  {\n    if((key[18] + key[22])%11==5)                                           {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check6.\\n\");\n        return false;                                                       }\n                                                                            }\n// Solution must be X4XX9-#XX7X-XXX#X-6XXX2-XXX88\n_Bool check_07(char * key)                                                  {\n    if((key[28] + key[22] + key[18])%26==4)                                 {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check7.\\n\");\n        return false;                                                       }\n                                                                            }\n// Solution must be X4XX9-8XX7X-XXX#X-6XXX2-XXX88\n_Bool check_08(char * key)                                                  {\n    if((key[1] + key[4]*key[6])%41==5)                                      {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check8.\\n\");\n        return false;                                                       }\n                                                                            }\n// Solution must be X4XX9-8XX7X-XXX9X-6XXX2-XXX88\n_Bool check_09(char * key)                                                  {\n    if((key[15] - key[28])%4==1)                                            {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check9.\\n\");\n        return false;                                                       }\n                                                                            }\n// Solution must be X4XX9-8XX7X-XXX9X-6XXX2-XXX88\n_Bool check_0A(char * key)                                                  {\n    if((key[4] + key[22])%4==3)                                             {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check10. %d\\n\", (key[4] + key[22])%4);\n        return false;                                                       }\n                                                                            }\n\n// Solution must be X4XX9-8XX7X-XXX9X-6XBB2-XXX88\n_Bool check_0B(char * key)                                                  {\n    if(key[20] == 'B' && key[21] == 'B')                                    {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check11.\\n\");\n        return false;                                                       }\n                                                                            }\n\n// Solution must be X4XX9-8XX7X-XXX9X-6XBB2-XXX88\n_Bool check_0C(char * key)                                                  {\n    if((key[6] + key[15]*key[9])%10==1)                                     {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check12 %d.\\n\",(key[6] + key[15]*key[9])%10 );\n        return false;                                                       }\n                                                                            }\n\n// Solution must be X4XX9-8XX7X-XXX9X-6XBB2-XXX88\n_Bool check_0D(char * key)                                                  {\n    if((key[4] + key[15] + key[27] - 18)%16==8)                             {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check13.\\n\");\n        return false;                                                       }\n                                                                            }\n// Solution must be X4XX9-8XX7X-XXX9X-6XBB2-XXX88\n_Bool check_0E(char * key)                                                  {\n    if((key[28] - key[9])%2==1)                                             {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check14.\\n\");\n        return false;                                                       }\n                                                                            }\n// Solution must be M4XX9-8XX7X-XXX9X-6XBB2-XXX88\n_Bool check_0F(char * key)                                                  {\n    if(key[0] == 'M')                                                       {\n        return true;                                                        }\n    else                                                                    {\n        //printf(\"Failed Check15.\\n\");\n        return false;                                                       }\n                                                                            }\n\n\n\n_Bool verify_key(char * key)                                                {\n    if(strlen(key) < 29)                                                    { \n        printf(\"Key was too short %d.\\n\", strlen(key));\n        return false;                                                       }\n    return check_01(key)\n        && check_02(key)\n        && check_03(key)\n        && check_04(key)\n        && check_05(key)\n        && check_06(key)\n        && check_07(key)\n        && check_08(key)\n        && check_09(key)\n        && check_0A(key)\n        && check_0B(key)\n        && check_0C(key)\n        && check_0D(key)\n        && check_0E(key)\n        && check_0F(key);\n                                                                            }\n\nint main()                                                                  {\n    setvbuf(stdout,0, _IONBF,0);\n    printf(\"\\nPlease Enter a product key to continue: \\n\");\n    char pkey[30];\n    fgets((char*)pkey, 30, stdin);\n    if (verify_key(pkey))                                                   {\n        FILE* infile = fopen(\"flag.txt\", \"r\");\n        if (infile == NULL)                                                 {\n            printf(\"Too bad the flag is only on the remote server!\\n\");\n            return 0;                                                       }\n        char output[100];\n        fgets(output, 100, infile);\n        printf(\"%s\", output);                                                     }\n                                                                            }\n",
    "category": "Reversing"
}