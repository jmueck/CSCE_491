{
    "crontab.txt": "* * * * * /usr/local/bin/python /flag_bot.py >> /var/log/script.log\n# empty line\n",
    "Dockerfile": "FROM python:alpine\n\nENV HOME /\n\nCOPY flag_bot.py /\nCOPY requirements.txt /\nCOPY credentials.json /\n\nRUN python -m pip install --upgrade pip\nRUN python -m pip install --upgrade -r requirements.txt\n\nRUN mkdir /root/.credentials\nCOPY credentials.json /root/.credentials/\nCOPY gmail-python-email-send.json /root/.credentials/\nADD crontab.txt /crontab.txt\nRUN /usr/bin/crontab /crontab.txt\n\nCMD [\"crond\",\"-f\",\"-l\",\"8\"]\n",
    "flag_bot.py": "import httplib2\nimport os\nimport re\nimport oauth2client\nfrom oauth2client import client, tools, file\nimport base64\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom apiclient import errors, discovery\n\nSCOPES = 'https://mail.google.com/'\nCLIENT_SECRET_FILE = 'credentials.json'\nAPPLICATION_NAME = 'Gmail API Python Send Email'\n\ndef ListMessagesMatchingQuery(service, user_id, query=''):\n    try:\n        response = service.users().messages().list(userId=user_id,q=query).execute()\n        messages = []\n        if 'messages' in response:\n            messages.extend(response['messages'])\n        \n        while 'nextPageToken' in response:\n            page_token = response['nextPageToken']\n            response = service.users().messages().list(userId=user_id, q=query,pageToken=page_token).execute()\n            messages.extend(response['messages'])\n        return messages\n    except errors.HttpError as error:\n        print('An error occurred: %s' % error)\n\ndef GetMessage(service, user_id, msg_id):\n    try:\n        message = service.users().messages().get(userId=user_id, id=msg_id).execute()\n        return message\n    except errors.HttpError as error:\n        print('An error occurred: %s' % error)\n\ndef get_credentials():\n    home_dir = os.path.expanduser('~')\n    credential_dir = os.path.join(home_dir, '.credentials')\n    if not os.path.exists(credential_dir):\n        os.makedirs(credential_dir)\n    credential_path = os.path.join(credential_dir, 'gmail-python-email-send.json')\n    store = oauth2client.file.Storage(credential_path)\n    credentials = store.get()\n    if not credentials or credentials.invalid:\n        flow = client.flow_from_clientsecrets(CLIENT_SECRET_FILE, SCOPES)\n        flow.user_agent = APPLICATION_NAME\n        credentials = tools.run_flow(flow, store)\n        print('Storing credentials to ' + credential_path)\n    return credentials  \n\ndef SendMessage(service, user_id, message):\n    try:\n        message = (service.users().messages().send(userId=user_id, body=message).execute())\n        print('Message Id: %s' % message['id'])\n        return message\n    except errors.HttpError as error:\n        print('An error occurred: %s' % error)\n\ndef CreateMessage(sender, to, subject, msgPlain):\n    msg = MIMEMultipart('alternative')\n    msg['Subject'] = subject\n    msg['From'] = sender\n    msg['To'] = to\n    msg.attach(MIMEText(msgPlain, 'plain'))\n    raw = base64.urlsafe_b64encode(msg.as_bytes())\n    raw = raw.decode()\n    body = {'raw': raw}\n    return body\n\ndef findEmail(message):\n    match = re.search(r'[\\w\\.-]+@[\\w\\.-]+', message)\n    if match:\n        return match.group(0)\n    else:\n        return 'No match'\n    \ndef DeleteMessage(service, user_id, msg_id):\n    try:\n        service.users().messages().delete(userId=user_id, id=msg_id).execute()\n        print('Message with id: %s deleted successfully.' % msg_id)\n    except errors.HttpError as error:\n        print('An error occurred: %s' % error)\n   \ndef main():\n    credentials = get_credentials()\n    http = credentials.authorize(httplib2.Http())\n    service = discovery.build('gmail', 'v1', http=http)\n    inbox_ids = ListMessagesMatchingQuery(service,\"me\",'in:inbox')\n    spam_ids = ListMessagesMatchingQuery(service,\"me\",'in:spam')\n    message_ids = inbox_ids + spam_ids\n    for message_id in message_ids:\n        message = GetMessage(service, \"me\", message_id['id'])\n        from_address = [value['value'] for value in message['payload']['headers'] if value['name'] == 'From'][0]\n        print('From:',from_address)\n        snippet = message['snippet']\n        print('Body:',snippet)\n        send_flag_address = findEmail(snippet)\n        if '<someguy@somebigcorp.com>' in from_address and send_flag_address != 'No match':\n            to = send_flag_address\n            sender = \"tamuctf@gmail.com\"\n            subject = \"TAMUctf Flag\"\n            msgPlain = \"gigem{wuT_4n_31337_sp0ofer_494C4F5645594F55}\"\n            reply_message = CreateMessage(sender, to, subject, msgPlain)\n            SendMessage(service, \"me\", reply_message)\n            print('sent flag to %s' % send_flag_address)\n        DeleteMessage(service,\"me\",message_id['id'])\n\nif __name__ == '__main__':\n    main()",
    "README.md": "# Onboarding Checklist\n## Challenge\nFrom: importantperson@somebigcorp.com<br/>\nDate: Feb 22, 2019 9:00 AM<br/>\nTo: someguy@somebigcorp.com<br/>\nSubject: New Employee Access\n\nHello Some Guy,\n\nWe need to begin sending requests for the new employee to get access to our security appliances. I believe they already know that you are authorized to make a new account request. Would you mind sending the new employee's email address to tamuctf@gmail.com so they can process the account request?\n\nThank you,<br/>\nImportant Person\n\n## Configuration\n```docker build -t spoofers .```<br/>\n```docker run spoofers```\n\n```credentials.json``` and ```gmail-python-email-send.json``` are both in the tamuctf team drive under TAMUctf 2019 \\> Keys \\> spoofers email bot credentials\n\n## Solution\nSend a spoofed email address to tamuctf@gmail.com using the sender address someguy@somebigcorp.com<br/>\nMake sure an email that you have access to is included in the email body.\n",
    "requirements.txt": "google-api-python-client\ngoogle-auth-httplib2\ngoogle-auth-oauthlib\noauth2client\n",
    "category": "Misc"
}