{
    "Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\n[[package]]\nname = \"pwgen\"\nversion = \"0.1.0\"\n\n",
    "Cargo.toml": "[package]\nname = \"pwgen\"\nversion = \"0.1.0\"\nauthors = [\"Teddy Heinen <teddy@heinen.dev>\"]\nedition = \"2018\"\n\n\n[[bin]]\nname = \"check\"\npath = \"src/check.rs\"\n\n[[bin]]\nname = \"pwgen\"\npath = \"src/main.rs\"\n\n\n[dependencies]\n",
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        pass\n\n    def generate_flag(self, random):\n        return r\"gigem{cryp706r4ph1c4lly_1n53cur3_prn65_DC6F9B}\"\n",
    "Dockerfile": "FROM rust:alpine\n\nRUN apk add --update socat\n\nCOPY . /chall/.\nWORKDIR /chall\n\nRUN cargo build --release\nEXPOSE 4662\n\nENTRYPOINT [\"sh\", \"-c\", \"exec socat TCP-LISTEN:4662,reuseaddr,fork EXEC:/chall/target/release/check,stderr\"]",
    "flag.txt": "gigem{cryp706r4ph1c4lly_1n53cur3_prn65_DC6F9B}",
    "Makefile": "CONTAINER := pwgen\n\n\nclean: .PHONY\n\trm -f pwgen check\n\n\ndocker: Dockerfile flag.txt password src\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run -d -p 4662:4662 --name $(CONTAINER) $(CONTAINER)\n\n\nextract: docker\n\t$(eval id := $(shell docker create $(CONTAINER)))\n\tdocker cp $(id):/chall/. - | tar xv\n\tdocker rm -v $(id)\n\n.PHONY:",
    "password": "[Binary file or unsupported type: c:\\users\\jomue\\tamuctf-2021-master\\tamuctf-2021-master\\crypto\\pwgen\\password]",
    "problem.json": "{\n  \"name\": \"pwgen\",\n  \"category\": \"Crypto\",\n  \"description\": \"We're trying to figure out the current password of REDACTED. We have reason to believe that they generated a set of passwords at the same time using a custom password generation program and that their previous password was <code>ElxFr9)F</code>. Can you figure out their current password?\\n{{url_for('src/main.rs')}}\\n<code>openssl s_client -connect tamuctf.com:443 -servername pwgen -quiet</code>\",\n  \"score\" : 200,\n  \"hints\": [],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Teddy Heinen\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "pwgen.py": "import z3\nfrom pwn import *\nimport re\nimport sys\n\ndef guess_next_number(known):\n    n_nums = len(known)\n    \n    states = {f'state_{i}': z3.BitVec(f'state_{i}', 32) for i in range(1, n_nums + 2)}\n    next_number = z3.BitVec('next_number', 32)\n    \n    s = z3.Solver()\n\n    a = 1103515245\n    c = 12345\n    m = 16\n    for i in range(2, n_nums + 2):\n        s.add(states[f'state_{i}'] == states[f'state_{i - 1}'] * a + c)\n\n    for i in range(1, n_nums + 1):\n        s.add(z3.URem((states[f'state_{i}'] >> m) & 0x7fff, (0x7f - 0x21)) + 0x21 == known[i - 1])\n        \n    s.add(next_number == z3.URem((states[f'state_{n_nums + 1}'] >> m) & 0x7fff,  (0x7f - 0x21)) + 0x21)\n    \n    if s.check() == z3.sat:\n        return s.model()[next_number]\n    else:\n        print(f\"Couldn't satisfy constraints for {known}\")\n        sys.exit(1)\n    \n\n\nknown = \"ElxFr9)F\"\ncorrect = \"xV!;28vj\"\n\n\nknown_nums = [ord(x) for x in known]\n\n\npassword = \"\"\n\nfor i in range(8):\n\n    next_num = guess_next_number(known_nums)\n    print(f\"guessed {chr(int(str(next_num)))}, actual {correct[i]}\")\n    if chr(int(str(next_num))) != correct[i]:\n        print(\"failed :(\")\n        sys.exit(0)\n    password += chr(int(str(next_num)))\n    known_nums.append(next_num)\n\n\nprint(\"password = \", password)\np = remote(\"localhost\",4662)\np.sendline(password)\nprint(re.search(\"(gigem{.*})\", p.recvall().decode()).group(1))\n",
    "readme.md": "# pwgen\n\nWe're trying to figure out the current password of \\<REDACTED\\>.  We have reason to believe that they generated a set of passwords at the same time using a custom password generation program and that their previous password was `ElxFr9)F`.  Can you figure out their current password?  \n\n`nc challenges.tamuctf.com 4662`\n\n[zipped source of pwgen]  \n\n\n## solution\n`gigem{cryp706r4ph1c4lly_1n53cur3_prn65_DC6F9B}`\n\nLooking at the rand function from the source, we can see that this is a [linear congruential generator](https://en.wikipedia.org/wiki/Linear_congruential_generator) which is trivially reversible when we have access to the raw outputs:\n```rust\nimpl Random {\n    fn rand(&mut self) -> i32 {\n        let a = 1103515245;\n        let c = 12345;\n        self.seed = self.seed.wrapping_mul(a) + c;\n        (self.seed >> 16) & 0x7fff\n    }\n}\n```\n\nUnfortunately, we don't have the raw outputs; the outputs are instead passed through a modulo or two to get it into a nice format for a password:\n```rust\nfn generate_password(rand: &mut Random, n: i32) -> String {\n    (0..n)\n        .map(|_| (rand.rand() % (0x7f - 0x21) + 0x21) as u8 as char)\n        .collect::<String>()\n}\n```\n\nBecause I don't want to work this out by hand or write a solving script, we'll use z3:\n```python\nfrom z3 import *\n\npassword = 'ElxFr9)F'\n\ns = Solver()\n\na = BitVecVal(1103515245, 32)\nc = BitVecVal(12345, 32)\n\nbase_seed = BitVec('s0', 32)\nseed = base_seed\n\ndef rand():  # see the rand definition above\n  global seed\n  seed = (seed * a) + c\n  res = (seed >> BitVecVal(16, 32)) & BitVecVal(0x7fff, 32)\n  return res\n\n# we know the values for the first password, so we can assert them to be equal to characters in password\nfor i in range(0, len(password)):  # see the generate_password function above\n  res = rand()\n  pc = BitVec('c' + str(i), 8)\n  s.add(pc == Extract(7, 0, res % (0x7f - 0x21) + 0x21), pc == BitVecVal(ord(password[i]), 8))\n\ngenerated = []\n\n# we don't know the values in the generated password, but we can store these for later extraction\nfor i in range(len(password), len(password) * 2):\n  res = rand()\n  pc = BitVec('c' + str(i), 8)\n  generated.append(pc)\n  s.add(pc == Extract(7, 0, res % (0x7f - 0x21) + 0x21))\n\ns.check()\nmodel = s.model()\n\n# extract the characters from the z3 model\ngenerated = [chr(model[c].as_long()) for c in generated]\nprint(''.join(generated))\n```\n\nAfter 10 seconds on my clunky laptop, this outputs: `xV!;28vj`\n\nLogging in with `nc 104.155.170.123 4662`:\n```\n$ nc 104.155.170.123 4662\nWhat's the password?\nxV!;28vj\ngigem{cryp706r4ph1c4lly_1n53cur3_prn65_DC6F9B}\n```\n\nz3 is really so satisfying ;)\n",
    "src\\check.rs": "fn main() -> std::io::Result<()>  {\n    println!(\"What's the password?\");\n    let stdin = std::io::stdin();\n    let mut line = String::new();\n    stdin.read_line(&mut line)?;\n    if line.trim() == include_str!(\"../password\") {\n        println!(\"{}\", include_str!(\"../flag.txt\"))\n    } else {\n        println!(\"Sorry, that isn't correct.\");\n    };\n    Ok(())\n}\n",
    "src\\main.rs": "use std::io::Read;\n\nstruct Random {\n    seed: i32\n}\n\nimpl Random {\n    fn rand(&mut self) -> i32 {\n        let a = 1103515245;\n        let c = 12345;\n        self.seed = self.seed.wrapping_mul(a) + c;\n        (self.seed >> 16) & 0x7fff\n    }\n}\n\nfn generate_password(rand: &mut Random, n: i32) -> String {\n    (0..n).map(|_| (rand.rand() % (0x7f - 0x21) + 0x21) as u8 as char).collect::<String>()\n}\n\nfn main() -> std::io::Result<()> {\n    let seed = {\n        let mut os_rand = std::fs::File::open(\"/dev/urandom\")?;\n        let mut rand_bytes = [0; 4];\n        os_rand.read(&mut rand_bytes)?;\n        i32::from_le_bytes(rand_bytes)\n    };\n    let mut rand = Random {\n        seed\n    };\n\n    let stdin = std::io::stdin();\n    loop {\n        println!(\"Howdy!  How many passwords would you like to generate? \");\n        let mut line = String::new();\n        stdin.read_line(&mut line)?;\n        if let Ok(num) = line.trim().parse::<i32>() {\n            for _ in 0..num {\n                println!(\"{}\", generate_password(&mut rand, 8));\n            }\n            std::process::exit(0)\n        } else {\n            println!(\"That doesn't look like a number...\");\n        }\n    }\n}\n",
    "category": "crypto"
}