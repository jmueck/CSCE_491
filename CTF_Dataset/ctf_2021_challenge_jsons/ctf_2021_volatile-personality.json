{
    ".gitignore": "*.lime\n*.lime.gz\nUbuntu2004.zip\ntarget/\nextracted/\n\n*.lkm\n",
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        pass\n\n    def generate_flag(self, random):\n        return r\"gigem{redman_has_bad_memory}\"\n",
    "problem.json": "{\n  \"name\": \"Volatile Personality\",\n  \"category\": \"Forensics\",\n  \"description\": \"We successfully exploited a target, but the IDS detected us! The only thing we got was this memory snapshot; think you can extract the flag from it? <a href='http://tamuctf.com/static-files/mem.lime.zz'>mem.lime.zz</a>\",\n  \"score\" : 500,\n  \"hints\": [],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Addison Crump\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n",
    "README.md": "# Volatile Personality\n\n## Description\n\nWe successfully exploited a target, but the IDS detected us! The only thing we got was this\nmemory snapshot; think you can extract the flag from it?\n\n## Solution\n\nWe're provided a memory snapshot and the flag is presumably somewhere inside of it.  After trying and failing the obvious (strings lol), the next thing to do is look for a memory dump analysis tool.  The one i'll be using in this writeup is Volatility.  It should be noted that 2.6.1 doesn't quite work - I had to use the bleeding version off of github.  \n\n### creating the profile\n\nTo work correctly Volatility requires a \"profile\" of the target system.  A profile is essentially a zip file with information on OS data structures that Volatility can use to find relevant information.  The easiest way to make one of these is just build a VM with the same operating system as your target and build it off of that.  Can we figure out which operating system the system was using?  \n\n`strings mem.lime | grep \"Linux\"` gives us the line\n`Aug 27 02:53:33 redman-dev kernel: [    0.000000] Linux version 5.4.0-42-generic (buildd@lgw01-amd64-038) (gcc version 9.3.0 (Ubuntu 9.3.0-10ubuntu2)) #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 (Ubuntu 5.4.0-42.46-generic 5.4.44)`\n\nKnowing that it is Ubuntu tells us a little bit more about the mem dump and where we should be looking for the specific version. \n`strings mem.lime | grep \"deb \"` gives us `deb http://mirror.dal10.us.leaseweb.net/ubuntu focal main restricted`.  Our dumped system is running Ubuntu 20.04 Focal Fossa\n\nAfter creating a VM of the system the process to create a profile is pretty simple.  \n```bash\napt update\napt install linux-headers-generic dwarfdump build-essential\ngit clone https://github.com/volatilityfoundation/volatility.git\ncd volatility/tools/linux/ && make\ncd ../../../\nzip $(lsb_release -i -s)_$(uname -r)_profile.zip ./volatility/tools/linux/module.dwarf /boot/System.map-$(uname -r)\n```\n\nAftering creating the profile you just need to grab it off your VM and place it in ./plugins/overlays/linux under your volatility installation. \n\n### reviewing the memory dump\n\n```text\n\u276f python2 volatility/vol.py -f mem.lime --profile=LinuxUbuntu_5_4_0-42-generic_profilex64 -h\n...\n\tSupported Plugin Commands:\n\n\t\timagecopy      \tCopies a physical address space out as a raw DD image\n\t\tlimeinfo       \tDump Lime file format information\n\t\tlinux_apihooks \tChecks for userland apihooks\n\t\tlinux_arp      \tPrint the ARP table\n\t\tlinux_aslr_shift\tAutomatically detect the Linux ASLR shift\n\t\tlinux_banner   \tPrints the Linux banner information \n\t\tlinux_bash     \tRecover bash history from bash process memory\n\t\tlinux_bash_env \tRecover a process' dynamic environment variables\n\t\tlinux_bash_hash\tRecover bash hash table from bash process memory\n\t\tlinux_check_afinfo\tVerifies the operation function pointers of network protocols\n\t\tlinux_check_creds\tChecks if any processes are sharing credential structures\n\t\tlinux_check_fop\tCheck file operation structures for rootkit modifications\n\t\tlinux_check_idt\tChecks if the IDT has been altered \n\t\tlinux_check_inline_kernel\tCheck for inline kernel hooks\n\t\tlinux_check_modules\tCompares module list to sysfs info, if available\n\t\tlinux_check_syscall\tChecks if the system call table has been altered \n\t\tlinux_check_tty\tChecks tty devices for hooks\n\t\tlinux_cpuinfo  \tPrints info about each active processor\n\t\tlinux_dentry_cache\tGather files from the dentry cache\n\t\tlinux_dmesg    \tGather dmesg buffer\n\t\tlinux_dump_map \tWrites selected memory mappings to disk \n\t\tlinux_dynamic_env\tRecover a process' dynamic environment variables\n\t\tlinux_elfs     \tFind ELF binaries in process mappings\n\t\tlinux_enumerate_files\tLists files referenced by the filesystem cache\n\t\tlinux_find_file\tLists and recovers files from memory\n\t\tlinux_getcwd   \tLists current working directory of each process\n\t\tlinux_hidden_modules\tCarves memory to find hidden kernel modules\n\t\tlinux_ifconfig \tGathers active interfaces\n\t\tlinux_info_regs\tIt's like 'info registers' in GDB. It prints out all the\n\t\tlinux_iomem    \tProvides output similar to /proc/iomem\n\t\tlinux_kernel_opened_files\tLists files that are opened from within the kernel\n\t\tlinux_keyboard_notifiers\tParses the keyboard notifier call chain\n\t\tlinux_ldrmodules\tCompares the output of proc maps with the list of libraries from libdl\n\t\tlinux_library_list\tLists libraries loaded into a process \n\t\tlinux_librarydump\tDumps shared libraries in process memory to disk\n\t\tlinux_list_raw \tList applications with promiscuous sockets\n\t\tlinux_lsmod    \tGather loaded kernel modules\n\t\tlinux_lsof     \tLists file descriptors and their path\n\t\tlinux_malfind  \tLooks for suspicious process mappings\n\t\tlinux_memmap   \tDumps the memory map for linux tasks\n\t\tlinux_moddump  \tExtract loaded kernel modules\n\t\tlinux_mount    \tGather mounted fs/devices\n\t\tlinux_mount_cache\tGather mounted fs/devices from kmem_cache\n\t\tlinux_netfilter\tLists Netfilter hooks\n\t\tlinux_netscan  \tCarves for network connection structures\n\t\tlinux_netstat  \tLists open sockets\n\t\tlinux_pidhashtable\tEnumerates processes through the PID hash table\n\t\tlinux_pkt_queues\tWrites per-process packet queues out to disk\n\t\tlinux_plthook  \tScan ELF binaries' PLT for hooks to non-NEEDED images\n\t\tlinux_proc_maps\tGathers process memory maps\n\t\tlinux_proc_maps_rb\tGathers process maps for linux through the mappings red-black tree\n\t\tlinux_procdump \tDumps a process's executable image to disk\n\t\tlinux_process_hollow\tChecks for signs of process hollowing\n\t\tlinux_psaux    \tGathers processes along with full command line and start time\n\t\tlinux_psenv    \tGathers processes along with their static environment variables\n\t\tlinux_pslist   \tGather active tasks by walking the task_struct->task list\n\t\tlinux_pslist_cache\tGather tasks from the kmem_cache\n\t\tlinux_psscan   \tScan physical memory for processes \n\t\tlinux_pstree   \tShows the parent/child relationship between processes\n\t\tlinux_psxview  \tFind hidden processes with various process listings\n\t\tlinux_recover_filesystem\tRecovers the entire cached file system from memory\n\t\tlinux_route_cache\tRecovers the routing cache from memory \n\t\tlinux_sk_buff_cache\tRecovers packets from the sk_buff kmem_cache\n\t\tlinux_slabinfo \tMimics /proc/slabinfo on a running machine\n\t\tlinux_strings  \tMatch physical offsets to virtual addresses (may take a while, VERY verbose)\n\t\tlinux_threads  \tPrints threads of processes \n\t\tlinux_tmpfs    \tRecovers tmpfs filesystems from memory\n\t\tlinux_truecrypt_passphrase\tRecovers cached Truecrypt passphrases \n\t\tlinux_vma_cache\tGather VMAs from the vm_area_struct cache\n\t\tlinux_volshell \tShell in the memory image\n\t\tlinux_yarascan \tA shell in the Linux memory image\n\t\tmbrparser      \tScans for and parses potential Master Boot Records (MBRs) \n\t\tpatcher        \tPatches memory based on page scans\n\t\traw2dmp        \tConverts a physical memory sample to a windbg crash dump\n\t\tvmwareinfo     \tDump VMware VMSS/VMSN information\n```\nThere are a lot of plugins available to us, checking bash_history is a good place to start. \n\n```text\n\u276f python2 volatility/vol.py -f mem.lime --profile=LinuxUbuntu_5_4_0-42-generic_profilex64 linux_bash\nVolatility Foundation Volatility Framework 2.6.1\nPid      Name                 Command Time                   Command\n-------- -------------------- ------------------------------ -------\n    1903 bash                 2020-08-27 02:56:11 UTC+0000   cd git/\n    1903 bash                 2020-08-27 02:56:11 UTC+0000   ls\n    1903 bash                 2020-08-27 02:56:11 UTC+0000   cd something-special/\n    1903 bash                 2020-08-27 02:56:11 UTC+0000   cd linux-kernel-module-rust/\n    1903 bash                 2020-08-27 02:56:11 UTC+0000   ls\n    1903 bash                 2020-08-27 02:56:11 UTC+0000   ls\n    1903 bash                 2020-08-27 02:56:11 UTC+0000   sudo insmod somethingspecial.ko \n    1903 bash                 2020-08-27 02:56:11 UTC+0000   ls\n    1903 bash                 2020-08-27 02:56:17 UTC+0000   cd $(mktemp -d)\n    1903 bash                 2020-08-27 02:56:40 UTC+0000   git clone https://github.com/504ensicsLabs/LiME.git\n    1903 bash                 2020-08-27 02:56:45 UTC+0000   cd LiME/src/\n    1903 bash                 2020-08-27 02:56:45 UTC+0000   ls\n    1903 bash                 2020-08-27 02:56:46 UTC+0000   make\n    1903 bash                 2020-08-27 02:56:51 UTC+0000   ls\n    1903 bash                 2020-08-27 02:58:43 UTC+0000   sudo insmod lime-5.4.0-42-generic.ko \"path=tcp:4444 compress=1 format=lime\"\n```\n\nSo the challenge author installed a kernel module and then took the memory dump.  It seems pretty likely that this kernel module is relevant to our flag hunting efforts so let's see if we can pull it from the dump.  \n\n```\n\u276f python2 volatility/vol.py -f mem.lime --profile=LinuxUbuntu_5_4_0-42-generic_profilex64 linux_enumerate_files | grep \"somethingspecial.ko\"\nVolatility Foundation Volatility Framework 2.6.1\n0xffffa038b992ebf0                    544016 /home/redman/git/linux-kernel-module-rust/something-special/somethingspecial.ko\n```\n\n```\n\u276f python2 volatility/vol.py -f mem.lime --profile=LinuxUbuntu_5_4_0-42-generic_profilex64 linux_find_file -i 0xffffa038b992ebf0 -O somethingspecial.ko\n```\nlinux_enumerate_files gets us the information we need to pull a file out of the dump and linux_find_file will actually do it.  \n\n\n### ghidra review\n\nnote: i've renamed some symbols from the obfuscated form, i'll try and give enough context to match symbols to their original form.  \n\n![init_module function](somethingspecial1.png)\n\nThe init_module function is somewhat painful to look at but fairly simple.  It runs a function and then branches based on the result.  Let's take a look at that first function!  \n\n![the first function call of init_module](somethingspecial2.png)\n\nThis function is also reasonably straightforward.  It calls a function, propagates result errors outwards, calls another function, etc.  We could look closer at the decompilation but fortunately that is not necessary because the symbols include the library name these functions are from.  \n\n![the kernel module library used](somethingspecial3.png)\n\nA quick google search for \"linux kernel module rust\" brings us to [it's github repository](https://github.com/fishinabarrel/linux-kernel-module-rust) and more particularly [the chrdev.rs file](https://github.com/fishinabarrel/linux-kernel-module-rust/blob/master/src/chrdev.rs)\n\n```rust\n    pub fn build(self) -> KernelResult<Registration> {\n        let mut dev: bindings::dev_t = 0;\n        let res = unsafe {\n            bindings::alloc_chrdev_region(\n                &mut dev,\n                self.minors.start.into(),\n                self.minors.len().try_into()?,\n                self.name.as_ptr() as *const c_types::c_char,\n            )\n        };\n        if res != 0 {\n            return Err(Error::from_kernel_errno(res));\n        }\n\n        // Turn this into a boxed slice immediately because the kernel stores pointers into it, and\n        // so that data should never be moved.\n        let mut cdevs = vec![unsafe { mem::zeroed() }; self.file_ops.len()].into_boxed_slice();\n        for (i, file_op) in self.file_ops.iter().enumerate() {\n            unsafe {\n                bindings::cdev_init(&mut cdevs[i], &file_op.0);\n                cdevs[i].owner = &mut bindings::__this_module;\n                let rc = bindings::cdev_add(&mut cdevs[i], dev + i as bindings::dev_t, 1);\n                if rc != 0 {\n                    // Clean up the ones that were allocated.\n                    for j in 0..=i {\n                        bindings::cdev_del(&mut cdevs[j]);\n                    }\n                    bindings::unregister_chrdev_region(dev, self.minors.len() as _);\n                    return Err(Error::from_kernel_errno(rc));\n                }\n            }\n        }\n\n        Ok(Registration {\n            dev,\n            count: self.minors.len(),\n            cdevs,\n        })\n    }\n```\n\nsomethingspecial.ko adds a character device when loaded.  Instead of trying to reverse the rest of this module we're just going to see what happens when we use the character device.  \n\n### getting the flag\n\nWe still have the Ubuntu VM from earlier so we can just use that.  \n\n`sudo insmod somethingspecial.ko`\n\n```\nteddy@teddy-Standard-PC-Q35-ICH9-2009:~$ ls /dev\nautofs           log           snd     tty3   tty56      ttyS23   vcsa1\nblock            loop0         sr0     tty30  tty57      ttyS24   vcsa2\nbsg              loop1         stderr  tty31  tty58      ttyS25   vcsa3\nbtrfs-control    loop2         stdin   tty32  tty59      ttyS26   vcsa4\nbus              loop3         stdout  tty33  tty6       ttyS27   vcsa5\ncdrom            loop4         tty     tty34  tty60      ttyS28   vcsa6\nchar             loop5         tty0    tty35  tty61      ttyS29   vcsu\nconsole          loop6         tty1    tty36  tty62      ttyS3    vcsu1\ncore             loop7         tty10   tty37  tty63      ttyS30   vcsu2\ncpu_dma_latency  loop-control  tty11   tty38  tty7       ttyS31   vcsu3\ncuse             mapper        tty12   tty39  tty8       ttyS4    vcsu4\ndisk             mcelog        tty13   tty4   tty9       ttyS5    vcsu5\ndri              mem           tty14   tty40  ttyprintk  ttyS6    vcsu6\ndvd              mqueue        tty15   tty41  ttyS0      ttyS7    vda\necryptfs         net           tty16   tty42  ttyS1      ttyS8    vda1\nfb0              null          tty17   tty43  ttyS10     ttyS9    vda2\nfd               nvram         tty18   tty44  ttyS11     udmabuf  vda5\nfull             port          tty19   tty45  ttyS12     uhid     vfio\nfuse             ppp           tty2    tty46  ttyS13     uinput   vga_arbiter\nhidraw0          psaux         tty20   tty47  ttyS14     urandom  vhci\nhpet             ptmx          tty21   tty48  ttyS15     userio   vhost-net\nhugepages        pts           tty22   tty49  ttyS16     vcs      vhost-vsock\nhwrng            random        tty23   tty5   ttyS17     vcs1     virtio-ports\ni2c-0            rfkill        tty24   tty50  ttyS18     vcs2     vport1p1\ninitctl          rtc           tty25   tty51  ttyS19     vcs3     vport1p2\ninput            rtc0          tty26   tty52  ttyS2      vcs4     zero\nkmsg             sg0           tty27   tty53  ttyS20     vcs5     zfs\nkvm              shm           tty28   tty54  ttyS21     vcs6\nlightnvm         snapshot      tty29   tty55  ttyS22     vcsa\n```\n\nI don't see anything under /dev but /proc/devices shows that the device is registered (and the major version for the device).  \n\n```\nteddy@teddy-Standard-PC-Q35-ICH9-2009:~$ cat /proc/devices \nCharacter devices:\n...\n239 something-special\n...\n```\n\nLet's just try making a filesystem node for that device.  \n\n`sudo mknod somethingspecial c 239 0`\n\n`cat somethingspecial` gives us an endless repeating stream of `gigem{redman_has_bad_memory}` - which is the flag we're looking for!\n\nflag: `gigem{redman_has_bad_memory}`\n\n## Creation\n\nFirst, we create a Ubuntu 20.04 Server VM. How you do this is mostly up to you, but I used\nQEMU/KVM. In this VM, we create a user who downloads the [linux-kernel-module-rust] library and\nadds the something-special folder present in this directory. something-special is compiled\nand `insmod`'d into existence. Logout.\n\nThe \"attacker\" comes in, builds LiME forensics suite for imaging the physical memory space.\nThis image is then exfiltrated over TCP in compressed format to the attacker. Logout.\n\n\n[linux-kernel-module-rust]: https://github.com/fishinabarrel/linux-kernel-module-rust/blob/master/tests/chrdev/tests/tests.rs\n",
    "somethingspecial1.png": "[Binary file or unsupported type: png]",
    "somethingspecial2.png": "[Binary file or unsupported type: png]",
    "somethingspecial3.png": "[Binary file or unsupported type: png]",
    "something-special\\Cargo.toml": "[package]\nname = \"something-special\"\nversion = \"0.1.0\"\nauthors = [\"Reggie Redman <reggie@redman.local>\"]\nedition = \"2018\"\n\n[lib]\ncrate-type = [\"staticlib\"]\n\n[dependencies]\nhex-literal = \"0.3.1\"\nlinux-kernel-module = { path = \"..\" }\n",
    "something-special\\Kbuild": "obj-m := somethingspecial.o\nsomethingspecial-objs := something_special.rust.o\n\nCARGO ?= cargo\n\nexport c_flags\n\n$(src)/target/x86_64-linux-kernel/debug/libsomething_special.a: cargo_will_determine_dependencies\n\tcd $(src); $(CARGO) build -Z build-std=core,alloc --target=x86_64-linux-kernel\n\n.PHONY: cargo_will_determine_dependencies\n\n%.rust.o: target/x86_64-linux-kernel/debug/lib%.a\n\t$(LD) -r -o $@ --whole-archive $<\n",
    "something-special\\Makefile": "export KDIR ?= /lib/modules/$(shell uname -r)/build\n\nCLANG ?= clang\nifeq ($(origin CC),default)\nCC := ${CLANG}\nendif\n\nall:\n\t$(MAKE) -C $(KDIR) M=$(CURDIR) CC=$(CC) CONFIG_CC_IS_CLANG=y\n\nclean:\n\t$(MAKE) -C $(KDIR) M=$(CURDIR) CC=$(CC) clean\n",
    "something-special\\src\\lib.rs": "#![no_std]\n\nextern crate alloc;\n\nuse alloc::borrow::ToOwned;\nuse alloc::string::String;\n\nuse hex_literal::hex;\n\nuse linux_kernel_module::{cstr, println, self};\n\nstatic SOMETHING: [u8; 28] = hex!(\"c7ebb16296e5a9a9cb202e816cd12d0ca82a5c6e54db96d6bb5e5fad\");\nstatic SPECIAL: [u8; 28] = hex!(\"a082d607fb9edbccaf4d4fef33b94c7ff7483d0a0bb6f3bbd42c26d0\");\n\nstruct CycleFile;\n\nimpl linux_kernel_module::file_operations::FileOperations for CycleFile {\n    const VTABLE: linux_kernel_module::file_operations::FileOperationsVtable =\n        linux_kernel_module::file_operations::FileOperationsVtable::builder::<Self>()\n            .read()\n            .build();\n\n    fn open() -> linux_kernel_module::KernelResult<Self> {\n        Ok(CycleFile)\n    }\n}\n\nimpl linux_kernel_module::file_operations::Read for CycleFile {\n    fn read(\n        &self,\n        _file: &linux_kernel_module::file_operations::File,\n        buf: &mut linux_kernel_module::user_ptr::UserSlicePtrWriter,\n        offset: u64,\n    ) -> linux_kernel_module::KernelResult<()> {\n        for (c, x) in SOMETHING.iter().zip(SPECIAL.iter())\n            .cycle()\n            .skip((offset % 9) as _)\n            .take(buf.len())\n        {\n            buf.write(&[c ^ x])?;\n        }\n        Ok(())\n    }\n}\n\nstruct SomethingSpecialModule {\n    _chrdev_registration: linux_kernel_module::chrdev::Registration,\n}\n\nimpl linux_kernel_module::KernelModule for SomethingSpecialModule {\n    fn init() -> linux_kernel_module::KernelResult<Self> {\n        let chrdev_registration =\n            linux_kernel_module::chrdev::builder(cstr!(\"something-special\"), 0..1)?\n                .register_device::<CycleFile>()\n                .build()?;\n        println!(\"Ah, now you won't forget! :)\");\n        Ok(SomethingSpecialModule {\n            _chrdev_registration: chrdev_registration,\n        })\n    }\n}\n\nimpl Drop for SomethingSpecialModule {\n    fn drop(&mut self) {\n        println!(\"Don't forget me!!\");\n    }\n}\n\nlinux_kernel_module::kernel_module!(\n    SomethingSpecialModule,\n    author: b\"Reggie Redman\",\n    description: b\"Something special I never want to forget\",\n    license: b\"WTFPL\"\n);\n",
    "category": "forensics"
}