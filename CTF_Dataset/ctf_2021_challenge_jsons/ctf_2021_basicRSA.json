{
    "challenge.py": "from hacksport.problem import Challenge, File\n\nclass Problem(Challenge):\n    def setup(self):\n        self.files = [File(\"data.txt\")]\n\n    def generate_flag(self, random):\n        return r\"gigem{RSA_s3cur1ty_1s_4b0ut_pr1m3s}\"\n",
    "data.txt": "N = 2095975199372471\ne = 5449\ngigem{ 875597732337885 1079270043421597 616489707580218 2010079518477891 1620280754358135 616660320758264 86492804386481 171830236437002 1500250422231406 234060757406619 1461569132566245 897825842938043 2010079518477891 234060757406619 1620280754358135 2010079518477891 966944159095310 1669094464917286 1532683993596672 171830236437002 1461569132566245 2010079518477891 221195854354967 1500250422231406 234060757406619 355168739080744 616660320758264 1620280754358135 }\n",
    "problem.json": "{\n  \"name\": \"Basic RSA\",\n  \"category\": \"Crypto\",\n  \"description\": \"To: Dr Rivest\\nCC: Dr Shamir\\n\\nWe found this code and these numbers. {{url_for('data.txt')}}\\nMean anything to you?\\n\\nSincerely\\n- Dr Adleman\",\n  \"score\" : 100,\n  \"hints\": [\"The names are very specific\", \"Maybe you don't have to break the number to decrypt the challenge\"],\n  \"walkthrough\": \"check our github or something\",\n  \"author\": \"Glenn Fitzpatrick\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf 2021\"\n}\n",
    "README.md": "# Basic RSA\n\n## Description\nTo: Dr. Rivest\nCC: Dr. Shamir\n\nWe found this code and these numbers.\nMean anything to you?\n\nSincerely\n- Dr. Adleman\n\n## solution\n\n<details>\n  <summary>Thinking Process</summary>\n  \n  Starting from nothing, I see three names with some weird numbers and specific variable names.\nI also see the gigem{} flag format with spaced blocks of numbers inside of it.\n\nIf I google Rivest, I find information about Ron Rivest, the cryptographer and co-inventor of RSA. \n\nIf I google \"N e encryption\" I find a page on the RSA algorithm.\n\nFrom the names of people and variable names, I can assume that the RSA encyption algorithm is involved.\n\nI find a basic guide on generating a key and decryption: https://www.di-mgt.com.au/rsa_alg.html#decryption\n\nI have n but not d, and I need to compute m  = c^d mod n, then get the plaintext using m.\n\nTo get d, I need p and q.\n\nI use an online tool, `factorize 15241604814814604814814604814814609737853` \nhttps://www.wolframalpha.com/input/?i=factorize+15241604814814604814814604814814609737853\n\nFollowing the given examples, I tried to implement decryption using a guessed d, but didn't make progress (see commented out code). I got blocks of numbers out of range to be converted into UTF or ASCII, so I assumed that my d was incorrect.\n\nI searched more and found that RSA is not \"RSA\". RSA with no padding or randomness (\"Textbook RSA\") isn't very good encrpytion, and the actual standard specifies padding and randomness. Since padding and randomness wasn't specified in the message, I looked elsewhere. I found a stackoverflow post which suggested a brute force attack of encrypting all possible values\n\n---\n\nYou can run an exhaustive search on the possible plaintexts. No padding means no randomness; encryption is deterministic, so you can \"try\" plaintexts and see if one matches the encrypted value when encrypted.\n\nhttps://crypto.stackexchange.com/questions/6770/cracking-an-rsa-with-no-padding-and-very-small-e\n\n---\n\nA more academic source\n\"Since textbook RSA is deterministic, if the messagemis chosenfrom a small list of possible values, then it is possible to determinemfrom the ciphertextc=[memodN] by trying each value ofm,1\uf8ffm\uf8ffL.\"\nhttp://cs.wellesley.edu/~cs310/lectures/26_rsa_slides_handouts.pdf\n\nI changed my approach to find the equivalent input to the encryption function that produces the same output as the current cipher block, then add that input to the output.\n\n---\n\n</details>\n\n<details>\n  <summary>Python Solution</summary>\n  \n  ```python\n# requires python >= 3.9\nimport string\n\nN = 2095975199372471\ne = 5449\ninput_string = \"gigem{ 875597732337885 1079270043421597 616489707580218 2010079518477891 1620280754358135 616660320758264 86492804386481 171830236437002 1500250422231406 234060757406619 1461569132566245 897825842938043 2010079518477891 234060757406619 1620280754358135 2010079518477891 966944159095310 1669094464917286 1532683993596672 171830236437002 1461569132566245 2010079518477891 221195854354967 1500250422231406 234060757406619 355168739080744 616660320758264 1620280754358135 }\"\n# provided information\n\nprepend = \"gigem{ \"\npostpend = \" }\"\n\n# from https://www.wolframalpha.com/input/?i=factorize+15241604814814604814814604814814609737853\np = 123457\nq = 123456789123456789123456789123456829\n\nphi = (p-1)*(q-1)\nassert (e>1 & e < phi), \"e is out of range\"\n\n#find rsa D using multiplicative inverse\nd = pow(e, -1, phi)\n\n# split input text\ninput_as_list = input_string.removeprefix(prepend).removesuffix(postpend).split(\" \")\n\n\n#out_num = []\n#for string_block in input_as_list: #decrypt each 'block'\n#    cipher_block = int(string_block)\n#    assert str(cipher_block) == string_block, \"String did not become equiv base 10 int\"\n#    msg_block = pow(cipher_block, d, N) #apply to each block\n#    out_num.append(msg_block)\n\ndef cipher(n: int, e: int, plaintext: str) -> int:\n    # given public key (n,e), cipher the plaintext str into an integer ciphertext\n    # https://www.di-mgt.com.au/rsa_alg.html\n    # convert plaintext to an int\n    assert len(plaintext) == 1\n    m = ord(plaintext)\n    assert (1 < m) & (m < n)\n    ciphertext = pow(m, e) % n\n    return ciphertext\n\nout_str = \"\"\nfor string_block in input_as_list: # decrypt each 'block'\n    cipher_block = int(string_block)\n    for char in string.printable:\n        if cipher_block == cipher(N,e,char):\n            out_str+=char\n            break\n\nprint(prepend+out_str+postpend)\n```\n  \n</details>\n",
    "category": "crypto"
}