{
    "Dockerfile": "FROM python:slim-buster\n\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\n\nCOPY flag.py /crypto/flag.py\nCOPY server.py /crypto/server.py\nWORKDIR /crypto\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:\\\"python3 /crypto/server.py\\\",stderr\" > /crypto/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/crypto/docker_entrypoint.sh\"]\n",
    "flag.py": "flag = \"gigem{D0nt_r0ll_y0uR_oWn_RnG}\"\nm = pow(2, 64)\na = 69\nc = 69\n\n",
    "Makefile": "NAME := prng\nPORT := 7001\n\ndocker: Dockerfile\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nclean:\n\tdocker rm -f $(NAME) ; docker rmi $(NAME)\n\ndist:\n\tzip $(NAME).zip server.py\n",
    "README.md": "# PRNG\n\nAuthor: `anomie`\n\nI know they say don't roll your own crypto, but secure RNG should be easy. How hard could it be?\n\n## Dev Notes\nGiven file `server.py`\n\n## Solution\nThis challenge implements a [linear congruential generator](https://en.wikipedia.org/wiki/Linear_congruential_generator) as a pseudo-random number generator. We're tasked with finding the next 10 outputs given the first 10, but we don't know the starting parameters. I googled \"find LCG parameters\" and eventually found https://github.com/jvdsn/crypto-attacks/blob/master/attacks/lcg/parameter_recovery.py. Given the original parameters, we can easily compute the next 10 outputs. See `solve.py` for details.\n\nFlag: `gigem{D0nt_r0ll_y0uR_oWn_RnG}`\n",
    "server.py": "import secrets\nfrom flag import flag, m, a, c\n\nclass Rand:\n    def __init__(self, seed):\n        self.m = m\n        self.a = a\n        self.c = c\n        self.seed = seed\n        if seed % 2 == 0: # initial state must be odd\n            self.seed += 1\n\n    def rand(self):\n        self.seed = (self.a * self.seed + self.c) % self.m\n        return self.seed\n\ndef main():\n    seed = secrets.choice(range(0, 0x7fffffffffffffff))\n    rng = Rand(seed)\n    \n    chall = []\n    for _ in range(10):\n        chall.append(rng.rand())\n\n    print(f\"Authenticate. Provide the next 10 numbers following\")\n    for c in chall:\n        print(c)\n\n    for _ in range(10):\n        x = int(input('> '))\n        if x != rng.rand():\n            print(\"Access denied.\")\n            exit()\n    \n    print(\"Access granted.\")\n    print(flag)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "solve.py": "from pwn import *\nfrom math import gcd\n\np = remote(\"localhost\", 7001)\np.recvline()\ny = [int(p.recvlineS()) for _ in range(10)]\n\nm = 0\nfor i in range(len(y) - 3):\n    d0 = y[i + 1] - y[i]\n    d1 = y[i + 2] - y[i + 1]\n    d2 = y[i + 3] - y[i + 2]\n    g = d2 * d0 - d1 * d1\n    m = g if m == 0 else gcd(g, m)\n\nt1 = (y[2] - y[1]) % m\nt2 = (y[1] - y[0]) % m\na = t1 * pow(t2, -1, m) % m\nc = (y[1] - a * y[0]) % m\n\nstate = y[-1]\nfor _ in range(10):\n    state = (a * state + c) % m\n    p.sendline(str(state).encode())\nprint(p.recvline_containsS(b\"gigem\"))\n",
    "category": "crypto"
}