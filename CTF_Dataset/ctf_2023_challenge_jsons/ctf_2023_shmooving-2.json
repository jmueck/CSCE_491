{
    ".gitignore": "/target\n",
    "A.data": "[Binary file or unsupported type: data]",
    "Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"shmooving-2\"\nversion = \"0.1.0\"\n",
    "Cargo.toml": "[package]\nname = \"shmooving-2\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n",
    "Dockerfile": "FROM rust as build\n\nADD src /build/src\nADD Cargo.toml /build/Cargo.toml\nADD flag.txt /build/flag.txt\n\nWORKDIR /build\n\nRUN cargo build --release\n\nFROM debian:buster-slim\n\nARG port\nARG name\n\nRUN apt update; apt -y install socat\nCOPY --from=build /build/target/release/$name /crypto/$name\nCOPY --from=build /build/flag.txt flag.txt\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/crypto/$name,stderr\" > /crypto/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/crypto/docker_entrypoint.sh\"]\n",
    "encouragement.txt.enc": "[Binary file or unsupported type: enc]",
    "flag.txt": "gigem{l1n34r_syst3ms_4r3_sc4ry}\n",
    "flag.txt.enc": "[Binary file or unsupported type: enc]",
    "Makefile": "NAME := shmooving-2\n\ndist:\n\tcargo run --release\n\tzip -j $(NAME).zip encouragement.txt.enc flag.txt.enc src/main.rs\nclean:\n\trm -f $(NAME).zip flag.txt.enc encouragement.txt.enc\n",
    "README.md": "# Shmooving 2\n\nAuthor: `nhwn`\n\nMy AES-128 implementation was too slow, so I removed some non-essential logic. Good luck getting the flag!\n\n## Solution\nLooking at main.rs, we see that AES has been implemented in ECB mode except the `sub_bytes()` step has been commented out. Since the S-Box is the only part of AES that is non-linear, by removing that step, we now have a cipher that can be solved with some linear equations.  \n\nEffectively, AES is now an affine cipher that can be represented with the equation: `c = Ap + K`\n(If you want to read more about this go check out this crypto stack exchange post: https://crypto.stackexchange.com/questions/20228/consequences-of-aes-without-any-one-of-its-operations)\n\nThe tricky part is finding the A matrix. But I did this by commenting out the `add_round_key()` step and encrypting 128 inputs, each with only a single bit set to 1 and all others set to 0. The 128 outputs generated are the columns of the A matrix and which can then be used to create our needed matrix.\n\nIn `solve.py` we use `A.data` to build the A matrix (the file is `A` in byte form), solve for `K` using the known plaintext/ciphertext pair, and then decrypt the flag using the given ciphertext.\n\nflag: \n`gigem{l1n34r_syst3ms_4r3_sc4ry}`\n",
    "solve.py": "import numpy as np\nimport galois\n\nGF = galois.GF(2)\ncolumns = [] \nptxt = b'Good luck with the challenge! :D'\nflag = ''\n\n# convert byte string to an array of binary values\ndef b_to_ar(b):\n\tb_int = int.from_bytes(b, 'big')\n\tx = []\n\tfor i in range(128):\n\t\tmask = (1 << 127 - i)\n\t\tx.append((b_int & mask) >> 127 - i)\n\treturn x\n\n# convert binary matrix to its byte string\ndef matrix_to_byte(m):\n\ts = 0\n\tfor i in range(128): \n\t\ts *= 2 \n\t\tif m[i] > 0:\n\t\t\ts += 1\n\treturn s.to_bytes(16, 'big')\n\n# Read encrypted ciphertext and convert to a matrix\nwith open('encouragement.txt.enc', 'rb') as file:\n\tctxt = file.read()\n\n# Read in the encrypted flag\nwith open('flag.txt.enc', 'rb') as file:\n\tflag_enc = file.read()\n\n# Read in the A matrix (as bytes) and convert to a 2D array\nwith open('A.data', 'rb') as file:\n\tdata = file.read()\n\tfor i in range(len(data) // 16):\n\t\trow = data[16 * i : 16 * (i + 1)]\n\t\tbit_str = b_to_ar(row)\n\t\tcolumns.append(bit_str)\n\n# Convert the array to a galois field and compute its inverse\nA = GF(columns)\nA_inv = np.linalg.inv(A)\n\n# We will calculate the K matrix with our known plaintext/ciphertext pair\nc = GF(b_to_ar(ctxt[:16]))\np = GF(b_to_ar(ptxt[:16]))\n\n# Use the known plaintext and ciphertext pair to calculate the K vector (K = A * p - c)\nAp = np.matmul(A, p)\nK = c - Ap\n\n# Now we shall decrypt the flag! p = A^-1 * (c - K)\nfor i in range(len(flag_enc) // 16):\n\t# Go through block by block\n\tblock = flag_enc[16 * i: 16 * (i + 1)]\n\tblock = GF(b_to_ar(block))\n\n\t# c - k\n\tck = block - K\n\n\t# p = A^-1 * (c - K)\n\tplain = np.matmul(A_inv, ck)\n\tdecoded = matrix_to_byte(plain)\n\tflag += decoded.decode()\n\n\nprint(flag)",
    "src\\main.rs": "static SBOX: [u8; 256] = [\n    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,\n];\nstatic RCON: [u8; 11] = [\n    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,\n];\n\nfn xtime(x: u8) -> u8 {\n    (x << 1) ^ (((x >> 7) & 1) * 0x1b)\n}\nfn add_round_key(s: &mut [u8; 16], key: &[u8; 16]) {\n    s.iter_mut().zip(key.iter()).for_each(|(s, k)| *s ^= k);\n}\nfn sub_bytes(s: &mut [u8; 16]) {\n    // rigorous benchmarking shows that this makes encryption 69% faster\n    // s.iter_mut().for_each(|s| *s = SBOX[*s as usize]);\n}\nfn mix_columns(s: &mut [u8; 16]) {\n    for s in s.chunks_exact_mut(4) {\n        let t = s[0] ^ s[1] ^ s[2] ^ s[3];\n        let old_s0 = s[0];\n        s[0] ^= t ^ xtime(s[0] ^ s[1]);\n        s[1] ^= t ^ xtime(s[1] ^ s[2]);\n        s[2] ^= t ^ xtime(s[2] ^ s[3]);\n        s[3] ^= t ^ xtime(s[3] ^ old_s0);\n    }\n}\nfn shift_rows(s: &mut [u8; 16]) {\n    for col in 0..4 {\n        let (i0, i1, i2, i3) = (col, col + 4, col + 8, col + 12);\n        for _ in 0..col {\n            let t = s[i0];\n            s[i0] = s[i1];\n            s[i1] = s[i2];\n            s[i2] = s[i3];\n            s[i3] = t;\n        }\n    }\n}\nfn blocks(blocks: &mut [u8]) -> impl Iterator<Item = &mut [u8; 16]> + '_ {\n    assert_eq!(blocks.len() % 16, 0);\n    blocks.chunks_exact_mut(16).map(|block| block.try_into().unwrap())\n}\n\npub struct Aes128 {\n    schedule: [[u8; 16]; 11],\n}\n\nimpl Aes128 {\n    pub fn new(key: &[u8; 16]) -> Self {\n        let mut schedule = [[0u8; 16]; 11];\n\n        schedule[0] = *key;\n\n        // SAFETY: imagine checking invariants \n        let w = unsafe {\n            &mut *schedule.as_mut_ptr().cast::<[[u8; 4]; 44]>()\n        };\n\n        for i in 4..44 {\n            let mut temp = w[i - 1];\n            if i % 4 == 0 {\n                temp.rotate_left(1);\n                temp.iter_mut().for_each(|x| *x = SBOX[*x as usize]);\n                temp[0] ^= RCON[i / 4];\n            }\n            temp.iter_mut().zip(w[i - 4].iter()).for_each(|(t, w)| *t ^= *w);\n            w[i] = temp;\n        }\n\n        Self { schedule }\n    }\n    pub fn encrypt(&self, plaintext: &mut [u8]) {\n        for block in blocks(plaintext) {\n            add_round_key(block, &self.schedule[0]);\n            for key in &self.schedule[1..10] {\n                sub_bytes(block);\n                shift_rows(block);\n                mix_columns(block);\n                add_round_key(block, key);\n            }\n            sub_bytes(block);\n            shift_rows(block);\n            add_round_key(block, &self.schedule[10]);\n        }\n    }\n}\n\nuse std::fs::File;\nuse std::io::Read;\n\nfn gen_key() -> [u8; 16] {\n    let mut buf = [0; 16];\n    let mut f = File::open(\"/dev/random\").unwrap();\n    f.read_exact(&mut buf).unwrap();\n    buf\n}\n\nfn main() {\n    let key = gen_key();\n    let cipher = Aes128::new(&key);\n    let mut encouragement = *b\"Good luck with the challenge! :D\";\n    cipher.encrypt(&mut encouragement);\n    std::fs::write(\"encouragement.txt.enc\", &encouragement).unwrap();\n    let mut flag = std::fs::read(\"flag.txt\").unwrap();\n    cipher.encrypt(&mut flag);\n    std::fs::write(\"flag.txt.enc\", &flag).unwrap();\n}\n",
    "category": "crypto"
}