{
    ".gitignore": "binaries/\n*.zip\n",
    "Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"anyhow\"\nversion = \"1.0.68\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2cb2f989d18dd141ab8ae82f64d1a8cdd37e0840f73a406896cf5e99502fab61\"\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"1.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n\n[[package]]\nname = \"bytes\"\nversion = \"1.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dfb24e866b15a1af2a1b663f10c6b6b8f397a84aadb828f12e5b289ec23a3a3c\"\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"friend\"\nversion = \"0.1.0\"\ndependencies = [\n \"proto\",\n]\n\n[[package]]\nname = \"launcher\"\nversion = \"0.1.0\"\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.139\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n\n[[package]]\nname = \"log\"\nversion = \"0.4.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"memchr\"\nversion = \"2.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n\n[[package]]\nname = \"memoffset\"\nversion = \"0.7.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"mio\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e5d732bc30207a6423068df043e3d02e0735b155ad7ce1a6f76fe2baa5b158de\"\ndependencies = [\n \"libc\",\n \"log\",\n \"wasi\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"nix\"\nversion = \"0.26.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bfdda3d196821d6af13126e40375cdf7da646a96114af134d5f417a9a1dc8e1a\"\ndependencies = [\n \"bitflags\",\n \"cfg-if\",\n \"libc\",\n \"memoffset\",\n \"pin-utils\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"pin-project-lite\"\nversion = \"0.2.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e0a7ae3ac2f1173085d398531c705756c94a4c56843785df85a60c1a0afac116\"\n\n[[package]]\nname = \"pin-utils\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184\"\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.50\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6ef7d57beacfaf2d8aee5937dab7b7f28de3cb8b1828479bb5de2a7106f2bae2\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"proto\"\nversion = \"0.1.0\"\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.23\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8856d8364d252a14d474036ea1358d63c9e6965c8e5c1885c18f73d70bff9c7b\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"server\"\nversion = \"0.1.0\"\ndependencies = [\n \"anyhow\",\n \"nix\",\n \"tokio\",\n]\n\n[[package]]\nname = \"signal-hook-registry\"\nversion = \"1.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e51e73328dc4ac0c7ccbda3a494dfa03df1de2f46018127f60c693f2648455b0\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"socket2\"\nversion = \"0.4.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"02e2d2db9033d13a1567121ddd7a095ee144db4e1ca1b1bda3419bc0da294ebd\"\ndependencies = [\n \"libc\",\n \"winapi\",\n]\n\n[[package]]\nname = \"static_assertions\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n\n[[package]]\nname = \"syn\"\nversion = \"1.0.107\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1f4064b5b16e03ae50984a5a8ed5d4f8803e6bc1fd170a3cda91a1be4b18e3f5\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"tokio\"\nversion = \"1.24.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"597a12a59981d9e3c38d216785b0c37399f6e415e8d0712047620f189371b0bb\"\ndependencies = [\n \"autocfg\",\n \"bytes\",\n \"libc\",\n \"memchr\",\n \"mio\",\n \"pin-project-lite\",\n \"signal-hook-registry\",\n \"socket2\",\n \"tokio-macros\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"tokio-macros\"\nversion = \"1.8.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d266c00fde287f55d3f1c3e96c500c362a2b8c695076ec180f27918820bc6df8\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn\",\n]\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"84a22b9f218b40614adcb3f4ff08b703773ad44fa9423e4e0d346d5db86e4ebc\"\n\n[[package]]\nname = \"wasi\"\nversion = \"0.11.0+wasi-snapshot-preview1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n\n[[package]]\nname = \"winapi\"\nversion = \"0.3.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\ndependencies = [\n \"winapi-i686-pc-windows-gnu\",\n \"winapi-x86_64-pc-windows-gnu\",\n]\n\n[[package]]\nname = \"winapi-i686-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n\n[[package]]\nname = \"winapi-x86_64-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n\n[[package]]\nname = \"windows-sys\"\nversion = \"0.42.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\ndependencies = [\n \"windows_aarch64_gnullvm\",\n \"windows_aarch64_msvc\",\n \"windows_i686_gnu\",\n \"windows_i686_msvc\",\n \"windows_x86_64_gnu\",\n \"windows_x86_64_gnullvm\",\n \"windows_x86_64_msvc\",\n]\n\n[[package]]\nname = \"windows_aarch64_gnullvm\"\nversion = \"0.42.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8c9864e83243fdec7fc9c5444389dcbbfd258f745e7853198f365e3c4968a608\"\n\n[[package]]\nname = \"windows_aarch64_msvc\"\nversion = \"0.42.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4c8b1b673ffc16c47a9ff48570a9d85e25d265735c503681332589af6253c6c7\"\n\n[[package]]\nname = \"windows_i686_gnu\"\nversion = \"0.42.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"de3887528ad530ba7bdbb1faa8275ec7a1155a45ffa57c37993960277145d640\"\n\n[[package]]\nname = \"windows_i686_msvc\"\nversion = \"0.42.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bf4d1122317eddd6ff351aa852118a2418ad4214e6613a50e0191f7004372605\"\n\n[[package]]\nname = \"windows_x86_64_gnu\"\nversion = \"0.42.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c1040f221285e17ebccbc2591ffdc2d44ee1f9186324dd3e84e99ac68d699c45\"\n\n[[package]]\nname = \"windows_x86_64_gnullvm\"\nversion = \"0.42.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"628bfdf232daa22b0d64fdb62b09fcc36bb01f05a3939e20ab73aaf9470d0463\"\n\n[[package]]\nname = \"windows_x86_64_msvc\"\nversion = \"0.42.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"447660ad36a13288b1db4d4248e857b510e8c3a225c822ba4fb748c0aafecffd\"\n",
    "Cargo.toml": "[workspace]\nmembers = [\n    \"proto\",\n    \"server\",\n    \"friend\",\n    \"launcher\",\n]\n\n[profile.release]\ndebug = true\ncodegen-units = 1\n",
    "client.png": "[Binary file or unsupported type: png]",
    "Dockerfile": "FROM rust:alpine as build\n\nRUN apk update\nRUN apk add --no-cache openssl-dev musl-dev\n\nADD Cargo.toml Cargo.toml\nADD Cargo.lock Cargo.lock\nADD friend friend\nADD proto proto\nADD server server\nADD launcher launcher\n\nRUN cargo build --release\n\nADD flag.txt flag.txt\nRUN chmod 400 flag.txt\n\nFROM scratch\n\nCOPY --from=build /proc /proc\nCOPY --from=build /target/release/friend /friend\nCOPY --from=build /target/release/server /server\nCOPY --from=build /target/release/launcher /launcher\nCOPY --from=build /flag.txt /flag.txt\n\nUSER 0\n\nENTRYPOINT [\"/launcher\"]\n",
    "flag.txt": "gigem{cut_me_some_slack000}",
    "Makefile": "NAME := absolute-cap\nPORT := 16983\n\nrun: docker\n\tdocker run -d --cap-add cap_sys_nice --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nclean: .PHONY\n\tdocker container rm -f $(NAME)\n\trm -f $(NAME)\n\ndocker: Dockerfile Cargo.toml friend server\n\tdocker buildx build -t $(NAME) --build-arg name=$(NAME) .\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tmkdir -p binaries\n\tdocker cp $(id):/server - | tar -C binaries -xv server\n\tdocker cp $(id):/friend - | tar -C binaries -xv friend\n\tdocker rm -v $(id)\n\ndist: extract server\n\tzip -r $(NAME).zip binaries server\n\n.PHONY:\n",
    "README.md": "# absolute-cap\n\nAuthor: `Addison`\n\nLook, I tried to write some flavour text for this challenge, but it's really a straightforward blind reversing\nchallenge. We've provided you with two binaries, both present and running on the server. Connections to the server\nconnect to the \"server\" binary. **There are no other binaries present on the server, not even system utilities**.\n\nBreathe, step back, and enjoy a little Rust reversing. :)\n\n## Solution\n\nA quick inspection of the `server` binary indicates that the server accepts a command, `execute`, followed by a size\nindicator, followed by an ELF to be executed. Whatever we end up doing, we'll need to send a binary to the server to be\nexecuted. A quick test binary shows that there is very little present in the container: `friend`, `server`, `flag.txt`,\nand `/proc`. `flag.txt` cannot be read, giving a \"permission denied\" error. It seems that we will have to reverse\n`friend` in order to determine what our binary must do.\n\nWith the `friend` binary being written in Rust, it makes it relatively difficult to reverse. However, we can piece\ntogether what this binary does by inspecting its runtime behaviour. To start with, let's look at strace:\n\n```c\nopen(\"/proc/14135/timerslack_ns\", O_RDONLY|O_CLOEXEC) = 3\nfcntl(3, F_SETFD, FD_CLOEXEC)           = 0\nfstat(3, {st_mode=S_IFREG|0666, st_size=0, ...}) = 0\nread(3, 0x555555aa5160, 32)             = -1 EPERM (Operation not permitted)\nclose(3)> >     = 0\nopen(\"/proc/14168/timerslack_ns\", O_RDONLY|O_CLOEXEC) = 3\nfcntl(3, F_SETFD, FD_CLOEXEC)           = 0\nfstat(3, {st_mode=S_IFREG|0666, st_size=0, ...}) = 0\nread(3, 0x555555aa5160, 32)             = -1 EPERM (Operation not permitted)\nclose(3)> >     = 0\nopen(\"/proc/14171/timerslack_ns\", O_RDONLY|O_CLOEXEC) = 3\n```\n\nWe see quite a bit of accesses to timerslack_ns. Referring to the [manual page](https://man7.org/linux/man-pages/man5/proc.5.html),\nwe see the following:\n\n> This file exposes the process's \"current\" timer slack\n> value, expressed in nanoseconds.  **The file is writable,**\n> allowing the process's timer slack value to be changed.\n> Writing 0 to this file resets the \"current\" timer slack to\n> the \"default\" timer slack value.  For further details, see\n> the discussion of PR_SET_TIMERSLACK in prctl(2).\n\nA quick look into a random /proc/[pid] later:\n\n```\n$ ls -alh /proc/14/timerslack_ns \n-rw-rw-rw-. 1 root root 0 22. Apr 02:56 /proc/14/timerslack_ns\n```\n\nIt would appear that this is a globally writable file. With that said, this would require CAP_SYS_NICE set on the\nbinary, so for now we'll just use sudo. Let's inspect how the process intends to interact with the file.\n\n```\ngef\u27a4  break open\nBreakpoint 1 at 0x49138: file ../src_musl/src/fcntl/open.c, line 6.\ngef\u27a4  run\nStarting program: /home/addisoncrump/git/tamuctf-2023/rev/absolute-cap/binaries/friend \n... SNIP ...\n[#0] 0x7ffff7fda138 \u2192 open()\n[#1] 0x7ffff7fd9c13 \u2192 opendir()\n[#2] 0x7ffff7fb7774 \u2192 std::sys::unix::fs::readdir::{closure#0}()\n[#3] 0x7ffff7fb7774 \u2192 std::sys::common::small_c_string::run_with_cstr<*mut libc::unix::DIR, std::sys::unix::fs::readdir::{closure_env#0}>()\n[#4] 0x7ffff7fb7774 \u2192 std::sys::common::small_c_string::run_path_with_cstr<*mut libc::unix::DIR, std::sys::unix::fs::readdir::{closure_env#0}>()\n[#5] 0x7ffff7fb7774 \u2192 std::sys::unix::fs::readdir()\n[#6] 0x7ffff7f9ae26 \u2192 std::fs::read_dir<&str>(path=<error: Cannot access memory at address 0x90000>)\n[#7] 0x7ffff7f9ae26 \u2192 proto::Client::find_server()\n[#8] 0x7ffff7f993ab \u2192 friend::main()\n```\n\nIt would seem that this open is coming from a method called \"find_server\". Looking back in Ghidra, we can explore the\nClient namespace for relevant methods, as the binary was exported with debug symbols:\n\n![picture of the Client namespace](client.png)\n\nIt is likely that these methods are what will write a message to our program, and we can guess that this message will\nbe sent over `timerslack_ns` given that `friend` is searching for something in all the `timerslack_ns` files. After\nskimming through the `find_server` method for a bit, we see that there is an interesting comparison:\n\n```c\nif (CONCAT44(uStack_bc,local_c0) == 0x696d636c69656e74) {\n    ...\n}\n```\n\nThis 8-byte value is composed of ASCII characters!\n\n```bash\n$ echo 696d636c69656e74 | xxd -r -p\nimclient\n```\n\nThus, the `friend` binary is searching for a process with number corresponding to `imclient` in the `timerslack_ns`\nfile. We know that it must be a number, as the `timerslack_ns` process only accepts string representations of numbers\nas inputs. To test this, we can modify the `timerslack_ns` of a local program and see what happens when we run `friend`.\n\n```bash\nterm-1$ sleep 3600\nterm-2$ ps aux | grep sleep\naddison+   16457  0.0  0.0 221580  2176 pts/3    S+   03:20   0:00 sleep 3600\nterm-2$ python3 -c 'print(0x696d636c69656e74)' | sudo tee /proc/16457/timerslack_ns \n7596837463719767668\nterm-2$ sudo ./friend \nFound a server!: /proc/16457/timerslack_ns\n^C\nterm-2$ sudo cat /proc/16457/timerslack_ns\n7596855025993147762\nterm-2$ python3 -c 'print(hex(7596855025993147762))'\n0x696d736572766572\nterm-2$ echo 696d736572766572 | xxd -r -p\nimserver\n```\n\nIt would appear that as soon as the `friend` binary finds a \"client\", it writes `imserver` into the timerslack_ns of the\nprocess which originally wrote `imclient` into the `timerslack_ns` file.\n\nLooking through `main` in Ghidra, we see that the next method used on Client is `wait_until_ready`, which checks for two\npotential values (commented with their ASCII forms):\n\n```c\n// imdying!\nif (local_38 == (Result<(),_std::io::error::Error>)0x696d6479696e6721) {\n    return (Result<(),_std::io::error::Error>)0xb00000003;\n}\n// imready!\nif (local_38 == (Result<(),_std::io::error::Error>)0x696d726561647921) {\n    return (Result<(),_std::io::error::Error>)0x0;\n}\n```\n\nAs a guess, we'll likely use `imready!`, since we want to accept information.\n\nOnce `wait_until_ready` is done, the method `write_msg` is used in `main`. The same check for `imready!`/`imdying!` is\npresent multiple lines, including in a loop, so we'll likely need to continuously send these `imready!` messages between\nreceived data. Given the format that's been used already (bytes encoded as numbers), we'll just try using this approach\nfor decoding.\n\nTrying it out, we craft the following program:\n\n```rust\nuse std::fs::{read_to_string, write};\nuse std::io;\nuse std::io::{stdout, Write};\nuse std::str::FromStr;\n\nfn main() -> Result<(), io::Error> {\n    // write that we're a client\n    write(\n        \"/proc/self/timerslack_ns\",\n        u64::from_be_bytes(*b\"imclient\").to_string(),\n    )?;\n\n    loop {\n        let content = u64::from_str(&read_to_string(\"/proc/self/timerslack_ns\")?.trim()).unwrap();\n        // wait until we see a server\n        if content == u64::from_be_bytes(*b\"imserver\") {\n            println!(\"got a server!\");\n            break;\n        }\n    }\n\n    loop {\n        // say that we're ready for information\n        write(\n            \"/proc/self/timerslack_ns\",\n            u64::from_be_bytes(*b\"imready!\").to_string(),\n        )?;\n        loop {\n            let content =\n                u64::from_str(read_to_string(\"/proc/self/timerslack_ns\")?.trim()).unwrap();\n            if content != u64::from_be_bytes(*b\"imready!\") {\n                // write the information, raw, to the standard out\n                stdout().write_all(&content.to_be_bytes())?;\n                break;\n            }\n        }\n    }\n}\n\n```\n\nThen, to test, we execute `friend` with a fake `flag.txt` to make sure our solution works:\n\n```bash\nterm-1$ cargo run # execute our solution code\n... let this run ...\nterm-2$ cat flag.txt\nlmao_this_is_not_a_flag\nterm-2$ sudo ./friend\n$ sudo ./friend\nFound a server!: /proc/18025/timerslack_ns\n^C\n... meanwhile, in term-1 ...\ngot a server!\nlmao_this_is_not_a_flag\nlmao_this_is_not_a_flag\nlmao_this_is_not_a_flag\nlmao_this_is_not_a_flag\n```\n\nOkay! Now that we have a locally building solution, we compile this to be statically executed on the remote system (must\nbe static since there are no other files present in the remote):\n\n```bash\n$ cargo build --release --target x86_64-unknown-linux-musl\n```\n\nThen: we upload it!\n\n```bash\n$ (echo 'execute'; stat -c '%s' solution; cat solution) | nc 0.0.0.0 16983\nsize of file: Cowardly refusing to create a binary >4MB.\n```\n\nHm, maybe we can just strip it...\n\n```bash\n$ strip solution\n$ (echo 'execute'; stat -c '%s' solution; cat solution) | nc 0.0.0.0 16983\nsize of file: got a server!\ngigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}gigem{cut_me_some_slack000}^C\n```\n\nFlag: `gigem{cut_me_some_slack000}`",
    "friend\\Cargo.toml": "[package]\nname = \"friend\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nproto = { path = \"../proto\" }\n",
    "friend\\src\\main.rs": "use proto::Client;\nuse std::convert::Infallible;\nuse std::fs::read_to_string;\nuse std::io;\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn interact(mut client: Client) -> Result<Infallible, io::Error> {\n    loop {\n        client.wait_until_ready()?;\n        client.write_msg(read_to_string(\"flag.txt\")?.as_bytes())?;\n    }\n}\n\nfn main() -> Result<(), io::Error> {\n    loop {\n        if let Ok(Some(client)) = Client::find_server() {\n            println!(\"Found a server!: {}\", client.target());\n            let e = interact(client).unwrap_err();\n            println!(\"Lost our server ({e}), beginning search...\");\n        }\n        sleep(Duration::from_millis(500));\n    }\n}\n",
    "launcher\\Cargo.toml": "[package]\nname = \"launcher\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n",
    "launcher\\src\\main.rs": "use std::error::Error;\nuse std::process::{Command, Stdio};\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let mut server = Command::new(\"/server\")\n        .stdin(Stdio::null())\n        .stdout(Stdio::inherit())\n        .stderr(Stdio::inherit())\n        .spawn()?;\n    let mut friend = Command::new(\"/friend\")\n        .stdin(Stdio::null())\n        .stdout(Stdio::inherit())\n        .stderr(Stdio::inherit())\n        .spawn()?;\n\n    friend.wait()?;\n    server.wait()?;\n\n    Ok(())\n}\n",
    "proto\\Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"proto\"\nversion = \"0.1.0\"\n",
    "proto\\Cargo.toml": "[package]\nname = \"proto\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]",
    "proto\\src\\lib.rs": "use std::fs::{read_dir, read_to_string, write};\nuse std::io;\nuse std::io::ErrorKind;\nuse std::str::FromStr;\nuse std::thread::sleep;\nuse std::time::Duration;\n\nconst CLIENT_AUTH: u64 = u64::from_be_bytes(*b\"imclient\");\nconst CLIENT_DISCONNECT: u64 = u64::from_be_bytes(*b\"imdying!\");\nconst CLIENT_READY: u64 = u64::from_be_bytes(*b\"imready!\");\nconst SERVER_AUTH: u64 = u64::from_be_bytes(*b\"imserver\");\n\npub struct Client {\n    target: String,\n}\n\npub struct Server {\n    _hidden: (),\n}\n\nimpl Client {\n    pub fn find_server() -> Result<Option<Self>, io::Error> {\n        let mut pids = Vec::new();\n        for process in read_dir(\"/proc\")? {\n            let path = process?.path();\n            if let Some(pid) = path\n                .file_name()\n                .and_then(|filename| filename.to_str())\n                .and_then(|filename| u64::from_str(filename).ok())\n            {\n                pids.push(pid);\n            }\n        }\n        pids.sort_unstable();\n\n        for pid in pids {\n            let target = format!(\"/proc/{pid}/timerslack_ns\");\n            let mut this = Self { target };\n            if this\n                .try_read_chunk()\n                .map(|chunk| chunk == CLIENT_AUTH)\n                .unwrap_or(false)\n            {\n                write(&this.target, format!(\"{SERVER_AUTH}\"))?;\n                return Ok(Some(this));\n            }\n        }\n\n        Ok(None)\n    }\n\n    fn try_read_chunk(&mut self) -> Result<u64, io::Error> {\n        Ok(u64::from_str(read_to_string(&self.target)?.trim()).unwrap())\n    }\n\n    pub fn wait_until_ready(&mut self) -> Result<(), io::Error> {\n        loop {\n            let chunk = self.try_read_chunk()?;\n            match chunk {\n                CLIENT_READY => return Ok(()),\n                CLIENT_DISCONNECT => return Err(io::Error::from(ErrorKind::BrokenPipe)),\n                _ => sleep(Duration::from_millis(10)),\n            }\n        }\n    }\n\n    pub fn write_msg(&mut self, content: &[u8]) -> Result<(), io::Error> {\n        assert!(content.len() < u32::MAX as usize);\n\n        self.wait_until_ready()?;\n\n        write(&self.target, format!(\"{}\", content.len()))?;\n\n        let chunks = content.chunks_exact(core::mem::size_of::<u32>());\n\n        let remainder = chunks.remainder();\n\n        for chunk in chunks {\n            self.wait_until_ready()?;\n            let num =\n                u32::from_be_bytes(<[u8; core::mem::size_of::<u32>()]>::try_from(chunk).unwrap());\n            write(&self.target, format!(\"{num}\"))?;\n        }\n\n        if !remainder.is_empty() {\n            self.wait_until_ready()?;\n            let mut chunk = Vec::from(remainder);\n            chunk.resize(core::mem::size_of::<u32>(), 0);\n\n            let num =\n                u32::from_be_bytes(<[u8; core::mem::size_of::<u32>()]>::try_from(chunk).unwrap());\n            write(&self.target, format!(\"{num}\"))?;\n        }\n\n        Ok(())\n    }\n\n    pub fn target(&self) -> &str {\n        &self.target\n    }\n}\n\nimpl Server {\n    pub fn wait_for_connection() -> Result<Self, io::Error> {\n        write(\"/proc/self/timerslack_ns\", format!(\"{CLIENT_AUTH}\"))?;\n\n        loop {\n            if u64::from_str(read_to_string(\"/proc/self/timerslack_ns\")?.trim()).unwrap()\n                == SERVER_AUTH\n            {\n                break Ok(Self { _hidden: () });\n            }\n        }\n    }\n\n    fn next_server_chunk(&mut self) -> Result<u32, io::Error> {\n        write(\"/proc/self/timerslack_ns\", format!(\"{CLIENT_READY}\"))?;\n        loop {\n            let last = u64::from_str(read_to_string(\"/proc/self/timerslack_ns\")?.trim()).unwrap();\n            if last != CLIENT_READY {\n                break Ok(last as u32);\n            }\n        }\n    }\n\n    pub fn read_msg(&mut self) -> Result<Vec<u8>, io::Error> {\n        let size = self.next_server_chunk()? as usize;\n        let mut buf = Vec::with_capacity(size + 3);\n\n        while buf.len() < size {\n            buf.extend_from_slice(&self.next_server_chunk()?.to_be_bytes());\n        }\n\n        buf.truncate(size);\n\n        Ok(buf)\n    }\n}\n\nimpl Drop for Server {\n    fn drop(&mut self) {\n        write(\"/proc/self/timerslack_ns\", format!(\"{CLIENT_DISCONNECT}\")).unwrap();\n    }\n}\n",
    "server\\Cargo.toml": "[package]\nname = \"server\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nanyhow = \"1.0.68\"\nnix = \"0.26.2\"\ntokio = { version = \"1.24.2\", default-features = false, features = [\"fs\", \"io-util\", \"macros\", \"net\", \"rt\", \"process\"] }\n",
    "server\\src\\main.rs": "use anyhow::Result;\n\nuse nix::fcntl::{fcntl, FcntlArg, OFlag, SealFlag};\nuse nix::sys::memfd::{memfd_create, MemFdCreateFlag};\nuse nix::unistd::Uid;\nuse std::ffi::CString;\nuse std::fs::Permissions;\nuse std::net::SocketAddr;\nuse std::os::fd::{AsRawFd, FromRawFd};\nuse std::os::unix::fs::PermissionsExt;\nuse std::process::Stdio;\nuse tokio::fs::File;\nuse tokio::io::{copy, AsyncBufReadExt, AsyncReadExt, AsyncWriteExt, BufReader, BufWriter};\nuse tokio::net::{TcpListener, TcpStream};\nuse tokio::process::Command;\nuse tokio::{pin, select};\n\nasync fn handle_client(mut client: TcpStream, source: SocketAddr) -> Result<()> {\n    println!(\"Handling connection from: {source}\");\n\n    let stream_fd = client.as_raw_fd();\n\n    let (rx, tx) = client.split();\n    let mut rx = BufReader::new(rx);\n    let mut tx = BufWriter::new(tx);\n\n    while let Ok(Some(line)) = (&mut rx).lines().next_line().await {\n        let line = line.trim();\n        if line == \"execute\" {\n            tx.write_all(b\"size of file: \").await?;\n            tx.flush().await?;\n            if let Ok(Some(bytes)) = (&mut rx).lines().next_line().await {\n                if let Ok(bytes) = bytes.parse() {\n                    if bytes > 4 << 20 {\n                        tx.write_all(b\"Cowardly refusing to create a binary >4MB.\")\n                            .await?;\n                        tx.flush().await?;\n                        continue;\n                    }\n\n                    let memfd = memfd_create(\n                        CString::new(format!(\"{source}\"))?.as_c_str(),\n                        MemFdCreateFlag::MFD_CLOEXEC | MemFdCreateFlag::MFD_ALLOW_SEALING,\n                    )?;\n\n                    let file = unsafe { File::from_raw_fd(memfd) };\n                    let mut writer = BufWriter::new(file);\n                    copy(&mut (&mut rx).take(bytes), &mut writer).await?;\n                    let file = writer.into_inner();\n\n                    // prevent further writing\n                    file.set_permissions(Permissions::from_mode(0o555)).await?;\n                    fcntl(memfd, FcntlArg::F_ADD_SEALS(SealFlag::all()))?;\n\n                    let executable = format!(\"/proc/self/fd/{memfd}\");\n                    println!(\"Launching {executable} for {source}\");\n\n                    let fut_status = Command::new(executable)\n                        .stdin(unsafe { Stdio::from_raw_fd(stream_fd) })\n                        .stdout(unsafe { Stdio::from_raw_fd(stream_fd) })\n                        .stderr(unsafe { Stdio::from_raw_fd(stream_fd) })\n                        .env_clear()\n                        .uid(Uid::current().as_raw() + 1000)\n                        .kill_on_drop(true)\n                        .status();\n                    pin!(fut_status);\n\n                    let status = loop {\n                        // loop until the process ends or the stream is killed\n                        select! {\n                            status = &mut fut_status => break status?,\n                            readable = rx.get_mut().readable() => readable?,\n                        }\n                    };\n\n                    tx.write_all(\n                        format!(\"Execute complete; exited {:?}\\n\", status.code()).as_bytes(),\n                    )\n                    .await?;\n                    tx.flush().await?;\n                } else {\n                    tx.write_all(b\"Invalid length specified: \").await?;\n                    tx.write_all(bytes.as_bytes()).await?;\n                    tx.write_u8(b'\\n').await?;\n                    tx.flush().await?;\n                }\n            }\n        } else {\n            tx.write_all(b\"Didn't recognise command. Try again?\\n\")\n                .await?;\n            tx.flush().await?;\n        }\n    }\n\n    println!(\"Mischief managed for {source}!\");\n\n    Ok(())\n}\n\nasync fn run_server() -> Result<()> {\n    let server = TcpListener::bind(\"0.0.0.0:16983\").await?;\n    println!(\"{}\", server.local_addr()?);\n\n    while let Ok((conn, source)) = server.accept().await {\n        fcntl(conn.as_raw_fd(), FcntlArg::F_SETFL(OFlag::O_CLOEXEC))?;\n        tokio::spawn(async move {\n            if let Err(e) = handle_client(conn, source).await {\n                println!(\"Encountered error while handling {source}: {e}\");\n            }\n        });\n    }\n\n    Ok(())\n}\n\nfn main() -> Result<()> {\n    tokio::runtime::Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(run_server())\n}\n",
    "solution\\Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"solution\"\nversion = \"0.1.0\"\n",
    "solution\\Cargo.toml": "[workspace]\n\n[package]\nname = \"solution\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\n[profile.release]\nstrip = true\nlto = true\n",
    "solution\\submit.py": "from pwn import *\nfrom pathlib import Path\nfrom subprocess import run\n\nrun(\"cargo build --release\", shell=True)\nelf = Path(\"target/x86_64-unknown-linux-musl/release/solution\").read_bytes()\n\np = remote(\"localhost\", 16983)\np.sendline(b\"execute\")\np.sendline(str(len(elf)).encode())\np.send(elf)\np.recvline()\nflag = p.recvuntil(b\"}\")\nprint(\"\".join(chr(x) for x in flag if 32 <= x <= 127))\n",
    "solution\\.cargo\\config.toml": "[build]\ntarget = \"x86_64-unknown-linux-musl\"\n",
    "solution\\src\\main.rs": "use std::fs::{read_to_string, write};\nuse std::io;\nuse std::io::{stdout, Write};\nuse std::str::FromStr;\n\nfn main() -> Result<(), io::Error> {\n    write(\n        \"/proc/self/timerslack_ns\",\n        u64::from_be_bytes(*b\"imclient\").to_string(),\n    )?;\n\n    loop {\n        let content = u64::from_str(&read_to_string(\"/proc/self/timerslack_ns\")?.trim()).unwrap();\n        if content == u64::from_be_bytes(*b\"imserver\") {\n            println!(\"got a server!\");\n            break;\n        }\n    }\n\n    loop {\n        write(\n            \"/proc/self/timerslack_ns\",\n            u64::from_be_bytes(*b\"imready!\").to_string(),\n        )?;\n        loop {\n            let content =\n                u64::from_str(read_to_string(\"/proc/self/timerslack_ns\")?.trim()).unwrap();\n            if content != u64::from_be_bytes(*b\"imready!\") {\n                stdout().write_all(&content.to_be_bytes())?;\n                break;\n            }\n        }\n    }\n}\n",
    "category": "rev"
}