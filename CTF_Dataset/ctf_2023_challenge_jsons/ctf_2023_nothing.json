{
    "Dockerfile": "FROM debian:buster-slim\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD nothing.c /nothing.c\nADD Makefile /Makefile\nRUN make all\n",
    "Makefile": "NAME := nothing\n\nall: $(NAME).c\n\tgcc $(NAME).c -s -o $(NAME)\n\tstrip $(NAME)\n\ndist: Dockerfile\n\tdocker build -t $(NAME) .\n\tdocker run -d --name $(NAME) $(NAME)\n\tdocker cp $(NAME):/$(NAME) ./$(NAME)\n\nclean:\n\trm $(NAME)\n\tdocker rm -f $(NAME)\n\tdocker rmi $(NAME)\n",
    "nothing": "[Binary file or unsupported type: c:\\users\\jomue\\tamuctf-2023-master\\tamuctf-2023-master\\rev\\nothing\\nothing]",
    "nothing.c": "#include <stdio.h>\n#include <string.h>\n\nchar* fun(char* p_addr) {\n    puts(\"also not here\");\n    return p_addr + 0x400000;\n}\n\nint main(int argc, char* argv[]) {\n    puts(\"not here\");\n\n    char* addr = fun(((char*)&&rethere) - 0x400000);\n    asm volatile(\n        \"push %0\\n\"\n        \"ret\"\n    :\n    : \"g\"(addr)\n    );\n\n    rethere:\n    if (argc != 2) {\n        return -1;\n    }\n\n    char check[] = \"ghefi~nbqVsdyRh`e\\x7fvL`}sHhku|n|sb\";\n    char message[] = {'g', 'o', 'o', 'd', '\\x00'};\n    for (size_t i = 0; i < strlen(argv[1]); i++) {\n        argv[1][i] ^= i;\n    }\n\n    if (strcmp(argv[1], check) == 0) {\n        puts(message);\n    }\n\n    return 0;\n\n}\n",
    "README.md": "# nothing\n\nAuthor: `anomie`\n\nThis program seems to be taunting me, I'm sure there's something here...\n\n## Dev notes\nOnly given file is the binary `nothing`.\n\n## Solution\nOpening the binary in Ghidra initially reveals nothing about the flag-checking logic. However, upon closer inspection, there is a sneaky `push` before a `ret` that prevents Ghidra from disassembling a certain section of code. Here's what it looks like:\n```c\nundefined8 UndefinedFunction_001011ab(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  long unaff_RBP;\n  \n  if (*(int *)(unaff_RBP + -0x54) == 2) {\n    *(undefined8 *)(unaff_RBP + -0x40) = 0x626e7e6966656867;\n    *(undefined8 *)(unaff_RBP + -0x38) = 0x6068527964735671;\n    *(undefined8 *)(unaff_RBP + -0x30) = 0x48737d604c767f65;\n    *(undefined8 *)(unaff_RBP + -0x28) = 0x62737c6e7c756b68;\n    *(undefined *)(unaff_RBP + -0x20) = 0;\n    *(undefined *)(unaff_RBP + -0x45) = 0x67;\n    *(undefined *)(unaff_RBP + -0x44) = 0x6f;\n    *(undefined *)(unaff_RBP + -0x43) = 0x6f;\n    *(undefined *)(unaff_RBP + -0x42) = 100;\n    *(undefined *)(unaff_RBP + -0x41) = 0;\n    *(undefined8 *)(unaff_RBP + -8) = 0;\n    while( true ) {\n      sVar3 = strlen(*(char **)(*(long *)(unaff_RBP + -0x60) + 8));\n      if (sVar3 <= *(ulong *)(unaff_RBP + -8)) break;\n      *(byte *)(*(long *)(unaff_RBP + -8) + *(long *)(*(long *)(unaff_RBP + -0x60) + 8)) =\n           *(byte *)(*(long *)(unaff_RBP + -8) + *(long *)(*(long *)(unaff_RBP + -0x60) + 8)) ^\n           (byte)*(undefined8 *)(unaff_RBP + -8);\n      *(long *)(unaff_RBP + -8) = *(long *)(unaff_RBP + -8) + 1;\n    }\n    iVar1 = strcmp(*(char **)(*(long *)(unaff_RBP + -0x60) + 8),(char *)(unaff_RBP + -0x40));\n    if (iVar1 == 0) {\n      puts((char *)(unaff_RBP + -0x45));\n    }\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 0xffffffff;\n  }\n  return uVar2;\n}\n```\nIf we squint hard enough and look past the crazy type-casting, we can see that a 32-byte key is loaded on the stack in 4 immediates. The user input is read from `argv[1]` and xor'd with a loop index. If the xor'd input matches the key (i.e. `strcmp` determines the inputs are equal), then we know we have the flag. I extracted the key and xor'd it with a counter in Python to get the flag:\n\n```python\nkey = b\"\\x67\\x68\\x65\\x66\\x69\\x7e\\x6e\\x62\\x71\\x56\\x73\\x64\\x79\\x52\\x68\\x60\\x65\\x7f\\x76\\x4c\\x60\\x7d\\x73\\x48\\x68\\x6b\\x75\\x7c\\x6e\\x7c\\x73\\x62\"\nprint(\"\".join(chr(i ^ b) for i, b in enumerate(key)))\n```\n\nFlag: `gigem{hey_you_found_the_program}`\n",
    "category": "rev"
}