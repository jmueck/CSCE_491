{
    "Dockerfile": "FROM python:slim-buster\n\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\n\nCOPY flag.txt /crypto/flag.txt\nCOPY server.py /crypto/server.py\nRUN chmod +x /crypto/server.py\nRUN python3 -m pip install pycryptodome\nWORKDIR /crypto\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:\\\"python3 /crypto/server.py\\\",stderr\" > /crypto/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/crypto/docker_entrypoint.sh\"]\n\n",
    "flag.txt": "gigem{h4h4_numb3rs_ar3_s0_qu1rky}\n",
    "Makefile": "NAME := numbers-pensive\nPORT := 7770\n\ndocker: Dockerfile\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nclean:\n\tdocker kill $(NAME) && docker rm $(NAME) && docker rmi $(NAME)\n\ndist:\n\tzip $(NAME).zip server.py\n",
    "README.md": "# Numbers :pensive:\n\nAuthor: `nhwn`\n\nIt wouldn't be a real CTF without some contrived RSA challenge, right?\n\n## Solution\nHow to find phi?\nAcquire i samples of `(e_i, d_i)`.\nLet `x_i = d_i * e_i`. Then for all `x_i`, `x_i = 1 (mod phi)` iff `x - 1 = phi * k` for some integer `k`.\n\nWe can (sometimes) determine phi because the gcd of all the `x_i - 1` should be phi, given enough samples.\n\nSolve given in `solve.py`, though I don't think it is robust and may fail a few times.\n\nFlag: `gigem{h4h4_numb3rs_ar3_s0_qu1rky}`\n",
    "server.py": "from Crypto.Util.number import getPrime\nfrom Crypto.Random.random import getrandbits, randint\nfrom pathlib import Path\nfrom math import gcd\n\nflag = Path(\"flag.txt\").read_text()\n\ne = 65537\n\nwhile True:\n    p = getPrime(1024)\n    q = getPrime(1024)\n    n = p * q\n    phi = (p - 1) * (q - 1)\n    if gcd(e, phi) == 1:\n        break\n\nprint(f\"n = {n}\")\nprint(f\"e = {e}\")\n\nwhile True:\n    chosen_e = int(input(\"Give me an `e`, and I'll give you a `d`: \"))\n    if chosen_e == e:\n        print(\"Nice try!\")\n        break\n    try:\n        print(pow(chosen_e, -1, phi))\n    except:\n        print(\"That's not invertible :pensive:\")\n        continue\n    m = getrandbits(1024)\n    c = pow(m, e, n)\n    print(\"If you can decrypt this, I'll give you a flag!\")\n    print(c)\n    ans = int(input(\"Your answer: \"))\n    if ans == m:\n        print(flag)\n        break\n    else:\n        print(\"Numbers, am I right :pensive:\")\n\n",
    "solve.py": "from pwn import *\nfrom math import gcd\n\ndef main():\n    r = remote('localhost', 7770)\n    n = int(r.recvline().split()[-1])\n    e = int(r.recvline().split()[-1])\n    \n    r.sendline(b'11')\n    d_1 = int(r.recvline().split()[-1])\n    r.sendline(b'1')\n    r.recvuntil(b'ive:\\n')\n\n    r.sendline(b'17')\n    d_2 = int(r.recvline().split()[-1])\n\n    phi = gcd((11*d_1) - 1, (17*d_2) - 1)\n    assert phi != 1\n\n    d = pow(e, -1, phi)\n    r.recvline()\n    c = int(r.recvline())\n    r.sendline(str(pow(c,d,n)))\n    r.interactive()\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "category": "crypto"
}