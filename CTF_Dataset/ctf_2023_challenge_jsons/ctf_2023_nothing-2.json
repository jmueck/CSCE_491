{
    "Dockerfile": "FROM debian:buster-slim\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD nothing-2.c /nothing-2.c\nADD Makefile /Makefile\nRUN make all\n\n",
    "Makefile": "NAME := nothing-2\n\nall: $(NAME).c\n\tgcc $(NAME).c -s -o $(NAME)\n\tstrip $(NAME)\n\ndist: Dockerfile\n\tdocker build -t $(NAME) .\n\tdocker run -d --name $(NAME) $(NAME)\n\tdocker cp $(NAME):/$(NAME) ./$(NAME)\n\tzip $(NAME).zip $(NAME)\n\nclean:\n\trm -f $(NAME).zip $(NAME)\n\tdocker rm -f $(NAME)\n\tdocker rmi $(NAME)\n",
    "nothing-2.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nconst char charset[] = \"abcdefghijklmnopqrstuvwxyz1234567890{}_\";\nconst char sbox[] = \"4piq9zovafg8{1hkcm7std03xle}ry6w_ujn52b\";\nconst size_t charset_len = strlen(charset);\n\nvoid* foo (void* addr) {\n    return addr + 0x400000;\n}\n\nvoid __attribute__((constructor)) before_main (int argc, char* argv[]) {\n    void* addr = foo(((void*)&&rethere) - 0x400000);\n    asm volatile(\n        \"push %0\\n\"\n        \"ret\\n\"\n    :\n    : \"g\"(addr)\n    );\nrethere:\n\n    if (argc != 2)\n        return;\n\n    char check[] = {'o', 'a', 'o', '9', '{', '5', 'i', 'n', '1', '7', 's', 'm', 't', 'i', 's', 'n', 'm', '6', 'b', 'm', 't', '1', 'b', 'p', 'r', 'z', 'n', 'm', 'r', 'b', '{', 'y', 'e', '1', '2'};\n    size_t check_len = strlen(check);\n    size_t inp_len = strlen(argv[1]);\n\n    if (check_len != inp_len)\n        return;\n\n    for (size_t i = 0; i < inp_len; i++) {\n        size_t index = (size_t)(strchr(charset, argv[1][i]) - charset);\n        if (index >= charset_len)\n            return;\n\n        if (sbox[index] != check[i])\n            return;\n    }\n\n    char win_message[] = {'c', 'o', 'r', 'r', 'e', 'c', 't', ' ', 'f', 'l', 'a', 'g', '!', '\\0'};\n    puts(win_message);\n}\n\nvoid main () {\n    puts(\"this is main\");\n}\n",
    "README.md": "# nothing 2\n\nAuthor: `anomie`\n\nAnother funny obfuscation technique.\n\n## Dev notes\nOnly given file is the binary `nothing-2`.\n\n## Solution\nWe can start by opening the binary in Ghidra (spoilers, the decompilation is mostly unhelpful). Since the binary is stripped, we can look at the entry point and check the first argument to `__libc_start_main()` to look at `main()`:\n```c\nvoid FUN_0010132b(void)\n{\n  puts(\"this is main\");\n  return;\n}\n```\nObviously, there's more to this binary than whatever's in the decompilation, so we can switch to looking at the assembly. After scrolling a bit in the output of `objdump`, I found this interesting snippet:\n```x86asm\n118f:\t83 7d 9c 02          \tcmp    DWORD PTR [rbp-0x64],0x2\n1193:\t0f 85 86 01 00 00    \tjne    131f <__cxa_finalize@plt+0x2bf>\n1199:\tc6 45 b0 6f          \tmov    BYTE PTR [rbp-0x50],0x6f\n119d:\tc6 45 b1 61          \tmov    BYTE PTR [rbp-0x4f],0x61\n11a1:\tc6 45 b2 6f          \tmov    BYTE PTR [rbp-0x4e],0x6f\n...\n```\nThe immediates are ASCII characters, so I decided to force Ghidra to decompile this section (right-click the first instruction and select \"Create Function\"), and lo and behold, a _very_ sus function magically appeared:\n```c\nvoid sus(void)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  long unaff_RBP;\n  \n  if (*(int *)(unaff_RBP + -100) == 2) {\n    *(undefined *)(unaff_RBP + -0x50) = 'o';\n    *(undefined *)(unaff_RBP + -0x4f) = 'a';\n    *(undefined *)(unaff_RBP + -0x4e) = 'o';\n    *(undefined *)(unaff_RBP + -0x4d) = '9';\n    *(undefined *)(unaff_RBP + -0x4c) = '{';\n    *(undefined *)(unaff_RBP + -0x4b) = '5';\n    *(undefined *)(unaff_RBP + -0x4a) = 'i';\n    *(undefined *)(unaff_RBP + -0x49) = 'n';\n    *(undefined *)(unaff_RBP + -0x48) = '1';\n    *(undefined *)(unaff_RBP + -0x47) = '7';\n    *(undefined *)(unaff_RBP + -0x46) = 's';\n    *(undefined *)(unaff_RBP + -0x45) = 'm';\n    *(undefined *)(unaff_RBP + -0x44) = 't';\n    *(undefined *)(unaff_RBP + -0x43) = 'i';\n    *(undefined *)(unaff_RBP + -0x42) = 's';\n    *(undefined *)(unaff_RBP + -0x41) = 'n';\n    *(undefined *)(unaff_RBP + -0x40) = 'm';\n    *(undefined *)(unaff_RBP + -0x3f) = '6';\n    *(undefined *)(unaff_RBP + -0x3e) = 'b';\n    *(undefined *)(unaff_RBP + -0x3d) = 'm';\n    *(undefined *)(unaff_RBP + -0x3c) = 't';\n    *(undefined *)(unaff_RBP + -0x3b) = '1';\n    *(undefined *)(unaff_RBP + -0x3a) = 'b';\n    *(undefined *)(unaff_RBP + -0x39) = 'p';\n    *(undefined *)(unaff_RBP + -0x38) = 'r';\n    *(undefined *)(unaff_RBP + -0x37) = 'z';\n    *(undefined *)(unaff_RBP + -0x36) = 'n';\n    *(undefined *)(unaff_RBP + -0x35) = 'm';\n    *(undefined *)(unaff_RBP + -0x34) = 'r';\n    *(undefined *)(unaff_RBP + -0x33) = 'b';\n    *(undefined *)(unaff_RBP + -0x32) = '{';\n    *(undefined *)(unaff_RBP + -0x31) = 'y';\n    *(undefined *)(unaff_RBP + -0x30) = 'e';\n    *(undefined *)(unaff_RBP + -0x2f) = '1';\n    *(undefined *)(unaff_RBP + -0x2e) = '2';\n    sVar1 = strlen((char *)(unaff_RBP + -0x50));\n    *(size_t *)(unaff_RBP + -0x18) = sVar1;\n    sVar1 = strlen(*(char **)(*(long *)(unaff_RBP + -0x70) + 8));\n    *(size_t *)(unaff_RBP + -0x20) = sVar1;\n    if (*(long *)(unaff_RBP + -0x18) == *(long *)(unaff_RBP + -0x20)) {\n      *(undefined8 *)(unaff_RBP + -8) = 0;\n      while (*(ulong *)(unaff_RBP + -8) < *(ulong *)(unaff_RBP + -0x20)) {\n        pcVar2 = strchr(\"abcdefghijklmnopqrstuvwxyz1234567890{}_\",\n                        (int)*(char *)(*(long *)(unaff_RBP + -8) +\n                                      *(long *)(*(long *)(unaff_RBP + -0x70) + 8)));\n        *(char **)(unaff_RBP + -0x28) = pcVar2 + -0x102020;\n        if (0x26 < *(ulong *)(unaff_RBP + -0x28)) {\n          return;\n        }\n        if (\"4piq9zovafg8{1hkcm7std03xle}ry6w_ujn52b\"[*(long *)(unaff_RBP + -0x28)] !=\n            *(char *)(*(long *)(unaff_RBP + -8) + unaff_RBP + -0x50)) {\n          return;\n        }\n        *(long *)(unaff_RBP + -8) = *(long *)(unaff_RBP + -8) + 1;\n      }\n      *(undefined *)(unaff_RBP + -0x5d) = 'c';\n      *(undefined *)(unaff_RBP + -0x5c) = 'o';\n      *(undefined *)(unaff_RBP + -0x5b) = 'r';\n      *(undefined *)(unaff_RBP + -0x5a) = 'r';\n      *(undefined *)(unaff_RBP + -0x59) = 'e';\n      *(undefined *)(unaff_RBP + -0x58) = 'c';\n      *(undefined *)(unaff_RBP + -0x57) = 't';\n      *(undefined *)(unaff_RBP + -0x56) = ' ';\n      *(undefined *)(unaff_RBP + -0x55) = 'f';\n      *(undefined *)(unaff_RBP + -0x54) = 'l';\n      *(undefined *)(unaff_RBP + -0x53) = 'a';\n      *(undefined *)(unaff_RBP + -0x52) = 'g';\n      *(undefined *)(unaff_RBP + -0x51) = '!';\n      *(undefined *)(unaff_RBP + -0x50) = 0;\n      puts((char *)(unaff_RBP + -0x5d));\n    }\n  }\n  return;\n}\n```\nAfter finding this, it was relatively straightforward to reverse. One annoying thing was that all of the variables were expressed as offsets relative to `unaff_RBP`, so I couldn't just rename them in Ghidra. As a result, I just copied the decompilation outside of Ghidra and started manually trimming it down.\n\nThe code essentially does something like this:\n```c\nchar* fixed = \"oao9{5in17smtisnm6bmt1bprznmrb{ye12\";\nsize_t fixed_len = strlen(fixed);\nchar* input = *(long *)(unaff_RBP + -0x70) + 8;\nsize_t input_len = strlen(input);\nif (fixed_len == input_len) {\n    for (size_t i = 0; i < input_len; ++i) {\n        char* alphabet = \"abcdefghijklmnopqrstuvwxyz1234567890{}_\";\n        size_t offset = strchr(alphabet, input[i]) - alphabet;\n        if (invalid offset) {\n            return;\n        }\n        if (\"4piq9zovafg8{1hkcm7std03xle}ry6w_ujn52b\"[offset] != fixed[i]) {\n            return;\n        }\n    }\n    puts(\"correct flag!\");\n}\n\n```\nTo actually get the flag, I wrote a short Python script to brute force the input because I was tired:\n```python\nfixed = \"oao9{5in17smtisnm6bmt1bprznmrb{ye12\"\nfixed2 = \"4piq9zovafg8{1hkcm7std03xle}ry6w_ujn52b\"\nalphabet = \"abcdefghijklmnopqrstuvwxyz1234567890{}_\"\nflag = \"\"\nfor f in fixed:\n    for j, a in enumerate(alphabet):\n        if f == fixed2[j]:\n            flag += a\n            break\nprint(flag)\n```\n\nFlag: `gigem{c0nstruct0r5_run_b3f0r3_m41n}`\n\n",
    "category": "rev"
}