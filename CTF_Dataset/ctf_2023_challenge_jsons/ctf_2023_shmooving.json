{
    "Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"getrandom\"\nversion = \"0.2.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4eb1a864a501629691edf6c15a593b7a51eebaa1e8468e9ddc623de7c9b58ec6\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"wasi\",\n]\n\n[[package]]\nname = \"hex\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70\"\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.132\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8371e4e5341c3a96db127eb2465ac681ced4c433e01dd0e938adbef26ba93ba5\"\n\n[[package]]\nname = \"ppv-lite86\"\nversion = \"0.2.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"eb9f9e6e233e5c4a35559a617bf40a4ec447db2e84c20b55a6f83167b7e57872\"\n\n[[package]]\nname = \"rand\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404\"\ndependencies = [\n \"libc\",\n \"rand_chacha\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_chacha\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88\"\ndependencies = [\n \"ppv-lite86\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_core\"\nversion = \"0.6.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d34f1408f55294453790c48b2f1ebbb1c5b4b7563eb1f418bcfcfdbb06ebb4e7\"\ndependencies = [\n \"getrandom\",\n]\n\n[[package]]\nname = \"shmooving\"\nversion = \"0.1.0\"\ndependencies = [\n \"hex\",\n \"rand\",\n]\n\n[[package]]\nname = \"wasi\"\nversion = \"0.11.0+wasi-snapshot-preview1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n",
    "Cargo.toml": "[package]\nname = \"shmooving\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nhex = \"0.4.3\"\nrand = \"0.8.5\"\n",
    "Dockerfile": "FROM rust as build\n\nADD src /build/src\nADD Cargo.toml /build/Cargo.toml\n\nWORKDIR /build\n\nRUN cargo build --release\n\nFROM debian:buster-slim\n\nARG port\nARG name\n\nRUN apt update; apt -y install socat\nCOPY --from=build /build/target/release/$name /crypto/$name\nADD flag.txt flag.txt\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/crypto/$name,stderr\" > /crypto/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/crypto/docker_entrypoint.sh\"]\n",
    "flag.txt": "gigem{please_no_more_aes_challs}",
    "Makefile": "NAME := shmooving\nPORT := 7773\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nclean: .PHONY\n\tdocker container rm -f $(NAME)\n\trm -f $(NAME)\n\ndocker: Dockerfile ./src/main.rs\n\ttouch flag.txt\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/crypto/$(NAME) $(NAME)\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip -r $(NAME).zip $(NAME) $(NAME) Cargo.toml Dockerfile Makefile src\n.PHONY:\n\n",
    "README.md": "# Shmooving\n\nAuthor: `nhwn`\n\nI discovered a new optimization for my AES-128 implementation that makes it blazingly fast. I'll even let you test it out yourself!\n\n## Solution\nWhen `mix_columns()` is removed from AES, it removes any sort of diffusion between the ciphertext and the plaintext. This means that changing only 1 byte in the plaintext will result in a single byte changed of the ciphertext (though the location of the byte will be different than that of the plaintext). \n\nFortunately, we can encrypt a block of every character since we are given the chance to encrypt a large message and see its output (and we know the possible input characters). From there, since we know the corresponding input, we can see which byte of the challenge ciphertext corresponds to a byte in the same location of a block in our encrypted ciphertext. When we find a match, we know the corresponding plaintext since the block was a single character. \n\nRepeat this for all bytes of the ciphertext to decrypt the challenge and get the flag! (Though we have to make sure to descramble the byte order as the final permutation of bytes isn't in the same order as the plaintext)\n\nflag: `gigem{please_no_more_aes_challs}`\n",
    "solve.py": "from pwn import *\nimport binascii\n\nHOST = 'localhost'\nPORT = 7773\n\ncharacters = string.ascii_letters + string.digits\n# array for knowning where to unshift all the bytes after the operations\nunshift = [0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 5, 14, 7]\n\nr = remote(HOST, PORT)\n\nr.recvuntil(b'flag:\\n')\nctxt = r.recvline().decode().strip()\nprint(\"Here's the challenge to decrypt: %s\" % ctxt)\n\n# create blocks of each alphanumeric character to encrypt\nptxt = \"\"\nfor letter in characters:\n\tptxt += letter * 16 \nptxt = binascii.hexlify(ptxt.encode())\n\n# send the plaintext and receive the encrypted version\nr.recvuntil(b'hex:')\nr.sendline(ptxt)\nr.recvuntil(b'blocks:\\n')\nenc = r.recvline().decode().strip()\n\ndecrypted = [''] * 16\nresponse = \"\"\nfor i in range(len(ctxt) // 2):\n\tbyte_c = ctxt[2 * i : 2 * (i+1)]\n\n\tif i == 16:\n\t\tresponse = \"\".join(decrypted)\n\t\t\n\tchar_ind = i % 16\n\t\n\t# iterate through all letters and check to find the matching one\n\tfor j in range(len(characters)):\n\t\tindex = 32 * j + 2 * char_ind\n\t\tbyte_e = enc[index : index + 2]\n\n\t\t# if we have a match add the character to the right spot\n\t\tif byte_e == byte_c:\n\t\t\tdecrypted[unshift[char_ind]] = characters[j]\n\nresponse += \"\".join(decrypted)\nprint(\"Decrypted version: %s\" % response)\nr.recvuntil(b'answer?')\nr.sendline(response.encode())\nr.recvuntil(b'flag:\\n')\nflag = r.recvline().decode().strip()\n\nr.close()\n\nprint(\"The flag is: %s\" % flag)\n",
    "src\\main.rs": "use rand::distributions::{Alphanumeric, DistString};\nuse rand::Rng;\nuse std::error::Error;\n\nstatic SBOX: [u8; 256] = [\n    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,\n];\nstatic RCON: [u8; 11] = [\n    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,\n];\n\nfn xtime(x: u8) -> u8 {\n    (x << 1) ^ (((x >> 7) & 1) * 0x1b)\n}\nfn add_round_key(s: &mut [u8; 16], key: &[u8; 16]) {\n    s.iter_mut().zip(key.iter()).for_each(|(s, k)| *s ^= k);\n}\nfn sub_bytes(s: &mut [u8; 16]) {\n    s.iter_mut().for_each(|s| *s = SBOX[*s as usize]);\n}\nfn mix_columns(s: &mut [u8; 16]) {\n    for s in s.chunks_exact_mut(4) {\n        let t = s[0] ^ s[1] ^ s[2] ^ s[3];\n        let old_s0 = s[0];\n        s[0] ^= t ^ xtime(s[0] ^ s[1]);\n        s[1] ^= t ^ xtime(s[1] ^ s[2]);\n        s[2] ^= t ^ xtime(s[2] ^ s[3]);\n        s[3] ^= t ^ xtime(s[3] ^ old_s0);\n    }\n}\nfn shift_rows(s: &mut [u8; 16]) {\n    for col in 0..4 {\n        let (i0, i1, i2, i3) = (col, col + 4, col + 8, col + 12);\n        for _ in 0..col {\n            let t = s[i0];\n            s[i0] = s[i1];\n            s[i1] = s[i2];\n            s[i2] = s[i3];\n            s[i3] = t;\n        }\n    }\n}\npub struct Aes128 {\n    schedule: [[u8; 16]; 11],\n}\n\nimpl Aes128 {\n    pub fn new(key: &[u8; 16]) -> Self {\n        let mut schedule = [[0u8; 16]; 11];\n\n        schedule[0] = *key;\n\n        // SAFETY: imagine checking invariants\n        let w = unsafe { &mut *schedule.as_mut_ptr().cast::<[[u8; 4]; 44]>() };\n\n        for i in 4..44 {\n            let mut temp = w[i - 1];\n            if i % 4 == 0 {\n                temp.rotate_left(1);\n                temp.iter_mut().for_each(|x| *x = SBOX[*x as usize]);\n                temp[0] ^= RCON[i / 4];\n            }\n            temp.iter_mut()\n                .zip(w[i - 4].iter())\n                .for_each(|(t, w)| *t ^= *w);\n            w[i] = temp;\n        }\n\n        Self { schedule }\n    }\n    fn blocks(blocks: &mut [u8]) -> impl Iterator<Item = &mut [u8; 16]> + '_ {\n        assert_eq!(blocks.len() % 16, 0);\n        blocks\n            .chunks_exact_mut(16)\n            .map(|block| block.try_into().unwrap())\n    }\n    pub fn encrypt(&self, plaintext: &mut [u8]) {\n        for block in Self::blocks(plaintext) {\n            add_round_key(block, &self.schedule[0]);\n            for key in &self.schedule[1..10] {\n                sub_bytes(block);\n                shift_rows(block);\n                // I never liked columns anyway\n                // mix_columns(block);\n                add_round_key(block, key);\n            }\n            sub_bytes(block);\n            shift_rows(block);\n            add_round_key(block, &self.schedule[10]);\n        }\n    }\n}\n\ntype Result<T> = std::result::Result<T, Box<dyn Error>>;\n\nfn get_line() -> Result<String> {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input)?;\n    input.pop();\n    Ok(input)\n}\n\nfn main() -> Result<()> {\n    let mut rng = rand::thread_rng();\n    let cipher = Aes128::new(&rng.gen());\n    let chall = Alphanumeric.sample_string(&mut rng, 32);\n    let mut ciphertext = chall.clone().into_bytes();\n    cipher.encrypt(&mut ciphertext);\n\n    println!(\"Decrypt this for a flag:\\n{}\", hex::encode(&ciphertext));\n\n    println!(\"I'll also encrypt whatever you want. Enter your blocks in hex:\");\n    let mut blocks = hex::decode(get_line()?)?;\n    if blocks.len() > 2048 || blocks.len() % 16 != 0 {\n        return Err(\"bad length\".into());\n    }\n    cipher.encrypt(&mut blocks);\n    println!(\"Here are your encrypted blocks:\\n{}\", hex::encode(&blocks));\n\n    println!(\"What's your answer?\");\n    if get_line()? == chall {\n        let flag = std::fs::read_to_string(\"flag.txt\")?;\n        println!(\"Nice work! Here's the flag:\\n{flag}\");\n    } else {\n        println!(\"That's not the right answer D:\");\n    }\n    Ok(())\n}\n",
    "category": "crypto"
}