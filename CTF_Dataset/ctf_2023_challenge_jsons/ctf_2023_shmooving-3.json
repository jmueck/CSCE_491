{
    "aes.py": "#!/usr/bin/env python3\n\"\"\"\nThis is an exercise in secure symmetric-key encryption, implemented in pure\nPython (no external libraries needed).\n\nOriginal AES-128 implementation by Bo Zhu (http://about.bozhu.me) at \nhttps://github.com/bozhu/AES-Python . PKCS#7 padding, CBC mode, PKBDF2, HMAC,\nbyte array and string support added by me at https://github.com/boppreh/aes. \nOther block modes contributed by @righthandabacus.\n\n\nAlthough this is an exercise, the `encrypt` and `decrypt` functions should\nprovide reasonable security to encrypted messages.\n\"\"\"\n\n\ns_box = (\n    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,\n)\n\ninv_s_box = (\n    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,\n)\n\n\ndef sub_bytes(s):\n    for i in range(4):\n        for j in range(4):\n            s[i][j] = s_box[s[i][j]]\n\n\ndef inv_sub_bytes(s):\n    for i in range(4):\n        for j in range(4):\n            s[i][j] = inv_s_box[s[i][j]]\n\n\ndef shift_rows(s):\n    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]\n    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]\n    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]\n\n\ndef inv_shift_rows(s):\n    s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1]\n    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]\n    s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3]\n\ndef add_round_key(s, k):\n    for i in range(4):\n        for j in range(4):\n            s[i][j] ^= k[i][j]\n\n\n# learned from https://web.archive.org/web/20100626212235/http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c\nxtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)\n\n\ndef mix_single_column(a):\n    # see Sec 4.1.2 in The Design of Rijndael\n    t = a[0] ^ a[1] ^ a[2] ^ a[3]\n    u = a[0]\n    a[0] ^= t ^ xtime(a[0] ^ a[1])\n    a[1] ^= t ^ xtime(a[1] ^ a[2])\n    a[2] ^= t ^ xtime(a[2] ^ a[3])\n    a[3] ^= t ^ xtime(a[3] ^ u)\n\n\ndef mix_columns(s):\n    for i in range(4):\n        mix_single_column(s[i])\n\n\ndef inv_mix_columns(s):\n    # see Sec 4.1.3 in The Design of Rijndael\n    for i in range(4):\n        u = xtime(xtime(s[i][0] ^ s[i][2]))\n        v = xtime(xtime(s[i][1] ^ s[i][3]))\n        s[i][0] ^= u\n        s[i][1] ^= v\n        s[i][2] ^= u\n        s[i][3] ^= v\n\n    mix_columns(s)\n\n\nr_con = (\n    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,\n    0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,\n    0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,\n    0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,\n)\n\n\ndef bytes2matrix(text):\n    \"\"\" Converts a 16-byte array into a 4x4 matrix.  \"\"\"\n    return [list(text[i:i+4]) for i in range(0, len(text), 4)]\n\ndef matrix2bytes(matrix):\n    \"\"\" Converts a 4x4 matrix into a 16-byte array.  \"\"\"\n    return bytes(sum(matrix, []))\n\ndef xor_bytes(a, b):\n    \"\"\" Returns a new byte array with the elements xor'ed. \"\"\"\n    return bytes(i^j for i, j in zip(a, b))\n\ndef inc_bytes(a):\n    \"\"\" Returns a new byte array with the value increment by 1 \"\"\"\n    out = list(a)\n    for i in reversed(range(len(out))):\n        if out[i] == 0xFF:\n            out[i] = 0\n        else:\n            out[i] += 1\n            break\n    return bytes(out)\n\ndef pad(plaintext):\n    \"\"\"\n    Pads the given plaintext with PKCS#7 padding to a multiple of 16 bytes.\n    Note that if the plaintext size is a multiple of 16,\n    a whole block will be added.\n    \"\"\"\n    padding_len = 16 - (len(plaintext) % 16)\n    padding = bytes([padding_len] * padding_len)\n    return plaintext + padding\n\ndef unpad(plaintext):\n    \"\"\"\n    Removes a PKCS#7 padding, returning the unpadded text and ensuring the\n    padding was correct.\n    \"\"\"\n    padding_len = plaintext[-1]\n    assert padding_len > 0\n    message, padding = plaintext[:-padding_len], plaintext[-padding_len:]\n    assert all(p == padding_len for p in padding)\n    return message\n\ndef split_blocks(message, block_size=16, require_padding=True):\n        assert len(message) % block_size == 0 or not require_padding\n        return [message[i:i+16] for i in range(0, len(message), block_size)]\n\n\nclass AES:\n    \"\"\"\n    Class for AES-128 encryption with CBC mode and PKCS#7.\n\n    This is a raw implementation of AES, without key stretching or IV\n    management. Unless you need that, please use `encrypt` and `decrypt`.\n    \"\"\"\n    rounds_by_key_size = {16: 10, 24: 12, 32: 14}\n    def __init__(self, master_key):\n        \"\"\"\n        Initializes the object with a given key.\n        \"\"\"\n        assert len(master_key) in AES.rounds_by_key_size\n        self.n_rounds = AES.rounds_by_key_size[len(master_key)]\n        self._key_matrices = self._expand_key(master_key)\n\n    def _expand_key(self, master_key):\n        \"\"\"\n        Expands and returns a list of key matrices for the given master_key.\n        \"\"\"\n        # Initialize round keys with raw key material.\n        key_columns = bytes2matrix(master_key)\n        iteration_size = len(master_key) // 4\n\n        i = 1\n        while len(key_columns) < (self.n_rounds + 1) * 4:\n            # Copy previous word.\n            word = list(key_columns[-1])\n\n            # Perform schedule_core once every \"row\".\n            if len(key_columns) % iteration_size == 0:\n                # Circular shift.\n                word.append(word.pop(0))\n                # Map to S-BOX.\n                word = [s_box[b] for b in word]\n                # XOR with first byte of R-CON, since the others bytes of R-CON are 0.\n                word[0] ^= r_con[i]\n                i += 1\n            elif len(master_key) == 32 and len(key_columns) % iteration_size == 4:\n                # Run word through S-box in the fourth iteration when using a\n                # 256-bit key.\n                word = [s_box[b] for b in word]\n\n            # XOR with equivalent word from previous iteration.\n            word = xor_bytes(word, key_columns[-iteration_size])\n            key_columns.append(word)\n\n        # Group key words in 4x4 byte matrices.\n        return [key_columns[4*i : 4*(i+1)] for i in range(len(key_columns) // 4)]\n\n    def encrypt_block(self, plaintext):\n        \"\"\"\n        Encrypts a single block of 16 byte long plaintext.\n        \"\"\"\n        assert len(plaintext) == 16\n\n        plain_state = bytes2matrix(plaintext)\n\n        add_round_key(plain_state, self._key_matrices[0])\n\n        for i in range(1, self.n_rounds):\n            sub_bytes(plain_state)\n            shift_rows(plain_state)\n            mix_columns(plain_state)\n            add_round_key(plain_state, self._key_matrices[i])\n\n        sub_bytes(plain_state)\n        shift_rows(plain_state)\n        add_round_key(plain_state, self._key_matrices[-1])\n\n        return matrix2bytes(plain_state)\n\n    def encrypt(self, plaintext):\n        ret = []\n        assert len(plaintext) % 16 == 0\n        assert len(plaintext) <= 160\n        for count in range(len(plaintext) // 16):\n            block = plaintext[count * 16:(count + 1) * 16]\n            plain_state = bytes2matrix(block)\n\n            add_round_key(plain_state, self._key_matrices[0])\n\n            for i in range(count):\n                sub_bytes(plain_state)\n                shift_rows(plain_state)\n                mix_columns(plain_state)\n                add_round_key(plain_state, self._key_matrices[i + 1])\n\n            sub_bytes(plain_state)\n            shift_rows(plain_state)\n            add_round_key(plain_state, self._key_matrices[count + 1])\n            ret.extend(matrix2bytes(plain_state))\n        return ret\n\n    def decrypt(self, ciphertext):\n        ret = []\n        assert len(ciphertext) % 16 == 0\n        assert len(ciphertext) <= 160\n        for count in range(len(ciphertext) // 16):\n            block = ciphertext[count * 16:(count + 1) * 16]\n            cipher_state = bytes2matrix(block)\n\n            add_round_key(cipher_state, self._key_matrices[count + 1])\n            inv_shift_rows(cipher_state)\n            inv_sub_bytes(cipher_state)\n\n            for i in reversed(range(count)):\n                add_round_key(cipher_state, self._key_matrices[i + 1])\n                inv_mix_columns(cipher_state)\n                inv_shift_rows(cipher_state)\n                inv_sub_bytes(cipher_state)\n\n            add_round_key(cipher_state, self._key_matrices[0])\n            ret.extend(matrix2bytes(cipher_state))\n        return ret\n",
    "Cargo.toml": "[package]\nname = \"shmooving-3\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nhex = \"0.4.3\"\nrand = { version = \"0.8.5\", features = [\"min_const_gen\"] }\n",
    "Dockerfile": "FROM rust as build\n\nADD src /build/src\nADD Cargo.toml /build/Cargo.toml\nADD flag.txt /build/flag.txt\n\nWORKDIR /build\n\nRUN cargo build --release\n\nFROM debian:buster-slim\n\nARG port\nARG name\n\nRUN apt update; apt -y install socat\nCOPY --from=build /build/target/release/$name /crypto/$name\nCOPY --from=build /build/flag.txt flag.txt\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/crypto/$name,stderr\" > /crypto/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/crypto/docker_entrypoint.sh\"]\n",
    "flag.txt": "gigem{r3duc3d_r0und_aes_1s_b4d}\n",
    "Makefile": "NAME := shmooving-3\nPORT := 7774\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nclean: .PHONY\n\tdocker kill $(NAME) && docker rm $(NAME) && docker rmi $(NAME)\n\trm -f $(NAME)\n\ndocker: Dockerfile ./src/main.rs\n\ttouch flag.txt\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/crypto/$(NAME) $(NAME)\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip -r $(NAME).zip $(NAME) $(NAME) Cargo.toml Dockerfile Makefile src\n\n.PHONY:\n",
    "README.md": "# Shmooving 3\n\nAuthor: `_mac_`\n\nYou're probably tired of it, but I've made AES so fast now. It only takes 1/10th of the time it took before!\n\n## Solution\nThis challenge implements AES-128-ECB, but the number of rounds is dependent on the index of the block. We get an encryption oracle for up to 10 blocks before we're asked to decrypt a 10-block challenge encrypted with the same key. Since the index of the first block is zero, the round loop will be completely skipped, and the only operations done on it are:\n1. add first round key\n2. apply substitution box\n3. shift rows\n4. add second round key\n\nIn other words, this is basically one round of AES (without the MixColumns operation), so I started googling and found this [crypto SE post](https://crypto.stackexchange.com/questions/80743/one-round-of-aes-128). The top answer describes an attack (with MixColumns) for recovering the key given 2 plaintext/ciphertext pairs, but we only have 1 pair (without MixColumns). The other answers also described attacks for a single pair, but I didn't bother trying to figure out how to adapt their listed strategies/code to not account for MixColumns. However, the last answer had an interesting reference:\n> There is a paper called [Low Data Complexity Attacks on AES](https://eprint.iacr.org/2010/633.pdf) by Bouillaget et al. It describes best attacks on 1-4 rounds of AES with only 1-9 known/chosen plaintexts.\n\nAfter some light skimming, I found yet another interesting reference within the paper:\n> We note that the problem of attacking one round AES without the MixColumns operation with a single known plaintext is studied in [25]. It is shown that 2^16 encryptions are sufficient to retrieve the key.\n\nThis led me to find [The Effects of the Omission of Last Round's MixColumns on AES](https://www.sciencedirect.com/science/article/pii/S0020019010000335). The approach was similar to the attacks first described on the SE post; you derive bytes of the first and second subkeys using relations imposed by the key schedule and encryption/decryption, guessing bytes where necessary and checking the results of said guesses with different relations to verify correctness. While reading, I also found [On the security of inclusion or omission of MixColumns in AES cipher](https://www.semanticscholar.org/paper/On-the-security-of-inclusion-or-omission-of-in-AES-AlMarashda-Alsalami/e13e7d71861290e218b57307a09dda040978375f). This paper described an attack that marginally improved the algorithm of the previous one, and the authors also described their approach in more detail, so I settled on using it for my solve.\n\nFor the actual solve, I implemented the attack by following this table from the paper:\n\n<img src=\"./table.png\"  width=\"60%\" height=\"30%\">\n\nUnfortunately, I had to figure out the relations myself (they weren't explicitly stated in the paper), and the attack could still produce multiple candidate keys that would work for the first block. To find the unique key that actually worked, my strategy was to re-encrypt the blocks I sent to the oracle, then check if they matched the response. To handle encryption and decryption, I adapted https://github.com/bozhu/AES-Python. Full details can be found in `solve.py`.\n\nFlag: `gigem{r3duc3d_r0und_aes_1s_b4d}`\n\n",
    "solve.py": "from aes import s_box as s, inv_s_box as si, AES\nfrom pwn import *\n\ndef solve(c):\n    candidates = []\n    k = [0] * 16\n    k1 = [0] * 16\n    for x in range(256):\n        # K1_13, GUESS\n        k1[12] = x\n        # K0_13, PED 13\n        # c[12] = k1[12] ^ s[k[12]]\n        k[12] = si[c[12] ^ k1[12]]\n        # K1_9, KS 13\n        # k1[12] = k[12] ^ k1[8]\n        k1[8] = k1[12] ^ k[12]\n        # K0_9, PED 9\n        # c[8] = k1[8] ^ s[k[8]]\n        k[8] = si[c[8] ^ k1[8]]\n        # K1_5, KS 9\n        # k1[8] = k[8] ^ k1[4]\n        k1[4] = k1[8] ^ k[8]\n        # K0_5, PED 5\n        # c[4] = k1[4] ^ s[k[4]]\n        k[4] = si[c[4] ^ k1[4]]\n        # K1_1, KS 5\n        # k1[4] = k[4] ^ k1[0]\n        k1[0] = k1[4] ^ k[4]\n        # K0_1, PED 1\n        # c[0] = k1[0] ^ s[k[0]]\n        k[0] = si[c[0] ^ k1[0]]\n        # K0_14, KS 1\n        # k1[0] = k[0] ^ s[k[13]] ^ 1\n        k[13] = si[k1[0] ^ k[0] ^ 1]\n        # K1_10, PED 10\n        # c[9] = k1[9] ^ s[k[13]]\n        k1[9] = c[9] ^ s[k[13]]\n        # K1_14, KS 14\n        # k1[13] = k[13] ^ k1[9]\n        k1[13] = k[13] ^ k1[9]\n        # K0_2, PED 14\n        # c[13] = k1[13] ^ s[k[1]]\n        k[1] = si[c[13] ^ k1[13]]\n        for y in range(256):\n            # K1_4, GUESS\n            k1[3] = y\n            # K0_16, PED 4\n            # c[3] = k1[3] ^ s[k[15]]\n            k[15] = si[c[3] ^ k1[3]]\n            # K0_4, KS 4\n            # k1[3] = k[3] ^ s[k[12]]\n            k[3] = k1[3] ^ s[k[12]]\n            # K1_8, PED 8\n            # c[7] = k1[7] ^ s[k[3]]\n            k1[7] = c[7] ^ s[k[3]]\n            # K0_8, KS 8\n            # k1[7] = k[7] ^ k1[3]\n            k[7] = k1[7] ^ k1[3]\n            # K1_12, PED 12\n            # c[11] = k1[11] ^ s[k[7]]\n            k1[11] = c[11] ^ s[k[7]]\n            # K0_12, KS 12\n            # k1[11] = k[11] ^ k1[7]\n            k[11] = k1[11] ^ k1[7]\n            # K1_16, PED 16\n            # c[15] = k1[15] ^ s[k[11]]\n            k1[15] = c[15] ^ s[k[11]]\n            # K1_16, KS 16 (check)\n            # k1[15] = k[15] ^ k1[11]\n            if k1[15] == k[15] ^ k1[11]:\n                for z in range(256):\n                    # K1_3, GUESS\n                    k1[2] = z\n                    # K0_3, KS 3\n                    # k1[2] = k[2] ^ s[k[15]]\n                    k[2] = k1[2] ^ s[k[15]]\n                    # K1_11, PED 11\n                    # c[10] = k1[10] ^ s[k[2]]\n                    k1[10] = c[10] ^ s[k[2]]\n                    # K0_11, PED 3\n                    # c[2] = k1[2] ^ s[k[10]]\n                    k[10] = si[c[2] ^ k1[2]]\n                    # K1_7, KS 11\n                    # k1[10] = k[10] ^ k1[6]\n                    k1[6] = k1[10] ^ k[10]\n                    # K0_7, KS 7\n                    # k1[6] = k[6] ^ k1[2]\n                    k[6] = k1[6] ^ k1[2]\n                    # K0_15, PED 7\n                    # c[6] = k1[6] ^ s[k[14]]\n                    k[14] = si[c[6] ^ k1[6]]\n                    # K1_15, KS 15\n                    # k1[14] = k[14] ^ k1[10]\n                    k1[14] = k[14] ^ k1[10]\n                    # K1_15, PED 15 (check)\n                    # c[14] = k1[14] ^ s[k[6]]\n                    if k1[14] == c[14] ^ s[k[6]]:\n                        # K1_2, KS 2\n                        # k1[1] = k[1] ^ s[k[14]]\n                        k1[1] = k[1] ^ s[k[14]]\n                        # K0_6, PED 2\n                        # c[1] = k1[1] ^ s[k[5]]\n                        k[5] = si[c[1] ^ k1[1]]\n                        # K1_6, KS 6\n                        # k1[5] = k[5] ^ k1[1]\n                        k1[5] = k[5] ^ k1[1]\n                        # K0_10, PED 6\n                        # c[5] = k1[5] ^ s[k[9]]\n                        k[9] = si[c[5] ^ k1[5]]\n                        # K0_10, KS 10 (check)\n                        # k1[9] = k[9] ^ k1[5]\n                        if k[9] == k1[9] ^ k1[5]:\n                            candidates.append(k[:])\n    return candidates\n\np = remote(\"localhost\", 7774)\nzeros = b\"\\x00\" * (16 * 2)\np.sendline(zeros.hex().encode())\np.recvuntil(b\"message:\\n\")\noracle = bytes.fromhex(p.recvlineS())\np.recvuntil(b\"flag:\\n\")\nchall = bytes.fromhex(p.recvlineS())\nfor key in solve(oracle[:16]):\n    cipher = AES(key)\n    if bytes(cipher.encrypt(zeros)) == oracle:\n        response = bytes(cipher.decrypt(chall))\n        p.sendline(response.hex().encode())\n        p.recvuntil(b\"flag:\\n\")\n        print(p.recvlineS())\n        break\n",
    "table.png": "[Binary file or unsupported type: png]",
    "src\\main.rs": "use rand::Rng;\nuse std::error::Error;\n\nstatic SBOX: [u8; 256] = [\n    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,\n];\nstatic RCON: [u8; 11] = [\n    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,\n];\n\nfn xtime(x: u8) -> u8 {\n    (x << 1) ^ (((x >> 7) & 1) * 0x1b)\n}\nfn add_round_key(s: &mut [u8; 16], key: &[u8; 16]) {\n    s.iter_mut().zip(key.iter()).for_each(|(s, k)| *s ^= k);\n}\nfn sub_bytes(s: &mut [u8; 16]) {\n    s.iter_mut().for_each(|s| *s = SBOX[*s as usize]);\n}\nfn mix_columns(s: &mut [u8; 16]) {\n    for s in s.chunks_exact_mut(4) {\n        let t = s[0] ^ s[1] ^ s[2] ^ s[3];\n        let old_s0 = s[0];\n        s[0] ^= t ^ xtime(s[0] ^ s[1]);\n        s[1] ^= t ^ xtime(s[1] ^ s[2]);\n        s[2] ^= t ^ xtime(s[2] ^ s[3]);\n        s[3] ^= t ^ xtime(s[3] ^ old_s0);\n    }\n}\nfn shift_rows(s: &mut [u8; 16]) {\n    for col in 0..4 {\n        let (i0, i1, i2, i3) = (col, col + 4, col + 8, col + 12);\n        for _ in 0..col {\n            let t = s[i0];\n            s[i0] = s[i1];\n            s[i1] = s[i2];\n            s[i2] = s[i3];\n            s[i3] = t;\n        }\n    }\n}\nfn blocks(blocks: &mut [u8]) -> impl Iterator<Item = &mut [u8; 16]> + '_ {\n    assert_eq!(blocks.len() % 16, 0);\n    blocks\n        .chunks_exact_mut(16)\n        .map(|block| block.try_into().unwrap())\n}\n\npub struct Aes128 {\n    schedule: [[u8; 16]; 11],\n}\n\nimpl Aes128 {\n    pub fn new(key: &[u8; 16]) -> Self {\n        let mut schedule = [[0u8; 16]; 11];\n\n        schedule[0] = *key;\n\n        // SAFETY: imagine checking invariants\n        let w = unsafe { &mut *schedule.as_mut_ptr().cast::<[[u8; 4]; 44]>() };\n\n        for i in 4..44 {\n            let mut temp = w[i - 1];\n            if i % 4 == 0 {\n                temp.rotate_left(1);\n                temp.iter_mut().for_each(|x| *x = SBOX[*x as usize]);\n                temp[0] ^= RCON[i / 4];\n            }\n            temp.iter_mut()\n                .zip(w[i - 4].iter())\n                .for_each(|(t, w)| *t ^= *w);\n            w[i] = temp;\n        }\n\n        Self { schedule }\n    }\n    pub fn encrypt(&self, plaintext: &mut [u8]) {\n        for (count, block) in blocks(plaintext).enumerate() {\n            add_round_key(block, &self.schedule[0]);\n\n            for i in 0..count {\n                sub_bytes(block);\n                shift_rows(block);\n                mix_columns(block);\n                add_round_key(block, &self.schedule[i + 1]);\n            }\n\n            sub_bytes(block);\n            shift_rows(block);\n            add_round_key(block, &self.schedule[count + 1]);\n        }\n    }\n}\n\ntype Result<T> = std::result::Result<T, Box<dyn Error>>;\n\nfn get_line() -> Result<String> {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input)?;\n    input.pop();\n    Ok(input)\n}\n\nfn main() -> Result<()> {\n    let mut rng = rand::thread_rng();\n    let cipher = Aes128::new(&rng.gen());\n    let chall = rng.gen::<[u8; 16 * 10]>();\n    let mut ciphertext = chall.clone();\n    cipher.encrypt(&mut ciphertext);\n\n    println!(\"I've made the fastest version of AES yet!\");\n    println!(\"I'll encrypt whatever you want, but only up to 10 blocks. Enter them as hex below:\");\n    let mut block = hex::decode(get_line()?)?;\n    if block.len() % 16 != 0 || block.len() > 160 {\n        return Err(\"bad length\".into());\n    }\n    cipher.encrypt(&mut block);\n    println!(\"Here is your encrypted message:\\n{}\\n\", hex::encode(&block));\n    println!(\"Decrypt this for a flag:\\n{}\", hex::encode(&ciphertext));\n    println!(\"What's your answer (in hex)?\");\n    if hex::decode(get_line()?)? == chall {\n        let flag = std::fs::read_to_string(\"flag.txt\")?;\n        println!(\"Nice work! Here's the flag:\\n{flag}\");\n    } else {\n        println!(\"That's not the right answer D:\");\n    }\n    Ok(())\n}\n",
    "category": "crypto"
}