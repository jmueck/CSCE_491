{
    "BlackBox.hdl": "// Trust No One\n\nCHIP BlackBox {\n    IN in[128];\n    OUT out[128];\n\n    PARTS:\n    Xor(a=in[0..31], b=in[96..127], out=red);\n    Xor(a=in[32..63], b=in[64..95], out=king);\n    Xor(a=in[64..95], b=in[96..127], out=dave);\n    Concat(a=in[0..31], b=dave, c=red, d=king, out=ayk);\n    Switch(a=ayk[3..6], b=ayk[19..22]);\n    Switch(a=ayk[54..61], b=ayk[32..39]);\n    Switch(a=ayk[63..70], b=ayk[120..127]);\n    Switch(a=ayk[95..98], b=ayk[81..84]);\n    Xor(a=ayk[0..31], b=ayk[64..95], out=earl);\n    Xor(a=ayk[64..95], b=ayk[96..127], out=cosmo);\n    Xor(a=ayk[32..63], b=ayk[96..127], out=abbott);\n    Concat(a=abbott, b=comso, c=ayk[0..31], d=earl, out=phoenix);\n    Reverse(in=phoenix, out=out);\n}\n",
    "challenge.py": "from hacksport.problem import Challenge, File\n\nclass Problem(Challenge):\n    def setup(self):\n        self.files = [File(\"BlackBox.hdl\")]\n\n    def generate_flag(self, random):\n        return r\"gigem{t0o_M4nY_s3cR3tS}\"\n",
    "problem.json": "{\n  \"name\": \"setecAstronomy\",\n  \"category\": \"Reversing\",\n  \"description\": \"After a top NSA scientist was found murdered, we searched his office and found a black box with the output still on the display. We have no idea what the code was, but we were able to find a schematic of the black box in his office and turn it into an HDL file. Figure out what the input was. You are alone on this. Remember: Trust No One.\\n\\n<strong>Discovered Output</strong>\\n<code>11001010011011101100110001011000111110101010111000001100011101101111100001111010001000100110000011100100100110001110000001111101</code>\\n {{ url_for('BlackBox.hdl') }}\",\n  \"score\" : 200,\n  \"hints\": [\"Encryption Scheme: ISO-8859-1\"],\n  \"walkthrough\": \"check our github or something\",\n  \"author\": \"Glenn Fitzpatrick\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf 2021\"\n}\n",
    "README.md": "# setec astronomy\n\n## Description\n\nAfter a top NSA scientist was found murdered, we searched his office and found a black box with the output still on the display. We have no idea what the code was, but we were able to find a schematic of the black box in his office and turn it into an HDL file. Figure out what the input was. You are alone on this. Remember: Trust No One.\n\n## Discovered output\n\n`11001010011011101100110001011000111110101010111000001100011101101111100001111010001000100110000011100100100110001110000001111101`\n\nEncryption Scheme: ISO-8859-1\n\n## Solution\n\n`gigem{t0o_M4nY_s3cR3tS}`\n\nThis is helpfully a rather simple reversing challenge. Unhelpfully, there's\na lot of really finagle-y bit-level operations, so we'll use bitvectors to\nmake things less bad.\n\nThe only tricky bit about the code ended up being the XORs; we just use the\ncommutative property of XOR to get the input XOR via known values.\n\n```rust\nuse bitvec::prelude::*;\nuse hex_literal::hex;\n\nuse encoding::all::ISO_8859_1;\nuse encoding::{DecoderTrap, Encoding};\n\nstatic BYTES: [u8; 16] = hex!(\"ca6ecc58faae0c76f87a2260e498e07d\");\n\nfn main() {\n    let mut phoenix = bitvec![Msb0, u8; 0; 128];\n    for i in (0usize..128).step_by(8) {\n        phoenix[i..(i + 8)].store(BYTES[i / 8]);\n    }\n\n    println!(\"phoenix: {:x?}\", phoenix);\n\n    // reverse\n    phoenix.reverse(); // can only be done in place, unfortunately\n\n    println!(\"reversed phoenix: {:x?}\", phoenix);\n\n    // concat\n    let abbott = phoenix[0..32].to_bitvec();\n    let cosmo = phoenix[32..64].to_bitvec();\n    let mut ayk = phoenix[64..96].to_bitvec();\n    ayk.resize(128, false);\n    let earl = phoenix[96..128].to_bitvec();\n\n    let mut temp: bool;\n    // Xors\n    for i in 0..32 {\n        temp = ayk[i];\n        ayk.set(i + 64, earl[i] ^ temp); // yuck, manual xor\n    }\n    for i in 0..32 {\n        temp = ayk[i + 64];\n        ayk.set(i + 96, cosmo[i] ^ temp);\n    }\n    for i in 0..32 {\n        temp = ayk[i + 96];\n        ayk.set(i + 32, abbott[i] ^ temp);\n    }\n\n    println!(\"xord ayk: {:x?}\", ayk);\n\n    // swaps, ranges are inclusive\n    for i in 0..=3 {\n        ayk.swap(i + 95, i + 81);\n    }\n    for i in 0..=7 {\n        ayk.swap(i + 63, i + 120);\n    }\n    for i in 0..=7 {\n        ayk.swap(i + 54, i + 32);\n    }\n    for i in 0..=3 {\n        ayk.swap(i + 3, i + 19);\n    }\n\n    println!(\"swapped ayk: {:x?}\", ayk);\n\n    // concat 2: beyond cyberspace\n    let mut in_v = ayk[0..32].to_bitvec();\n    in_v.resize(128, false);\n    let dave = ayk[32..64].to_bitvec();\n    let red = ayk[64..96].to_bitvec();\n    let king = ayk[96..128].to_bitvec();\n\n    // Xors 2: resurrection\n    for i in 0..32 {\n        temp = in_v[i];\n        in_v.set(i + 96, red[i] ^ temp);\n    }\n    for i in 0..32 {\n        temp = in_v[i + 96];\n        in_v.set(i + 64, dave[i] ^ temp);\n    }\n    for i in 0..32 {\n        temp = in_v[i + 64];\n        in_v.set(i + 32, king[i] ^ temp);\n    }\n\n    println!(\"xord in_v: {:x?}\", ayk);\n\n    let res: Vec<u8> = in_v.into();\n    println!(\n        \"{}\",\n        ISO_8859_1\n            .decode(&res, DecoderTrap::Strict)\n            .unwrap()\n            .as_str()\n    );\n}\n```\n",
    "category": "reversing"
}