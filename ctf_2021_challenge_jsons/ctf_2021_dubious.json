{
    ".gitignore": "check_flag.*\n",
    "binwalk-worky.png": "[Binary file or unsupported type: png]",
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\nclass Problem(Challenge):\n    dont_template = [\"constraintgen\"]\n\n    def setup(self):\n        pass\n\n    def generate_flag(self, random):\n        return r\"gigem{cu570m_t0Ol1nG_0r_5uFF3r_c3fa0b029bf26fa98bf4b936532893}\"\n",
    "check-pattern.png": "[Binary file or unsupported type: png]",
    "compare.png": "[Binary file or unsupported type: png]",
    "dependency-hell-2.png": "[Binary file or unsupported type: png]",
    "dependency-hell.png": "[Binary file or unsupported type: png]",
    "file-no-worky.png": "[Binary file or unsupported type: png]",
    "Makefile": "CC := ubicom32-linux-uclibc-gcc\nOBJDUMP := ubicom32-linux-uclibc-objdump\nCFLAGS := -fPIC -shared -O0\nCONTAINER := check_flag.so\n\nall: check_flag.so\n\ndistclean: .PHONY clean\n\trm -rf constraintgen/venv\n\nclean: .PHONY\n\trm -f check_flag.*\n\nconstraintgen/venv:\n\tvirtualenv --python $(shell which python3.8) constraintgen/venv\n\tbash -c \"source constraintgen/venv/bin/activate; pip install z3-solver\"\n\ncheck_flag.c: constraintgen/venv constraintgen/main.py\n\tbash -c \"source constraintgen/venv/bin/activate; python constraintgen/main.py\"\n\ncheck_flag.so: check_flag.c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ncheck_flag.dump: check_flag.so\n\t$(OBJDUMP) -d $^ > $@\n\n.PHONY:\n",
    "problem.json": "{\n  \"name\": \"Dubious\",\n  \"category\": \"Reversing\",\n  \"description\": \"You completed your angr management course, but you're a little dubious about whether it was effective.\\n\\nIt definitely wasn't for this. Pass all checks to get the flag. <a href='http://tamuctf.com/static-files/check_flag.so'>dubious</a>\\n\\nEDIT: Please disregard the check_flag function; an old version of the binary was released, but does not impact a majority of the challenge.\",\n  \"score\": 500,\n  \"hints\": [\"I found this binary in an old router.\"],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Addison Crump\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n",
    "README.md": "# dubious\n\nYou completed your angr management course, but you're a little dubious about whether it was effective.\n\nIt definitely isn't for this. Pass all checks to get the flag.\n\n## Solution\n\nNote that this solution was not written for the binary which was used during the competition, but the solution script\nwas tested on the binary used in the competition before competition start. There are discrepancies only in the specific\nvalues used in the `check_xxx` functions and the component of the flag which was generated.\n\n### Identification\n\nThe first thing to do is to identify what check_flag.so even is. `file` correctly identifies it as an ELF, but not the\narchitecture info:\n\n![file does not identify the binary](file-no-worky.png)\n\nOur second option, a little more successful, is `binwalk`, which successfully identifies it as an Ubicom32 shared object\nfile:\n\n![binwalk identifies the binary](binwalk-worky.png)\n\nEven more specifically, it looks like this was compiled for the Linux triple, based on the Unix paths binwalk\ndiscovered.\n\n### Installation\n\nA little google-fu later, we find the [toolchain](https://wiki.codeaurora.org/xwiki/bin/Ubicom/Ubicom32%20Tool%20Chain/)!\nLooking at the build dependencies and comparing with those in the Ubuntu apt repositories, it looks like all the\ndependencies we need are present in Ubuntu 16.04 (Xenial). Quickest way to set that up is with debootstrap and a chroot\nor a systemd-nspawn container.\n\nWhat follows is a series of woes relating to dependency hell...\n\n![](dependency-hell.png)\n![](dependency-hell-2.png)\n\nBut finally, we execute `build_ubi32.sh` and build the toolchain. Success!\n\n### Inspection\n\nUsing objdump to dump the assembly of the ELF, we find quite a few functions of the naming pattern `check_xxx`, with xxx\nbeing some numbers:\n\n![](check-pattern.png)\n\nWhile it may not be the exact same toolchain, I can't actually find an IP8K ISA reference (go figure), but I can find an\nIP5K ISA reference with [very similar mnemonics and operands](http://www.texim-europe.com/getfile.aspx?id=68544). We'll\nlean on that for now.\n\nA few things we notice about these checks:\n\n1. This architecture is super cursed. (`-8(sp)++` haunts my dreams)\n2. These checks all look very similar, as though they were generated. It's probably a good guess that they were.\n3. There are index-based accesses of a parameter (pointer copy at 1814, offset at 1820 and 1834, and byte access at 1828\n   and 183c) which are stashed in d1 and d0.\n4. d0 then has a value added, and d1 and d0 are compared for equality using subtraction and checking the carry bit with\n   addc (addresses 1844-1850)\n5. Function returns using calli (because, for some reason, calli is faster than ret on leaf functions according to the\n   ISA reference)\n   \nThere end up being a total of 4 or 5 different versions of these checks, depending on the size of the compared value or\nif the zero-th index of the pointer is used, and then finally a straight up equality comparison:\n\n![](compare.png)\n\nThis effectively pins one value to a specific index and the other comparisons are between different indices. We'll need\nto script this.\n\n### Automation\n\nBecause I'm a z3 and a Rust nut, I used Rust and z3 to solve this by parsing each assembly code pattern with regex and\neffectively dumping the constraints into z3 for solving. That code is available in [the solver directory](solver/src/main.rs).\n\nRunning this satisfyingly extracts all the values:\n\n```\n0 => p[37] == 209 + p[30]\n1 => p[5] == 70 + p[24]\n2 => p[53] == 228 + p[15]\n3 => p[30] == 24 + p[19]\n4 => p[60] == 190 + p[25]\n5 => p[22] == 19 + p[23]\n6 => p[60] == 198 + p[4]\n7 => p[56] == 204 + p[0]\n8 => p[48] == 1 + p[34]\n9 => p[47] == 187 + p[61]\n10 => p[20] == 226 + p[61]\n11 => p[38] == 204 + p[49]\n12 => p[49] == 248 + p[18]\n13 => p[50] == 1 + p[28]\n14 => p[23] == 47 + p[14]\n15 => p[25] == 61 + p[47]\n16 => p[22] == 60 + p[43]\n17 => p[57] == 253 + p[55]\n18 => p[23] == 41 + p[43]\n19 => p[45] == 43 + p[54]\n20 => p[16] == 6 + p[44]\n21 => p[15] == 31 + p[14]\n22 => p[61] == 17 + p[16]\n23 => p[24] == 252 + p[52]\n24 => p[14] == 209 + p[20]\n25 => p[42] == 2 + p[10]\n26 => p[4] == 30 + p[15]\n27 => p[49] == 248 + p[18]\n28 => p[19] == 225 + p[44]\n29 => p[0] == 53 + p[42]\n30 => p[56] == 199 + p[16]\n31 => p[2] == 8 + p[30]\n32 => p[15] == 23 + p[58]\n33 => p[12] == 254 + p[45]\n34 => p[47] == 214 + p[36]\n35 => p[14] == 201 + p[0]\n36 => p[2] == 1 + p[44]\n37 => p[27] == 18 + p[50]\n38 => p[59] == 6 + p[28]\n39 => p[47] == 215 + p[34]\n40 => p[12] == 47 + p[21]\n41 => p[29] == 15 + p[6]\n42 => p[11] == 14 + p[30]\n43 => p[22] == 66 + p[14]\n44 => p[52] == 9 + p[10]\n45 => p[19] == 248 + p[15]\n46 => p[48] == 44 + p[54]\n47 => p[37] == 247 + p[39]\n48 => p[8] == 211 + p[48]\n49 => p[9] == 2 + p[55]\n50 => p[48] == 253 + p[3]\n51 => p[60] == 212 + p[20]\n52 => p[3] == 240 + p[25]\n53 => p[21] == 202 + p[44]\n54 => p[8] == 214 + p[23]\n55 => p[0] == 55 + p[21]\n56 => p[51] == 27 + p[19]\n57 => p[39] == 1 + p[47]\n58 => p[54] == 253 + p[52]\n59 => p[49] == 54 + p[35]\n60 => p[38] == 250 + p[58]\n61 => p[14] == 252 + p[50]\n62 => p[3] == 45 + p[47]\n63 => p[34] == 248 + p[1]\n64 => p[28] == 205 + p[41]\n65 => p[52] == 215 + p[36]\n66 => p[4] == 10 + p[6]\n67 => p[56] == 237 + p[27]\n68 => p[29] == 57 + p[46]\n69 => p[26] == 14 + p[58]\n70 => p[28] == 1 + p[57]\n71 => p[26] == 231 + p[23]\n72 => p[6] == 254 + p[3]\n73 => p[49] == 51 + p[32]\n74 => p[8] == 2 + p[32]\n75 => p[11] == 54 + p[9]\n76 => p[8] == 207 + p[33]\n77 => p[0] == 1 + p[41]\n78 => p[10] == 209 + p[30]\n79 => p[51] == 41 + p[52]\n80 => p[15] == 237 + p[40]\n81 => p[41] == 46 + p[58]\n82 => p[50] == 206 + p[33]\n83 => p[17] == 180 + p[61]\n84 => p[24] == 4 + p[17]\n85 => p[12] == 40 + p[9]\n86 => p[55] == 5 + p[21]\n87 => p[1] == 49 + p[58]\n88 => p[18] == 60 + p[38]\n89 => p[43] == 254 + p[47]\n90 => p[25] == 66 + p[32]\n91 => p[26] == 224 + p[49]\n92 => p[27] == 212 + p[22]\n93 => p[36] == 252 + p[49]\n94 => p[37] == 196 + p[16]\n95 => p[39] == 188 + p[61]\n96 => p[42] == 189 + p[25]\n97 => p[50] == 251 + p[59]\n98 => p[57] == 255 + p[56]\n99 => p[7] == 19 + p[48]\nNo match found for 100\n101 => p[1] == 10 + p[23]\n102 => p[55] == 2 + p[53]\n103 => p[59] == 216 + p[45]\n104 => p[11] == 61 + p[35]\n105 => p[1] == 7 + p[40]\n106 => p[12] == 253 + p[40]\n107 => p[12] == 234 + p[7]\n108 => p[13] == 249 + p[5]\n109 => p[11] == 60 + p[17]\n110 => p[24] == 252 + p[46]\n111 => p[7] == 60 + p[52]\n112 => p[53] == 250 + p[46]\n113 => p[2] == 245 + p[29]\n114 => p[59] == 190 + p[5]\n115 => p[31] == 49 + p[38]\n116 => p[33] == 241 + p[7]\n117 => p[51] == 41 + p[52]\n118 => p[13] == 68 + p[35]\n119 => p[31] == 252 + p[2]\n120 => p[31] == 42 + p[39]\n121 => p[3] == 241 + p[13]\n122 => 98 == p[51]\nPassword discovered: gigem{cu570m_t0Ol1nG_0r_5uFF3r_c3fa0b029bf26fa98bf4b936532893}\n```\n\nNote in particular that there's even some redundancy, which is very nice (we didn't have to make a special case for\ncheck_100).\n",
    "constraintgen\\.gitignore": "venv/\n",
    "constraintgen\\main.py": "from random import getrandbits, sample, choice\nfrom binascii import b2a_hex\n\nfrom z3 import *\nfrom typing import Union, Dict\n\n\ndef prove(solver: Solver, stmt: Union[BoolRef, bool]):\n    res = solver.check(Not(stmt))\n    return res.r == -1\n\n\ndef generate_relatives(pw: Dict[BitVecRef, BitVecVal]) -> [BoolRef]:\n    avail = list(pw.keys())\n    rels = []\n    used = {}\n    for elem in pw.keys():\n        used[elem] = 0\n    while not all(used[elem] > 2 for elem in pw.keys()):\n        rel = sample(avail, 2)\n        if all(used[elem] > 2 for elem in rel):  # remove too many redundants\n            continue\n        used[rel[0]] += 1\n        used[rel[1]] += 1\n        rels.append(rel[0] == simplify(rel[1] + (pw.get(rel[0]) - pw.get(rel[1]))))\n\n    return rels\n\n\ndef squeeze(solver: Solver, pw: Dict[BitVecRef, BitVecVal]) -> int:\n    avail = list(pw.keys())\n    count = 0\n    while not prove(solver, And([sym == val for sym, val in pw.items()])):\n        count += 1\n        pick = choice(avail)\n        avail.remove(pick)\n        solver.add(pick == pw.get(pick))\n\n    return count\n\n\ndef generate(password: str):\n    ctx = Context()\n    solver = Solver(ctx=ctx)\n    bvsort = BitVecSort(8, ctx)\n    pw = {}\n    for i, c in enumerate(password):\n        pw[BitVec(f\"pw[{str(i)}]\", bvsort, ctx)] = BitVecVal(ord(c), bvsort, ctx)\n    rels = generate_relatives(pw)\n    solver.add(rels)\n    squeezes = squeeze(solver, pw)\n    with open('check_flag.c', 'w') as source:\n        source.write(\"#include <stdbool.h>\\n\")\n        source.write(\"\\n\")\n        source.write(f\"// {len(solver.assertions())} assertions, {squeezes} squeezes\\n\")\n        source.write(f\"// password: {password}\\n\")\n        source.write(\"\\n\")\n        for i, assertion in enumerate(solver.assertions()):\n            source.write(f\"bool check_{i}(char *pw) {{return {assertion};}}\\n\")\n        source.write(\"\\n\")\n\n#        source.write(\"bool check_flag(char *pw) {\\n\")\n#\n#        source.write(\"    return \")\n#        source.write(\" && \".join(f\"check_{i}(pw)\" for i in range(len(password))))\n#        source.write(\";\\n\")\n#\n#        source.write(\"}\\n\")\n    return 0\n\n\nif __name__ == '__main__':\n    extra = b2a_hex(bytearray(getrandbits(8) for _ in range(15))).decode('ascii')\n    password = f\"tamuctf{{cu570m_t0Ol1nG_0r_5uFF3r_{extra}}}\"\n    sys.exit(generate(password))\n",
    "solver\\.gitignore": "target/\n",
    "solver\\Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\n[[package]]\nname = \"aho-corasick\"\nversion = \"0.7.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7404febffaa47dac81aa44dba71523c9d069b1bdc50a77db41195149e17f68e5\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"cfg-if\"\nversion = \"0.1.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n\n[[package]]\nname = \"lazy_static\"\nversion = \"1.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n\n[[package]]\nname = \"log\"\nversion = \"0.4.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4fabed175da42fed1fa0746b0ea71f412aa9d35e76e95e59b192c64b9dc2bf8b\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"memchr\"\nversion = \"2.3.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0ee1c47aaa256ecabcaea351eae4a9b01ef39ed810004e298d2511ed284b1525\"\n\n[[package]]\nname = \"regex\"\nversion = \"1.4.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"38cf2c13ed4745de91a5eb834e11c00bcc3709e773173b2ce4c56c9fbde04b9c\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-syntax\",\n \"thread_local\",\n]\n\n[[package]]\nname = \"regex-syntax\"\nversion = \"0.6.21\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3b181ba2dcf07aaccad5448e8ead58db5b742cf85dfe035e2227f137a539a189\"\n\n[[package]]\nname = \"solver\"\nversion = \"0.1.0\"\ndependencies = [\n \"regex\",\n \"z3\",\n]\n\n[[package]]\nname = \"thread_local\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d40c6d1b69745a6ec6fb1ca717914848da4b44ae29d9b3080cbee91d72a69b14\"\ndependencies = [\n \"lazy_static\",\n]\n\n[[package]]\nname = \"z3\"\nversion = \"0.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0c5bdc8c9e19d1b983c5584cd4baf6fbd71f3ca5c83283b9d46ad7780d67bd3b\"\ndependencies = [\n \"lazy_static\",\n \"log\",\n \"z3-sys\",\n]\n\n[[package]]\nname = \"z3-sys\"\nversion = \"0.6.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"afa18ba5fbd4933e41ffb440c3fd91f91fe9cdb7310cce3ddfb6648563811de0\"\n",
    "solver\\Cargo.toml": "[package]\nname = \"solver\"\nversion = \"0.1.0\"\nauthors = [\"Addison Crump <me@addisoncrump.info>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nregex = \"1\"\nz3 = \"0.9.0\"\n",
    "solver\\src\\main.rs": "use regex::Regex;\nuse std::fs::File;\nuse std::io::{BufReader, Read};\nuse std::ops::Add;\nuse std::str::FromStr;\nuse z3::ast::{Ast, Int, BV};\nuse z3::{Config, Context};\nuse z3::{SatResult, Solver};\n\nfn main() {\n    let file = File::open(\"check_flag.dump\").expect(\"Couldn't find check_flag.dump\");\n    let mut dump = String::new();\n    BufReader::new(file)\n        .read_to_string(&mut dump)\n        .expect(\"Couldn't read whole dump\");\n\n    let check_parse =\n        Regex::new(r\"[0-9a-f]+ <check_[0-9]+>:\\n((?: {4}[0-9a-f]+:\\t[0-9a-f]+ \\t.+\\n)+)\").unwrap();\n    let diff1_parse = Regex::new(r\"[0-9a-f]+ <check_[0-9]+>:\\n.*move\\.4 -8\\(sp\\)\\+\\+,a6\\n.*lea\\.1 a6,4\\(sp\\)\\n.*move\\.4 \\(a6\\),d0\\n.*move\\.4 d0,\\(a6\\)\\n.*add\\.4 d0,#([0-9]+),d0\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*move\\.1 d1,d0\\n.*move\\.4 d0,\\(a6\\)\\n.*add\\.4 d0,#([0-9]+),d0\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*move\\.1 d0,d0\\n.*add\\.4 d0,#([0-9]+),d0\\n.*sub\\.4 d0,d1,d0\\n.*sub\\.4 d1,#0,d0\\n.*addc d0,d0,d1\\n.*move\\.4 a6,\\(sp\\)8\\+\\+\\n.*calli a5,0\\(a5\\)\").unwrap();\n    let diff2_parse = Regex::new(r\"[0-9a-f]+ <check_[0-9]+>:\\n.*move\\.4 -8\\(sp\\)\\+\\+,a6\\n.*lea\\.1 a6,4\\(sp\\)\\n.*move\\.4 \\(a6\\),d0\\n.*move\\.4 d0,\\(a6\\)\\n.*add\\.4 d0,#([0-9]+),d0\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*move\\.1 d1,d0\\n.*move\\.4 d0,\\(a6\\)\\n.*add\\.4 d0,#([0-9]+),d0\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*move\\.1 d0,d0\\n.*movei d2,#([0-9]+)\\n.*add\\.4 d0,d0,d2\\n.*sub\\.4 d0,d1,d0\\n.*sub\\.4 d1,#0,d0\\n.*addc d0,d0,d1\\n.*move\\.4 a6,\\(sp\\)8\\+\\+\\n.*calli a5,0\\(a5\\)\").unwrap();\n    let zdiff1_parse = Regex::new(r\"[0-9a-f]+ <check_[0-9]+>:\\n.*move\\.4 -8\\(sp\\)\\+\\+,a6\\n.*lea\\.1 a6,4\\(sp\\)\\n.*move\\.4 \\(a6\\),d0\\n.*move\\.4 d0,\\(a6\\)\\n.*add\\.4 d0,#([0-9]+),d0\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*move\\.1 d1,d0\\n.*move\\.4 d0,\\(a6\\)\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*move\\.1 d0,d0\\n.*movei d2,#([0-9]+)\\n.*add\\.4 d0,d0,d2\\n.*sub\\.4 d0,d1,d0\\n.*sub\\.4 d1,#0,d0\\n.*addc d0,d0,d1\\n.*move\\.4 a6,\\(sp\\)8\\+\\+\\n.*calli a5,0\\(a5\\)\").unwrap();\n    let zdiff2_parse = Regex::new(r\"[0-9a-f]+ <check_[0-9]+>:\\n.*move\\.4 -8\\(sp\\)\\+\\+,a6\\n.*lea\\.1 a6,4\\(sp\\)\\n.*move\\.4 \\(a6\\),d0\\n.*move\\.4 d0,\\(a6\\)\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*move\\.1 d1,d0\\n.*move\\.4 d0,\\(a6\\)\\n.*add\\.4 d0,#([0-9]+),d0\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*move\\.1 d0,d0\\n.*add\\.4 d0,#([0-9]+),d0\\n.*sub\\.4 d0,d1,d0\\n.*sub\\.4 d1,#0,d0\\n.*addc d0,d0,d1\\n.*move\\.4 a6,\\(sp\\)8\\+\\+\\n.*calli a5,0\\(a5\\)\").unwrap();\n    let zdiff3_parse = Regex::new(r\"[0-9a-f]+ <check_24>:\\n.*move\\.4 -8\\(sp\\)\\+\\+,a6\\n.*lea\\.1 a6,4\\(sp\\)\\n.*move\\.4 \\(a6\\),d0\\n.*move\\.4 d0,\\(a6\\)\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*move\\.1 d1,d0\\n.*move\\.4 d0,\\(a6\\)\\n.*add\\.4 d0,#([0-9]+),d0\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*move\\.1 d0,d0\\n.*movei d2,#([0-9]+)\\n.*add\\.4 d0,d0,d2\\n.*sub\\.4 d0,d1,d0\\n.*sub\\.4 d1,#0,d0\\n.*addc d0,d0,d1\\n.*move\\.4 a6,\\(sp\\)8\\+\\+\\n.*calli a5,0\\(a5\\)\").unwrap();\n    let eq_parse = Regex::new(r\"[0-9a-f]+ <check_[0-9]+>:\\n.*move\\.4 -8\\(sp\\)\\+\\+,a6\\n.*lea\\.1 a6,4\\(sp\\)\\n.*move\\.4 \\(a6\\),d0\\n.*move\\.4 d0,\\(a6\\)\\n.*add\\.4 d0,#([0-9]+),d0\\n.*movea a3,d0\\n.*move\\.1 d1,\\(a3\\)\\n.*move\\.4 d0,\\(a6\\)\\n.*add\\.4 d0,#([0-9]+),d0\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*xor\\.4 d0,d1,d0\\n.*move\\.1 d0,d0\\n.*add\\.4 d0,#-1,d0\\n.*lsr\\.4 d0,d0,#0x1f\\n.*move\\.4 a6,\\(sp\\)8\\+\\+\\n.*calli a5,0\\(a5\\)\").unwrap();\n    let eqimm_parse = Regex::new(r\"[0-9a-f]+ <check_[0-9a-f]+>:\\n.*move\\.4 -8\\(sp\\)\\+\\+,a6\\n.*lea\\.1 a6,4\\(sp\\)\\n.*move\\.4 \\(a6\\),d0\\n.*move\\.4 d0,\\(a6\\)\\n.*add\\.4 d0,#([0-9]+),d0\\n.*movea a3,d0\\n.*move\\.1 d0,\\(a3\\)\\n.*xor\\.4 d0,#([0-9]+),d0\\n.*move\\.1 d0,d0\\n.*add\\.4 d0,#-1,d0\\n.*lsr\\.4 d0,d0,#0x1f\\n.*move\\.4 a6,\\(sp\\)8\\+\\+\\n.*calli a5,0\\(a5\\)\").unwrap();\n\n    let config = Config::new();\n    let ctx = Context::new(&config);\n    let solver = Solver::new(&ctx);\n    for (func, capture) in (0..).zip(check_parse.captures_iter(&dump)) {\n        let check = capture.iter().next().unwrap().unwrap().as_str();\n        if let Some(extracted) = diff1_parse\n            .captures_iter(check)\n            .next()\n            .or_else(|| diff2_parse.captures_iter(check).next())\n        {\n            let mut args = extracted.iter().skip(1);\n            let cmp1 = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            let cmp2 = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            let offset = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            println!(\"{} => p[{}] == {} + p[{}]\", func, cmp1, offset, cmp2);\n            let cmp1 = BV::new_const(&ctx, format!(\"p[{}]\", cmp1), 8);\n            let cmp2 = BV::new_const(&ctx, format!(\"p[{}]\", cmp2), 8);\n            let offset = BV::from_int(&Int::from_u64(&ctx, offset as u64), 8);\n            solver.assert(&cmp1._eq(&offset.add(&cmp2)));\n        } else if let Some(extracted) = zdiff1_parse.captures_iter(check).next() {\n            let mut args = extracted.iter().skip(1);\n            let cmp1 = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            let offset = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            println!(\"{} => p[{}] == {} + p[0]\", func, cmp1, offset);\n            let cmp1 = BV::new_const(&ctx, format!(\"p[{}]\", cmp1), 8);\n            let cmp2 = BV::new_const(&ctx, format!(\"p[{}]\", 0), 8);\n            let offset = BV::from_int(&Int::from_u64(&ctx, offset as u64), 8);\n            solver.assert(&cmp1._eq(&offset.add(&cmp2)));\n        } else if let Some(extracted) = zdiff2_parse\n            .captures_iter(check)\n            .next()\n            .or_else(|| zdiff3_parse.captures_iter(check).next())\n        {\n            let mut args = extracted.iter().skip(1);\n            let cmp2 = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            let offset = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            println!(\"{} => p[0] == {} + p[{}]\", func, offset, cmp2);\n            let cmp1 = BV::new_const(&ctx, format!(\"p[{}]\", 0), 8);\n            let cmp2 = BV::new_const(&ctx, format!(\"p[{}]\", cmp2), 8);\n            let offset = BV::from_int(&Int::from_u64(&ctx, offset as u64), 8);\n            solver.assert(&cmp1._eq(&offset.add(&cmp2)));\n        } else if let Some(extracted) = eq_parse.captures_iter(check).next() {\n            let mut args = extracted.iter().skip(1);\n            let cmp1 = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            let cmp2 = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            println!(\"{} => p[{}] == p[{}]\", func, cmp1, cmp2);\n            let cmp1 = BV::new_const(&ctx, format!(\"p[{}]\", cmp1), 8);\n            let cmp2 = BV::new_const(&ctx, format!(\"p[{}]\", cmp2), 8);\n            solver.assert(&cmp1._eq(&cmp2));\n        } else if let Some(extracted) = eqimm_parse.captures_iter(check).next() {\n            let mut args = extracted.iter().skip(1);\n            let cmp = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            let value = u8::from_str(args.next().unwrap().unwrap().as_str()).unwrap();\n            println!(\"{} => {} == p[{}]\", func, value, cmp);\n            let cmp = BV::new_const(&ctx, format!(\"p[{}]\", cmp), 8);\n            let value = BV::from_int(&Int::from_u64(&ctx, value as u64), 8);\n            solver.assert(&cmp._eq(&value));\n        } else {\n            println!(\"No match found for {}\", func);\n        }\n    }\n    let mut pass = String::new();\n    match solver.check() {\n        SatResult::Sat => {\n            let model = solver.get_model().unwrap();\n            for i in 0..64 {\n                let c = model\n                    .eval(&BV::new_const(&ctx, format!(\"p[{}]\", i), 8))\n                    .unwrap()\n                    .as_u64()\n                    .unwrap() as u8 as char;\n                pass.push(c);\n            }\n        }\n        _ => {\n            eprintln!(\"Solver status was not SAT.\");\n            return;\n        }\n    }\n    println!(\"Password discovered: {}\", pass);\n}\n",
    "category": "reversing"
}