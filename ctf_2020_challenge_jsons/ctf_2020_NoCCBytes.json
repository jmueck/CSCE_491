{
    "a.out": "[Binary file or unsupported type: out]",
    "Dockerfile": "FROM ubuntu:16.04\n\nRUN apt update\nRUN apt install -y socat\n\nRUN groupadd ctf\n\nRUN mkdir /pwn\n\nCOPY entry.sh /entry.sh\nCOPY a.out /pwn/a.out\nCOPY flag.txt /pwn/flag.txt\n\nRUN useradd -G ctf --home=/pwn pwnuser\nRUN useradd -G ctf --home=/pwn pwnflag\n\nRUN chown pwnflag:pwnflag /pwn/flag.txt\nRUN chown pwnflag:pwnflag /pwn/a.out\n\nRUN chmod 4755 /pwn/a.out\nRUN chmod 444 /pwn/flag.txt\n\nEXPOSE 8188\nCMD [\"./entry.sh\"]\n",
    "entry.sh": "#!/bin/bash\n\nwhile :\ndo\n    su -c \"socat TCP4-listen:8188,reuseaddr,fork EXEC:/pwn/a.out\" - pwnuser\ndone\n",
    "flag.txt": "gigem{Y0urBreakpo1nt5Won7Work0nMeOnlyMon3y}\n",
    "OhExCeeCee.cpp": "//this file should never make it to master, just used for my own testing.\n#include <stdio.h>\n#include <iostream>\n#include <fstream>\n#include <string.h>\n\nbool checkFlag = 0;\nunsigned char globPass[25] = {'\\x46','\\x70','\\x65','\\x65','\\x7e','\\x42', '\\x70','\\x68','\\x62','\\x1b','\\x00'};\nbool passCheck(char* input);\n\nunsigned char* check(unsigned char* func){\n    //the check() function checks itself for the presence of breakpoints as well :)\n    if(func != (unsigned char*) check){\n        if (check((unsigned char*)check) != (unsigned char*)check){\n            return NULL;\n        }\n    }\n    unsigned char val = '\\x99';\n    unsigned char xorVal = '\\x11';\n    int i,j;\n    unsigned char *p = func;\n    //prints the first 64 bytes of the function\n    for (j=0; j<4; j++) {\n        //printf(\"\\n%p: \",p);\n        //iterate through lines of 16\n        for (i=0; i<16; i++){\n            //this does nothing except help obfuscate how the key is hidden.\n            xorVal += i * j;\n            *p++;\n            //printf(\"%.2x \", *p);\n            //printf(\"%.2x \",\"\\xcc\");\n            if ((*p ^ '\\x55') == val){\n                //printf(\"Found a breakpoint\\n\");\n                return NULL;\n            }\n            xorVal -= i*j;\n        }\n    }\n    //if we get here, we can decrypt the global password since there are no breakpoints.\n    for (int i = 0; i < sizeof(globPass); i++){\n        if(func == (unsigned char*) passCheck){\n            if (globPass[i] != '\\x00'){\n                globPass[i] = globPass[i] ^ xorVal;\n            }\n            else{\n                //do nothing\n            }\n        }\n    }\n    //Only gets here if no breakpoints\n    checkFlag =  1;\n    return func;\n}\nbool passCheck(char* input){\n    if (check((unsigned char*)passCheck) == (unsigned char*)passCheck){\\\n        //password = WattoSays\\n\n        unsigned char password[25] = {};\n        //copy the globalpass into our password\n        strcpy((char*)password, (char*)globPass);\n        if(strcmp((char*)input, (char*)password) == 0){\n            return true;\n        }\n        else{\n            printf(\"\\nWrong Password\\n\");\n\n            return false;\n        }\n    }\n    return false;\n}\n\nint main(int argc, char const *argv[]) {\n\n    setvbuf(stdout,0, _IONBF,0);\n    if(check((unsigned char*)main) == (unsigned char*)main){\n        printf(\"\\nWelcome. Please Enter a password to continue: \\n\");\n        char password[25];\n        fgets((char*)password, 25, stdin);\n        if (passCheck(password)){\n            FILE* infile = fopen(\"flag.txt\", \"r\");\n            if (infile == NULL){\n                printf(\"Too bad the flag is only on the remote server!\\n\");\n                return 0;\n            }\n            char output[100];\n            fgets(output, 100, infile);\n            printf(output);\n        }\n    }\n    else{\n\n    }\n    return 0;\n}\n",
    "password.txt": "WattoSays\n",
    "README.md": "# Anti-Debugging\nThis is a 2 stage problem:\n1. Getting around the anti-debugging mechanisms in place in the code. in this case, that comes in the form of checking for 0xCC bytes (breakpoints) in each running function when it is executed.\n2. After the attacker has managed to evade those mechanisms, then they will be able to view the stack during the checkPass function by setting breakpoints, where they will find the password: \"WattoSays\\n\".\n3. when they input the password, it will hint that they should put that password into our server, which will then read the flag from a file and print it if the password is correct.\n",
    "category": "Reversing"
}