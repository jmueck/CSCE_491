{
    ".gitignore": "target/\n.idea/\nvenv/",
    "Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\n[[package]]\nname = \"randomize\"\nversion = \"3.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"splatter-calc\"\nversion = \"0.1.0\"\ndependencies = [\n \"randomize 3.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[metadata]\n\"checksum randomize 3.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bd6f0f64ee91e11fe1b02debad386edc74c0eb815adde432733c014f1bff2a5f\"\n",
    "Cargo.toml": "[package]\nname = \"splatter-calc\"\nversion = \"0.1.0\"\nauthors = [\"Addison Crump <addisoncrump@tamu.edu>\"]\nedition = \"2018\"\n\n[dependencies]\nrandomize = \"3.0.0\"\n",
    "Dockerfile": "FROM rust:slim as build\n\nRUN USER=root cargo new --bin splatter-calc\nWORKDIR /splatter-calc\n\nCOPY Cargo.lock ./Cargo.lock\nCOPY Cargo.toml ./Cargo.toml\n\nCOPY src ./src\n\n# we need nightly for function \"references\", still experimental\nRUN rustup toolchain add nightly-x86_64-unknown-linux-gnu\nRUN cargo +nightly build --release\n\nFROM debian:buster-slim\nMAINTAINER Addison Crump \"addisoncrump@tamu.edu\"\n\nRUN apt update; apt -y --autoremove full-upgrade\nRUN apt -y install socat\n\n# copy the build artifact from the build stage\nCOPY --from=build /splatter-calc/target/release/splatter-calc /usr/bin/splatter-calc\nCOPY start.sh /usr/bin/server\nCOPY flag.txt /root/flag.txt\n\nWORKDIR /root\n\nEXPOSE 60032\n\n# set the startup command to run your binary\nCMD [\"/usr/bin/server\"]",
    "flag.txt": "gigem{00ps_ch3ck_y0ur_7upl35}",
    "README.md": "# Splattercalc\n\n```text\nReverse this binary to determine the input number required to read the flag on the remote server.\n```\n\n## Setup\n\n1. `docker build -t splatter-calc:latest .`\n2. `docker run --rm -d splatter-calc`\n3. `nc 172.17.0.2 60032`\n\nTo build the local binary, use `cargo build --release`. You can install cargo\n[here](https://rustup.rs/).\n\n## Brief Dev Description\n\nThis code uses a rather arcane feature of Rust (still \"experimental\") to invoke\nfunction pointers stored in an array. This behaviour is used along with a PRNG\nsystem to generate a number by invoking a function based on the current PRNG\nstate.\n\nThe result is the repeated modification of two values: the \"result\" value, which\nis modified by the function pointers themselves, and the \"state\" value, which is\nthe current state of the PRNG system.\n\nThe trick to solving this problem is the realisation that a) both the final\n\"result\" value and the \"state\" value are checked, b) the \"result\" value is not\nreversible, but the \"state\" value is, and c) only the \"state\" value needs to be\nreversed, as it implies the \"result\" value.\n\n## Solution\n\nAs this is a reversing challenge, I have provided an example reversing approach.\n\n### Finding `main`\n\nRust starts a little differently, so following it in with Ghidra:\n\n![](assets/_start.png)\n\nFollowing `main`...\n\n![](assets/main.png)\n\nFollowing `local8` (`h00...` can be interpreted as `__rustc_start_main`; this is\n  LLVM mangling, unavoidable)\n\n![](assets/namespacing_splatter_calc.png)\n\nSymbols window confirms that we have found the main method in the\nsplatter_calc namespace. We'll rename that to `actual_main`.\n\n### Finding Technique\n\nWe know by running it the first time that we get the output:\n```text\nPlease enter an initial rng: 1234\nOops, you didn't guess the right number. You got 8968822505825569188 with final state 17380140262299787378\n```\n\nWe learn a few things:\n - There's PRNG involved (we provide what is likely a seed value, as behaviour\n   is consitent between executions)\n - There are two values we get: some result value (unlabelled) and a state value\n - Input is taken from STDIN in a line format (we can look for `read_line` or\n   buffered reading), then parsed; we can find the uses of that parsed number\n\nUsing our handy-dandy symbol tree, we find the `stdin` namespace:\n\n![](assets/stdin_namespace.png)\n\nTracing the functions of the class `Stdin`, we find that stdin gets locked in\n`actual_main`.\n\n![](assets/stdin_lock.png)\n\nForward-slicing the result of that function (and thus finding the uses of that\n  lock) finds us this invocation:\n\n![](assets/lock_slice.png)\n\nWhich is passed to a function which, when followed...\n\n![](assets/locked_iter.png)\n\nreveals itself to be a `next` invocation on an internal iterator, implying the\nfollowing construct:\n\n```rust\n  std::io::stdin().lock().lines().next()\n```\n\nThis is a common construct for fetching the next line of standard input.\n\n`local_118`, which appears to be the result of this invocation, passes hands a\nfew times; it is trimmed (as `uVar3`) then parsed to a `u64` (as `local_130`).\nIf parsing fails, then 0 is used instead. This result is stored in `ppabVar1`.\n\n![](assets/line_parsing.png)\n\nThe next usage of `ppabVar1` begin a crypto-like technique.\n\n### Reversing the Cryptographic Technique\n\n`ppabVar1` gets used next to index the odd members an 16-member array stored at\n`local_b0`, which then gets offset by `0x18` and then invoked directly using the\neven member, `0xcafebabe` (a \"leetspeak\" number), and `ppabVar1`.\n\n![](assets/ppabVar1_indexing.png)\n\nLet's take a look at that array to get an idea of what we're looking at:\n\n![](assets/refarray.png)\n\nGiven the local offsets of 8-byte words and the global pointers, this looks like\nthe setup of a fixed-length Rust array of references. Additionally, if we follow\none of these global pointers (denoted by `PTR_...`)...\n\n![](assets/destruct_pointer.png)\n\nwe find a pointer to a [\"drop-in-place\" destructor](https://doc.rust-lang.org/std/ptr/fn.drop_in_place.html).\nIt's likely that we're looking at a [trait object vtable](https://huonw.github.io/blog/2015/01/peeking-inside-trait-objects/)\ngiven that, together, we see:\n\n![](assets/vtable.png)\n\nSo we've got an array of pointers to vtables -- neat. Effectively: an array of\nfunction pointers. Looks like the function used to modify some variable is being\nselected by `ppabVar1`.\n\nAdditionally, we have a recurring pattern of usage (likely an LLVM optimisation)\nwhere:\n - `uVar4` is set to `lVar6` (initially `ppabVar1`) % 8\n - `uVar3` is set to the result of the invocation of the `uVar4`-th function,\n   passed the parameters of `uVar3` (initially `0xcafebabe`) and `lVar6`\n - `lVar6` is set to `lVar6` * `0x83f66d0e3` + `0x24a452f8e`\n\n![](assets/pattern.png)\n\nThis pattern occurs 8 times (last time, `pabVar5` is used instead of `uVar3` and\n  `__ptr` is used instead of `lVar6`). Then we find the following if statement:\n\n![](assets/final_if.png)\n\nIf this check succeeds, a string to path function is invoked which converts\n\"flag.txt\" into a local path for file reading:\n\n![](assets/flag.txt.png)\n\nThat file is read to string in the statement immediately following as confirmed\nby the namespace (left to reader). Thus, if our entered number `ppabVar1` =>\n`lVar6` => `__ptr` and `0xcafebabe` => `uVar3` => `pabVar5` both match the\nnumbers in the if statement, then the `flag.txt` file is read and printed to the\nconsole (`local_118` is used by `std::io::stdio::_print` later).\n\n### Logic Time\n\nIt should be fairly obvious that both `lVar6` and `uVar3` are dependent on the\ninitial state (read: our entered value) and that it should always be the same;\nthis is confirmed by the consistency seen earlier by trialing the program.\n\n`uVar3` would be quite difficult to reverse, as its modifications depend on\nthe current state of `lVar6`. `lVar6`, however, uses a consistent modification\ntechnique throughout:\n\n```text\nlVar6 = lVar6 * 0x83f66d0e3 + 0x24a452f8e\n```\n\nThus, if we wanted to reverse lVar6, we'd want to do:\n\n```text\nlVar6 = (lVar6 - 0x24a452f8e) * 0x83f66d0e3^-1\n```\n\nSince `lVar6` is a 64-bit integer (it's a `long`), then each iteration must be\nconsidered mod 2^64. `0x83f66d0e3` => `35423441123`, and, since we're lazy, we\nuse Wolfram Alpha to calculate that [35423441123^-1 mod 2^64 =\n4882305260382647499](https://www.wolframalpha.com/input/?i=35423441123%5E-1+mod+2%5E64).\n\nOur reversal function is now:\n\n```text\nlVar6 = (lVar6 - 0x24a452f8e) * 4882305260382647499\n```\n\nWe apply this function 8 times from `lVar6 = 0x471de8678ae30ba1`:\n\n```rust\nfn main() {\n  let mut lVar6: u64 = 0x471de8678ae30ba1;\n\n  for _ in 0..8 {\n    lVar6 = lVar6.wrapping_sub(0x24a452f8e).wrapping_mul(4882305260382647499);\n  }\n\n  println!(\"{}\", lVar6);\n}\n```\n\nThis gets us the result `982730589345`, which, when we use it, gets:\n\n```text\n$ nc 172.17.0.2 60032\nPlease enter an initial rng: 982730589345\ngigem{00ps_ch3ck_y0ur_7upl35}\n```\n",
    "start.sh": "#!/bin/bash\n\nsocat -d -d tcp-l:60032,fork system:/usr/bin/splatter-calc",
    "assets\\destruct_pointer.png": "[Binary file or unsupported type: png]",
    "assets\\final_if.png": "[Binary file or unsupported type: png]",
    "assets\\flag.txt.png": "[Binary file or unsupported type: png]",
    "assets\\function_array.png": "[Binary file or unsupported type: png]",
    "assets\\line_parsing.png": "[Binary file or unsupported type: png]",
    "assets\\locked_iter.png": "[Binary file or unsupported type: png]",
    "assets\\lock_slice.png": "[Binary file or unsupported type: png]",
    "assets\\main.png": "[Binary file or unsupported type: png]",
    "assets\\namespacing_splatter_calc.png": "[Binary file or unsupported type: png]",
    "assets\\pattern.png": "[Binary file or unsupported type: png]",
    "assets\\ppabVar1_indexing.png": "[Binary file or unsupported type: png]",
    "assets\\refarray.png": "[Binary file or unsupported type: png]",
    "assets\\stdin_lock.png": "[Binary file or unsupported type: png]",
    "assets\\stdin_namespace.png": "[Binary file or unsupported type: png]",
    "assets\\vtable.png": "[Binary file or unsupported type: png]",
    "assets\\_start.png": "[Binary file or unsupported type: png]",
    "src\\main.rs": "#![feature(fn_traits)]\n\nuse std::fs::read_to_string;\n\nuse randomize::lcg64;\nuse std::io::{stdin, stdout, BufRead, Write};\n\nfn identity(res: u64, _state: u64) -> u64 { res }\n\nfn plus(res: u64, state: u64) -> u64 { res.wrapping_add(state) }\n\nfn minus(res: u64, state: u64) -> u64 { res.wrapping_sub(state) }\n\nfn mult(res: u64, state: u64) -> u64 { res.wrapping_mul(state as u64) }\n\nfn square(res: u64, _state: u64) -> u64 { res.wrapping_mul(res) }\n\nfn lshift(res: u64, state: u64) -> u64 { res.wrapping_shl((state % 64) as u32) }\n\nfn rshift(res: u64, state: u64) -> u64 { res.wrapping_shr((state % 64) as u32) }\n\nfn xor(res: u64, state: u64) -> u64 { res ^ (state as u64) }\n\nfn splattercalc(mut res: u64, mut state: u64, functions: &[&dyn Fn(u64, u64) -> u64; 8]) -> (u64, u64) {\n    for _ in 0..8 {\n        res = functions[(state % 8) as usize].call((res, state));\n//        println!(\"{} => {}\", state % 8, res);\n        state = lcg64(state, 35423441123, 9835982734);\n    }\n\n    return (res, state);\n}\n\nfn main() {\n    let functions: [&dyn Fn(u64, u64) -> u64; 8] = [\n        &identity,\n        &plus,\n        &minus,\n        &mult,\n        &square,\n        &lshift,\n        &rshift,\n        &xor\n    ];\n\n    print!(\"Please enter an initial rng: \");\n    stdout().lock().flush().unwrap();\n    let state = stdin().lock().lines().next().unwrap().unwrap().trim().parse::<u64>().unwrap_or_else(|_| {\n        println!(\"Couldn't read a 64-bit integer from input, defaulting to 0...\");\n        0\n    });\n\n    match splattercalc(0xcafebabe, state, &functions) {\n        (12456643129164290182, 5124507482426903457) => println!(\"{}\", read_to_string(\"flag.txt\").unwrap()),\n        (res, state) => println!(\"Oops, you didn't guess the right number. You got {} with final state {}\", res, state)\n    }\n\n}\n",
    "category": "Reversing"
}