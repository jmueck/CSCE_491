{
    "capture.pcap": "[Binary file or unsupported type: pcap]",
    "README.md": "## Challenge\nRecently, the office put up a private webserver to store important information about the newest research project for the company. This information was to be kept confidential, as it's release could mean a large loss for everyone in the office.\n\nJust as the research was about to be published, a competing firm published information eerily similar. Too similar...\n\nTime to take a look through the office network logs to figure out what happened.\n\n1. Network Enumeration:\n   1. What is the IP address of the private webserver?\n   2. How many hosts made contact with the private webserver that day?\n\n2. Discovering an Event:\n   1. What is the IP address of the host exfiltrating data?\n   2. For how long did the exfiltration happen? (Round to the nearest second. Format: MM:SS) \n   3. What protocol/s was used to exfiltrate data? (Alphabetical order, all caps, comma separated)\n\n3. Assessing of File:\n   1. What is the name of the stolen file?\n   2. What is the md5sum of the stolen file?\n\n4. Retrieving the Stolen Data:\n   1. What compression encoding was used for the data?\n   2. What is the name and type of the decompressed file? (Format: NAME.TYPE e.g. tamuctf.txt)\n\n## CTFd\nEach logical grouping for the questions should be revealed after the previous logical grouping is completely answered.\n\n## Solution\n* Use the filter ```ip.src == 192.168.11.4 && ip.dst == 192.168.11.7 && (dns or http or icmp)``` in wireshark or using ```tshark -r capture.pcap -Y \"<FILTER HERE>\" -w newfile.pcap``` and save the file as newfile.pcap\n* In the very first packet of newfile.pcap, hex decode ICMP data. This will show ```SEx4IRV.746f74616c6c795f6e6f7468696e672e706466.REGISTER.6156eab6691f32b8350c45b3fc4aadc1```. Hex decode the hex data between the first and second dots for the filename. The Hex data at the end after the 3rd dot is the md5sum.\n* Run ```python3 solver.py```\n* Decompress using ```tar -xzvf transferredData.tar.gz``` \n* Use ```file``` or ```binwalk``` to determine compression and filetype\n\n## Answers\n1.\n   1. 192.168.11.4\n   2. 13\n2.\n   1. 192.168.11.7\n   2. 11:09    (23:35:49.285991 - 23:24:40.525678)\n   3. DNS, HTTP, ICMP\n3.\n   1. totally_nothing.pdf\n   2. 6156eab6691f32b8350c45b3fc4aadc1\n4.\n   1. gzip\n   2. stuff.elf\n",
    "solver.py": "from scapy.all import *\n\npackets = rdpcap('newfile.pcap')\ntheData = []\nbuf = []\n\ndef getHTTPData(packet):\n    allData = packet.load[packet.load.find('data=')+5:].decode('hex')\n    theData.append(allData)\n\ndef getICMPData(packet):\n    allData = packet[ICMP].load.decode('hex')\n    theData.append(allData)\n\ndef getDNSData(packet):\n    global buf\n    dnsqr = packet[DNSQR].qname\n    data = dnsqr.split(\".\")[1]\n    jobid = dnsqr.split(\".\")[0]\n    if jobid in data.decode('hex'):\n        buf = []\n    if data not in buf:\n        buf.append(data)\n    if(len(dnsqr) < 68):\n        theData.append(''.join(buf).decode('hex'))\n\nfor packet in packets:\n    if 'http' in packet.summary():\n        retriever = getHTTPData\n    if packet.haslayer(ICMP):\n        retriever = getICMPData\n    if packet.haslayer(DNSQR):\n        retriever = getDNSData\n    retriever(packet)\n\nfileData = \"\"\nfor data in theData:\n    splitData = data.split('.')\n    if splitData[2] != 'REGISTER' and splitData[2] != 'DONE':\n        fileData += data.split('.')[2]\n\nf = open('transferredData.tar.gz','w')\nf.write(fileData.decode('hex'))\nf.close()\n",
    "category": "Scenarios"
}