{
    ".gitignore": "about_time\n.venv/\n",
    "about_time.c": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<time.h>\n#include<signal.h>\n#include<unistd.h>\n#define RANDBOOL (rand() % 2)\n\nstruct Decisions\n{\n\tint value;\n\tchar password[50];\n} decision;\n\nchar flag[50];\nchar encrypted_flag[50];\n\nvoid rot(char *string, int value){\n\tfor(int x = 0; x < strlen(string); x = x + 3){\n\t\tif(string[x] >= 'a' && string[x] <= 'z'){\n\t\t\tstring[x] = (((string[x]-'a')+13+value) % 26) + 'a';\n\t\t}\n\t\tif(string[x] >= 'A' && string[x] <= 'Z'){\n\t\t\tstring[x] = (((string[x]-'A')+13+value) % 26) + 'A';\n\t\t}\n\t}\n}\n\nvoid shift(char *string, int value){\n\tchar temp_pass[50];\n\tstrncpy(temp_pass,string,50);\n\tint length = strlen(string);\n\tfor(int x = 0; x < length; x++){\n\t\tstring[x] = temp_pass[(x + value) % length];\n\t}\n}\n\nvoid add(char *string, int value){\n\tchar temp;\n\tint length = strlen(string);\n\tfor(int x = 0; x < length; x++){\n\t\tif(string[x] >= '0' && string[x] <= '9'){\n\t\t\tstring[x] = string[x] + value;\n\t\t}\n\t}\n}\n\n\n\nvoid check_pass(char *pass, char *input){\n\tif(strcmp(pass,input) == 0){\n\t\tprintf(\"Correct! Here you go: gigem{%s}\\n\",flag);\n\t\tfflush(stdout);\n\t}\n\telse{\n\t\tprintf(\"Incorrect password! Try again.\\n\");\n\t\tfflush(stdout);\n\t}\n}\n\nvoid sigHandler(int sig_num){\n\tif(RANDBOOL) {\n\t\tflag[0] = '\\0';\n\t}\n\tif(RANDBOOL) {\n\t\tdecision.value = rand();\n\t}\n\tif(RANDBOOL) {\n\t\tdecision.password[0] = '\\0';\n\t}\n\tif(RANDBOOL) {\n\t\tencrypted_flag[0] = '\\0';\n\t}\n}\n\nint main(){\n\t//signal handler\n\tsignal(SIGALRM,sigHandler);\n\talarm(5);\n\n\t//seed rand\n\tsrand(time(0));\n\n\t//get time for decision value\n\ttime_t start_time = time(NULL);\n\tstruct tm *loc_time = localtime(&start_time);\n\tchar time[5];\n\tchar full_time[50];\n\tstrftime(full_time,50,\"%Y-%m-%dT%H:%M:%S%Z\",loc_time);\n\tstrftime(time,5,\"%M\",loc_time);\n\tdecision.value = ((atoi(time) % 6) + 2);\n\tint value = decision.value;\n\n\n\t//get flag from file\n\tFILE *flag_file;\n\tif((flag_file = fopen(\"flag.txt\",\"r\")) != NULL){\n\t\tfgets(flag,50,flag_file);\n\t\tfclose(flag_file);\n\t} else {\n\t\tprintf(\"Flag.txt not found. Exiting...\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i < strlen(flag); i++){\n\t\tif(flag[i] == '\\n'){\n\t\t\tflag[i] = '\\0';\n\t\t}\n\t}\n\tstrncpy(encrypted_flag,flag,50);\n\n\t//setup function pointers\n\tvoid (*fun_ptr[])() = {rot,shift,add};\n\n\t//run encryption on flag\n\t(*fun_ptr[value % 3])(encrypted_flag,value);\n\t(*fun_ptr[(value + 1) % 3])(encrypted_flag,value);\n\t(*fun_ptr[(value + 2) % 3])(encrypted_flag,value);\n\n\tprintf(\"%s> Encrypted password: %s\\n\",full_time,encrypted_flag);\n\tfflush(stdout);\n\n\t//get password from CLI user\n\tprintf(\"Enter the password: \");\n\tfflush(stdout);\n\tfgets(decision.password,50,stdin);\n\tfor(int i = 0; i < strlen(decision.password); i++){\n\t\tif(decision.password[i] == '\\n'){\n\t\t\tdecision.password[i] = '\\0';\n\t\t}\n\t}\n\n\t//run encryption on input\n\t(*fun_ptr[value % 3])(decision.password,value);\n\t(*fun_ptr[(value + 1) % 3])(decision.password,value);\n\t(*fun_ptr[(value + 2) % 3])(decision.password,value);\n\n\tcheck_pass(encrypted_flag,decision.password);\n\treturn 0;\n}\n",
    "build.sh": "#!/bin/bash\n\ndocker build -t about-time-builder -f Dockerfile.build .\ndocker run --rm -ti --mount \"type=bind,source=$(pwd),target=/tmp/build\" about-time-builder sh -c \"cd /tmp/build; gcc -s -o about_time about_time.c\"\n\ndocker build --rm -t about-time .\n",
    "Dockerfile": "FROM alpine\n\nRUN apk add --update socat\n\nRUN addgroup -S ctf\n\nRUN mkdir /rvrs\n\nCOPY about_time /rvrs/about_time\nCOPY flag.txt /rvrs/flag.txt\nCOPY entry.sh /rvrs/entry.sh\n\nRUN adduser -SDHG ctf rvrsuser\nRUN addgroup -S rvrsflag\nRUN adduser -SDHG ctf -G rvrsflag --home=/rvrs rvrsflag\n\nRUN chown rvrsflag:rvrsflag /rvrs/flag.txt\nRUN chown rvrsflag:rvrsflag /rvrs/about_time\nRUN chown rvrsflag:rvrsflag /rvrs\n\nRUN chmod 4755 /rvrs/about_time\nRUN chmod 444 /rvrs/flag.txt\nRUN chmod 4755 /rvrs/entry.sh\n\nWORKDIR /rvrs\n\nEXPOSE 4321\nENTRYPOINT [\"su\", \"-s\", \"/bin/sh\", \"-c\", \"/rvrs/entry.sh\", \"rvrsuser\"]\n",
    "Dockerfile.build": "FROM alpine\n\nRUN apk add --update alpine-sdk\n",
    "entry.sh": "#!/bin/sh\n\nwhile : \ndo\n    socat TCP-LISTEN:4321,reuseaddr,fork EXEC:/rvrs/about_time,stderr\ndone\n",
    "flag.txt": "1tsAbOut7iMet0geTaw47CH\n",
    "Makefile": "all:\n\tgcc -o about_time -s about_time.c\n\nclean:\n\trm about_time\n",
    "README.md": "# It's about time...\nLet's see if you can figure out this password..\n\nUse the following command to connect to the server and interact with the binary!\n\n\tnc <host> <ip>\n\n## Setup\nProvide the binary to the user and let them know the hostname/port to connect to via netcat.\nBuild the docker container\n\n        docker build -t about_time .\n\nThen run it\n\n\tdocker run -it --rm -p 4321:4321 about_time\n\n## Solution\nThe provided solution.py script is commented and can be used to solve the challenge.\n\n\nTo get started first we're gonna just run the binary. It prints out a prompt that includes the datetime as well as a password that is encrypted.\nAfter running it a few times, you'll notice that the encrypted password changes every so often. Let's take a look at the binary in a disassembler to see if we can get a good idea of what is going on...\n\n\nI like to use Ghidra, and the first thing to notice is that there are no symbols loaded - it's a stripped binary. This means that we can't just jump to main and start looking at the disassembly. However, it's still relatively simple to find the address of main.\n\n![Libc Start Main](images/libc_start_main.png)\n\nIn the __libc_start_main function, we can see that FUN_00100ebe is the first argument. This is the \"main\" function of the binary. I'm gonna rename that function to \"main\" in Ghidra.\n\nAt the beginning of the function, a signal handler is set to handle 0xe, which is SIGALRM. Looks like it is set to alarm for 5 seconds with the function FUN_00100e60.\n\n![FUN_00100e60](images/FUN_00100e60.PNG)\n\nLooks like it sets values to null and random. It is a function that messes with the binary after 5 seconds to increase debugging difficulty. Ignore this.\n\nNext in main, the program writes the datetime into a variable as well as just the current minute into a variable. The minute is converted to an integer in the equation (minute % 6) + 2, which is stored into a global variable that I will call \"minute\".\nIt looks like it then reads the flag from a text file into a global variable that is stripped of its newline character and copied into another global variable. I have renamed the variables to indicate such.\n\n![flag_file](images/flag_file.PNG)\n\nIn the next part, we see an array being assigned pointers to 3 different functions\n\n![encryption functions](images/encryption.PNG)\n\nYou can see that right afterwards, all 3 functions are being called. However, the order in which they are called is determined by the \"minute_local\" variable, which is the same thing as the \"minute\" variable described above. It calls each of these with these arguments - a pointer to the copied_flag and the value of the minute variable.\nIt should look something like this:\n\n\tfunction_array = [fun1,fun2,fun3]\n\tfunction_array[minute % 3](&copied_flag,minute)\n\tfunction_array[(minute + 1) % 3](&copied_flag,minute))\n\tfunction_array[(minute + 2) % 3](&copied_flag,minute))\n\nThe main function then prints out the encrypted copied_flag, gets the user prompt, then follows the same algorithms to encrypt the users input. Let's look at each of the functions in the array\n\n![Fun1](images/fun1.PNG)\n\nThe first function looks like it iterates over the input string in the first argument and applies some operation on each character. One thing to note is that it iterates over every 3rd element.\n\nIn the screenshot, it shows that it is checking for characters inbetween '`' and '{' as well as '@' and '['. It may be just because of the way the compiler does things, but this is actually checking to see if its in the ranges 'a'-'z' and 'A'-'Z'.\nIf so, it adds -0x54 + minute (or -0x34 + minute) to the character, then does a divide/multiply by 26 (which is the modulus operation) and then adds 'a' or 'A'\nIf you think about it, this is simply rotating the character through the alphabet. A cesar cipher that depends on the value of minute.\n\n\tcheck the solution script for an example of how to reverse that cipher\n\n![Fun2](images/fun2.PNG)\n\nThe second function again iterates through the argument 0 char array. This one simply assigns each value to another offset from the copied array. Simply put, it rotates the entire array by the offset defined by the minute variable.\n\n\tcheck the solution script for an example of how to reverse this\n\n![Fun3](images/fun3.PNG)\n\nThe third and final function iterates through the char array again. This time it checks for values between '/' and ':', which is actually '0' and '9'. If so, it adds the value of 'minute' to the char at that index. Pretty simple.\n\n\tcheck the solution script for an example of how to reverse this\n\nAt the end, it calls another function that takes the encrypted flag and your encrypted input as arguments. If they are the same, then it prints out the flag.\n\nNow, we put the reverse of each of those functions and then perform them in the reverse ordering, again depending on the value of minute. The solution script provided shows how to do so.\n\n",
    "solution.py": "import datetime\nfrom pwn import *\n\ndef decrypt1(encrypted, value):\n    #undo character alphabet rotation\n    decrypted = ''\n    for i,char in enumerate(encrypted):\n        if i % 3 == 0:\n            if ord(char) >= ord('a') and ord(char) <= ord('z'):\n                decrypted += chr((((ord(char)-ord('a'))+13-value) % 26) + ord('a'))\n            elif ord(char) >= ord('A') and ord(char) <= ord('Z'):\n                decrypted += chr((((ord(char)-ord('A'))+13-value) % 26) + ord('A'))\n            else:\n                decrypted += char\n        else:\n            decrypted += char\n    return decrypted\n\ndef decrypt2(encrypted, value):\n    #undo the array rotation\n    newval = len(encrypted) - value\n    return encrypted[newval:] + encrypted[:newval]\n\ndef decrypt3(encrypted, value):\n    #undo the numeral addition\n    decrypted = ''\n    for i,char in enumerate(encrypted):\n        #make note that the source binary adds to the numerals.\n        #This means that they can be characters not between '0' and '9'\n        if ord(char) >= ord('0') and ord(char) < ord('A'):\n            decrypted += chr(ord(char) - value)\n        else:\n            decrypted += char\n    return decrypted\n\n#connect\np = remote('localhost',4321)\n\n#read prompt\noriginal = p.read().decode().split(' ')\n\n#the minute section is important in making decisions\n#use the time given by the server, as your time might be slightly different than the server time\nminute = int(original[0].split('T')[1].split(':')[1])\nvalue = (minute % 6) + 2\n\n#get the encrypted password\nencrypted = original[3].split('\\n')[0]\n\n#setup function pointer array\nfun_ptr = [decrypt1,decrypt2,decrypt3]\n\n#go backwards through the encryption process seen in the binary.\nintermediate1 = fun_ptr[(value + 2) % 3](encrypted,value)\nintermediate2 = fun_ptr[(value + 1) % 3](intermediate1,value)\ndecrypted = fun_ptr[value % 3](intermediate2,value)\n\n#send password and get flag\np.send(decrypted + '\\n')\nprint(p.read())\n\n",
    "images\\encryption.PNG": "[Binary file or unsupported type: png]",
    "images\\flag_file.PNG": "[Binary file or unsupported type: png]",
    "images\\fun1.PNG": "[Binary file or unsupported type: png]",
    "images\\fun2.PNG": "[Binary file or unsupported type: png]",
    "images\\fun3.PNG": "[Binary file or unsupported type: png]",
    "images\\FUN_00100e60.PNG": "[Binary file or unsupported type: png]",
    "images\\libc_start_main.png": "[Binary file or unsupported type: png]",
    "category": "Reversing"
}