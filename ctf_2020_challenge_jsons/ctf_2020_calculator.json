{
    "docker-compose.yml": "version: '2.4'\n\nx-limits: &limits\n    pids_limit: 1024\n    cpu_shares: 256\n    mem_limit: 512m\n    logging:\n        options:\n            max-size: 10m\n            max-file: '3'\n\nservices:\n    shell:\n        <<: *limits\n        build:\n            context: ./shell\n            args:\n                USERNAME: alice\n                PASSWORD: \"58318008\"\n                CTF_FLAG: gigem{f5ae5f528ed5a9ad312f75bd1d3406a2}\n        image: naumachia/calculator.shell\n        cap_add:\n            - NET_BIND_SERVICE\n        networks:\n            default:\n                ipv4_address: 172.30.0.2\n        restart: unless-stopped\n\n    client:\n        <<: *limits\n        build: ./client\n        image: naumachia/calculator.client\n        environment:\n            SHELL_USER: alice\n            SHELL_PASS:  \"58318008\"\n        networks:\n            default:\n                ipv4_address: 172.30.0.3\n        restart: unless-stopped\n\nnetworks:\n    default:\n        driver: l2bridge\n        ipam:\n            driver: static\n            config:\n                - subnet: 172.30.0.0/28\n",
    "README.rst": "===========\nStraw House\n===========\n\nIn a land far far away there was an old mother pig who had `three little pigs <https://americanliterature.com/childrens-stories/the-three-little-pigs>`_ and not enough cpu cores in her server to host them. So when they were old enough, she sent them out into the world to seek their fortunes.\n\nThe first little pig was very lazy and secured his server by not telling anyone about it. Honestly a wolf wouldn't need to huff and puff so much as sniff his way into the server.\n",
    "client\\Dockerfile": "FROM python:3-alpine\n\nCOPY ./app ./app\nCMD [\"python\", \"-m\", \"app\"]\n",
    "client\\app\\client.py": "from .telnetbot import TelnetBot\nfrom os import environ\nimport itertools\nimport logging\nimport random\nimport time\n\nHOST = environ.get('SHELL_HOST', 'shell')\nUSER = environ.get('SHELL_USER', 'noob')\nPASSWD = environ.get('SHELL_PASS', 'noob')\nNAUMOTP_SECRET = environ.get('NAUMOTP_SECRET', None)\nHUMANISH = environ.get(\"HUMANISH\", \"true\").lower() == \"true\"\n\nDELAY_MEAN = 3\nDELAY_VAR = 0.6\nDELAY_INITIAL = 10\nACTION_MAX = 5\n\nlogger = logging.getLogger(\"client\")\nlogging.basicConfig(level=environ.get('LOG_LEVEL', 'info').upper())\n\ndef randnumber(decay):\n    number = 0\n    for i in itertools.count():\n        if random.random() > decay ** i:\n            break\n        number += random.randrange(10) * (10**i)\n    return number\n    \ndef randterms(alpha, beta):\n    for i in itertools.count():\n        if random.random() > alpha ** i:\n            return\n        yield randnumber(beta)\n\ndef randexpr(alpha, beta, seed=None):\n    \"\"\"Generate simple random expression of plus, minus, and multiply\n    \n    Args:\n        alpha (float): Decay for the number of terms\n        beta (float): Decay for the number of digits in each term\n        seed (int): Seed term to start the expression\n    \"\"\"\n    terms = tuple(randterms(alpha, beta))\n    if seed is not None:\n        terms = (seed,) + terms\n    \n    for term in terms[:-1]:\n        yield str(term)\n        yield random.choice('-+*')\n    yield str(terms[-1])\n\ndef randexprstr(alpha=0.8, beta=0.8, seed=None):\n    return ' '.join(randexpr(alpha, beta, seed=seed))\n\ndef delay(mu=DELAY_MEAN, sigma=DELAY_VAR):\n    length = abs(random.gauss(mu, sigma))\n    time.sleep(length)\n\ndef session():\n    with TelnetBot(HOST, USER, PASSWD, naumotp_secret=NAUMOTP_SECRET, humanish=HUMANISH) as shell:\n        shell.login()\n        logger.info(f\"Logged in to {HOST} as {USER} with {PASSWD}\")\n        delay()\n\n        ret = None\n        for _ in range(random.randrange(1, ACTION_MAX)):\n            expr = randexprstr(seed=ret)\n            ret = shell.bc(expr)\n            logger.info(f\"Calculated {expr} = {ret}\")\n            delay()\n\ndef main():\n    logger.info(\"Telnet shell host is '{0}'\".format(HOST))\n\n    while True:\n        try:\n            if DELAY_INITIAL > 0:\n                logger.info(f\"Waiting {DELAY_INITIAL} seconds to start\")\n                time.sleep(DELAY_INITIAL)\n            session()\n        except ConnectionErrror:\n            logger.exception(\"Connection error in interaction loop\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "client\\app\\telnetbot.py": "from binascii import hexlify, unhexlify\nfrom datetime import datetime\nfrom hashlib import sha256\nfrom os import path, environ, getenv\nfrom telnetlib import Telnet\nimport hmac\nimport itertools\nimport logging\nimport random\nimport re\nimport string\nimport sys\nimport time\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=environ.get('LOG_LEVEL', 'info').upper())\n\ndef timepoints(mu, sigma):\n    acc = time.time()\n    while True:\n        yield acc\n        acc += random.gauss(mu, sigma)\n\ndef humantype(text, mu=0.3, sigma=0.05):\n    for (ch, schedule) in zip(text, timepoints(mu, sigma)):\n        yield ch\n        time.sleep(max(schedule - time.time(), 0))\n        \nclass TelnetTimeoutError(ConnectionError):\n    def __init__(self, msg=\"telnet connection took too long to respond\"):\n        self.msg = msg\n\n    def __str__(self):\n        return \"TelnetTimoutException: {msg}\".format(msg=self.msg)\n\nclass TelnetBot:\n    \"\"\"\n    An interface for issuing and interpretting commands over telnet\n    \"\"\"\n    port = 23\n    retry_period = 5\n    retry_count = 5\n\n    def __init__(self, host, user=None, passwd=None, timeout=10, naumotp_secret=None, humanish=True):\n        self.connected = False\n        self.loggedin = False\n        self.host = host\n        self.user = user\n        self.passwd = passwd\n        self.timeout = timeout\n        self.naumotp_secret = naumotp_secret\n        self.humanish = humanish\n\n        if isinstance(self.naumotp_secret, str):\n            self.naumotp_secret = self.naumotp_secret.encode('utf-8')\n\n        self.connect()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.write(\"exit\\n\")\n        self.conn.close()\n\n    def connect(self):\n        for i in range(self.retry_count + 1):\n            start_time = time.time()\n            try:\n                self.conn = Telnet(self.host, self.port, self.timeout)\n            except Exception as e: # Catch all errors: not very precise, but it shouldn't be an issue\n                logger.info(\"Connect to shell server failed due to '{0}'\".format(e))\n                elapsed = time.time() - start_time\n                remaining = self.retry_period - elapsed\n                logger.debug(\"Retrying in {0:.2f}s\".format(remaining))\n                if remaining > 0: time.sleep(remaining)\n                if i == self.retry_count: raise\n            else:\n                self.connected = True\n\n\n    def login(self):\n        self.read_until(\"login: \")\n        self.write(\"{0}\\n\".format(self.user))\n\n        self.read_until(\"Password: \")\n        self.write(\"{0}\\n\".format(self.passwd))\n\n        index, match, _ = self.expect([r'\\$ ', r'challenge \\[(?P<chal>[0-9a-f]+)\\]'])\n        if index == 0:\n            self.loggedin = True\n\n        elif index == 1:\n            if self.naumotp_secret is None:\n                raise ValueError(\"Encountered naumotp challenge without a secret to compute the HMAC\")\n\n            resp = hexlify(hmac.new(self.naumotp_secret, unhexlify(match[\"chal\"]), digestmod=sha256).digest())\n\n            self.read_until(\"response: \")\n            self.write(\"{0}\\n\".format(resp.decode('utf-8')), humanish=False)\n\n            index, _, _ = self.expect([r'\\$ '])\n            if index == 0:\n                self.loggedin = True\n\n    def expect(self, patterns):\n        for i, pattern in enumerate(patterns):\n            if isinstance(pattern, str):\n                patterns[i] = pattern.encode('utf-8')\n\n        index, match, text = self.conn.expect(patterns, self.timeout)\n\n        try:\n            logger.debug(text.decode('utf-8'))\n        except UnicodeDecodeError:\n            pass\n\n        if index == -1:\n            raise TelnetTimeoutError()\n        else:\n            return index, match, text.decode('utf-8')\n\n    def read_until(self, expected):\n        if isinstance(expected, str):\n            expected = expected.encode('utf-8')\n\n        text = self.conn.read_until(expected, self.timeout)\n\n        try:\n            result = text.decode('utf-8')\n            logger.debug(result)\n        except UnicodeDecodeError:\n            result = None\n\n        if not text.endswith(expected):\n            raise TelnetTimeoutError()\n        else:\n            return result\n\n    def write(self, text, humanish=None):\n        if isinstance(text, str):\n            text = text.encode('utf-8')\n\n        try:\n            logger.debug(text.decode('utf-8'))\n        except UnicodeDecodeError:\n           pass\n\n        if humanish is None:\n            humanish = self.humanish\n\n        if humanish:\n            for ch in humantype(text):\n                self.conn.write(bytes((ch,)))\n        else:\n            self.conn.write(text)\n\n    def bc(self, expr):\n        self.write(f\"bc <<< '{expr}'\\n\")\n        return int(self.read_until(\"$ \").splitlines()[-2])\n\n    def date(self):\n        self.write(f\"date\\n\")\n        return self.read_until(\"$ \").splitlines()[-2]\n",
    "client\\app\\__init__.py": "",
    "client\\app\\__main__.py": "from .client import main\n\nif __name__ == \"__main__\":\n    main()\n",
    "shell\\Dockerfile": "FROM ubuntu:xenial\n\nRUN apt-get -y update \\\n    && apt-get -y install xinetd telnetd bc\n\nARG USERNAME\nARG PASSWORD\nARG CTF_FLAG\n\nRUN useradd -Um $USERNAME && \\\n    printf \"${PASSWORD}\\n${PASSWORD}\" | passwd $USERNAME\n\nRUN cd /home/$USERNAME && \\\n    echo \"$CTF_FLAG\" > .ctf_flag\n\nCOPY ./etc/* /etc/\n\nEXPOSE 23\nCMD [\"xinetd\", \"-dontfork\", \"-inetd_compat\"]\n",
    "shell\\etc\\hostname": "calculator\n",
    "shell\\etc\\inetd.conf": "telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd\n",
    "category": "NetworkPentest"
}