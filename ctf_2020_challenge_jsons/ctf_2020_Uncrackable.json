{
    "encrypt.py": "ans = ''\nsecret = 0x849182746352\n\nwith open('flag.txt', 'r') as flag_file:\n    flag = flag_file.read().rstrip('\\r\\n').encode('utf-8')\n    t = len(flag)\n    flag = flag.hex()\n    for i in range(t//6):\n        print(hex(secret^int(flag[12*i:12*i+12], 16))[2:], end='')\n    print()\n\n",
    "flag.txt": "gigem{1m_n3w_t0_cRypTo_okaYyY}\n",
    "README.md": "# Uncrackable\n\n## Description\n\ne3f8e5110e29e6fde31a0861f0a4dd13530db5ffdd17113be6c2dd1c022f\n\n## Documentation\n\nSimple XOR cipher (key length is 6).\n\n### Setup\n\nJust put the description above (this is all that is needed for the challenge).\n\n## Solution\n\nJust guess that the first 6 will be gigem{ and you'll get a XOR key of length 6 that works.\n\nAn example of this is in `solve.rs`:\n```\nrustc solve.rs\nfor i in $(echo \"e3f8e5110e29e6fde31a0861f0a4dd13530db5ffdd17113be6c2dd1c022f\" | fold -w2 | paste -sd' ' -); do printf \"\\x$i\"; done | ./solve\n```\n",
    "solve.rs": "use std::io::Read;\nuse std::error::Error;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let mut key = vec!['g' as u8, 'i' as u8, 'g' as u8, 'e' as u8, 'm' as u8, '{' as u8];\n    let mut index = 0;\n    for byte in std::io::stdin().lock().bytes() {\n        key[index] = key[index] ^ byte?;\n        index += 1;\n        if index == key.len() {\n            break;\n        }\n    }\n    index = 0;\n    print!(\"gigem{{\");\n    for byte in std::io::stdin().lock().bytes() {\n        print!(\"{}\", (key[index] ^ byte?) as char);\n        index = (index + 1) % key.len();\n    }\n    println!();\n    Ok(())\n}\n",
    "category": "Crypto"
}