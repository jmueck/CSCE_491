{
    "merklehellman.py": "#Python file for Merkle-Hellman Implementation\n\n#Function used to encrypt message\ndef encrypt(message):\n    serverPublicKey = [99, 1235, 865, 990, 5, 1443, 895, 1477]\n    cipherText = \"\"\n    for c in message:\n        temp = ord(c)\n        s = '{0:08b}'.format(temp)\n        i = 7\n        num = 0\n        for ch in s:\n            if ch == '1':\n                num += serverPublicKey[i]\n\n            i-=1\n                \n        cipherText += format(num, '04x')\n        \n    return cipherText\n\n\n#Function used to get a powerset of a set\ndef powerSet(s):\n    x = len(s)\n    ps = []\n    for i in range(1 << x):\n        ps.append([s[j] for j in range(x) if (i & (1 << j))])\n\n    return ps\n\n\n\n#BruteForce Knapsack Encryption\ndef bruteForceKnapsack(cipherText, pk):\n    i = 1\n    sets = powerSet(pk)\n\n    cipherList = [''.join(t) for t in zip(*[iter(cipherText)]*4)]\n    message = \"\"\n    for c in cipherList:\n        num = int(c,16)\n        p = 0\n        found = False\n        while not found:\n            guess = sum(sets[p])\n            if guess == num:\n                asciiVal = \"\"\n                curr = 7;\n                while curr >= 0:\n                    if pk[curr] in sets[p]:\n                        asciiVal += \"1\"\n                        curr -= 1\n                    else:\n                        asciiVal += \"0\"\n                        curr -= 1\n\n                \n                message += chr(int(asciiVal,2))\n                found = True\n            else:\n                p += 1\n\n    return message\n\n\n\n#Decrypt Knapsack Algorithm using Private Key\ndef decrypt(cipherText):\n    \n    cipherList = [''.join(t) for t in zip(*[iter(cipherText)]*4)]\n    message = \"\"\n    privateKey = [3, 7, 11, 30, 61, 135, 377, 851]\n    n = 1037\n    m = 1506\n    inverse_n = 1217\n\n    for c in cipherList:\n\n        num = int(c,16)\n        temp = (num*inverse_n)%m\n        asciiVal = \"\"\n        curr = 7\n        while temp > 0:\n            if temp >= privateKey[curr]:\n                asciiVal += \"1\"\n                temp -= privateKey[curr]\n            else:\n                asciiVal += \"0\"\n\n            curr -= 1\n\n        while len(asciiVal) < 8:\n            asciiVal += \"0\"\n            \n        message += chr(int(asciiVal,2))\n            \n        \n    return message\n\n\npublicKey = [99, 1235, 865, 990, 5, 1443, 895, 1477]\nsuperIncreasing = [3, 7, 11, 30, 61, 135, 377, 851]\n\nflag = encrypt(\"gigem{merkle-hellman-knapsack}\")\nprint(flag)\n\n\nmessage = bruteForceKnapsack(flag, publicKey)\nprint(message)\n",
    "README.md": "# Weakness of Knapsack Cryptosystems\nEasy / Medium depending on programming proficiency.\n\n## Description: \nFor the most part, this challenge shows that someone fully understands how the MerkleHellman\ncryptosystem works, as well as the fundamentals of knapsack based crypto systems. The\nchallenge demonstrates the fundamental weakness of knapsack cryptosystems i.e. large keys are\nneeded in order to make them secure. This is impractical which is why they are not really used in\npractice. https://en.wikipedia.org/wiki/Merkle\u2013Hellman_knapsack_cryptosystem  \n  \nIn this challenge, the Merkle-Hellman cryptosystem is used to encrypt a flag using the public key. The\nplayers will be given the public key and will use it to decrypt the flag.\n\n## Challenge:\n```\n11b90d6311b90ff90ce610c4123b10c40ce60dfa123610610ce60d450d000ce61061106110c4098515340d4512361534098509270e5d09850e58123610c9\n```  \nPublic key: `{99, 1235, 865, 990, 5, 1443, 895, 1477}`\n\n## Solution:\n`gigem{merkle-hellman-knapsack}`\nKey Points:\n- The public key is short (only 8 integers); This can be brute-forced\n- The sum of the integers in the public key is 4,096 < 7,009 < 65,536 \u2192 16<sup>3</sup> < 7,009 < 16<sup>4</sup>, which means that 4 hexadecimal digits are needed for each letter that is encrypted. (The size of the encryption is 4 times larger than the size of the flag.)\n- The public key is 8 integers long meaning that 8 bits are used\u2026 So the player could assume that ASCII was being used.\n\n## Possible Future Hard challenges that build off of this one\n- Implement a Merkle-Hellman Cryptosystem that uses a public key of size 52 (give or take). This\nwould make brute-forcing ineffective in the traditional sense (2<sup>52</sup>)\u2026 Modern techniques can reduce this search space to 2<sup>n/2</sup> = 2<sup>26</sup> (which could be brute-forced)\n",
    "category": "Crypto"
}