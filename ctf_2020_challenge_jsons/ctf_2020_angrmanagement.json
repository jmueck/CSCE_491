{
    ".gitignore": "angrmanagement\n",
    "angrmanagement.c": "#include \"unistd.h\"\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n\n\nint intify(double a) {\n  int newint = a;\n  return a;\n}\n\nbool check_len(char* string) {\n  return strlen(string) == 32;\n}\n\nbool check_0(char* string) { return (string[15] != 'h') && (string[25] != '|') && (string[27] >= 63); }\nbool check_1(char* string) { return ((string[17] * 16 % 13) == 0) && (string[30] <= 96) && (string[0] >= 38); }\nbool check_2(char* string) { return (string[4] != '{') && (string[17] <= 115) && ((string[23] * 65 % 89) == 19); }\nbool check_3(char* string) { return (string[28] <= 105) && (string[18] >= 37) && (string[0] != '7'); }\nbool check_4(char* string) { return (string[28] <= 75) && (string[18] >= 37) && (string[19] <= 92); }\nbool check_5(char* string) { return (string[20] <= 100) && (string[25] >= 34) && (string[8] <= 92); }\nbool check_6(char* string) { return (string[24] != '{') && ((string[9] * 68 % 74) == 46) && ((string[26] * 69 % 42) == 27); }\nbool check_7(char* string) { return (string[27] != ':') && (string[27] != '8') && ((string[19] * 20 % 95) == 65); }\nbool check_8(char* string) { return (string[12] != 'e') && ((string[10] * 58 % 63) == 9) && (string[1] <= 42); }\nbool check_9(char* string) { return (string[14] != ',') && (string[15] <= 99) && (string[29] <= 72); }\nbool check_10(char* string) { return (string[21] <= 80) && (string[22] <= 123) && ((string[16] * 69 % 92) == 0); }\nbool check_11(char* string) { return ((string[7] * 82 % 81) == 28) && ((string[22] * 77 % 75) == 21) && (string[29] <= 79); }\nbool check_12(char* string) { return (string[18] != 'C') && (string[3] != '|') && (string[14] <= 91); }\nbool check_13(char* string) { return (string[16] != 'h') && ((string[12] * 7 % 81) == 47) && (string[11] <= 69); }\nbool check_14(char* string) { return (string[10] <= 59) && (string[10] != 'R') && ((string[29] * 64 % 73) == 72); }\nbool check_15(char* string) { return (string[5] <= 120) && (string[8] != 'o') && (string[1] >= 34); }\nbool check_16(char* string) { return ((string[8] * 91 % 93) == 18) && (string[20] != 'K') && (string[6] >= 89); }\nbool check_17(char* string) { return (string[2] <= 95) && (string[6] <= 126) && (string[21] <= 64); }\nbool check_18(char* string) { return ((string[7] * 85 % 19) == 12) && (string[30] >= 40) && (string[16] != 'B'); }\nbool check_19(char* string) { return ((string[19] * 21 % 53) == 40) && ((string[9] * 33 % 18) == 15) && (string[24] <= 105); }\nbool check_20(char* string) { return (string[30] >= 33) && ((string[25] * 45 % 89) == 23) && ((string[9] * 36 % 37) == 20); }\nbool check_21(char* string) { return (string[23] != 'Z') && ((string[1] * 21 % 27) == 6) && ((string[5] * 68 % 34) == 0); }\nbool check_22(char* string) { return ((string[11] * 31 % 48) == 44) && ((string[7] * 28 % 72) == 28) && (string[4] >= 37); }\nbool check_23(char* string) { return (string[13] != 'Q') && (string[6] != '2') && ((string[2] * 74 % 90) == 70); }\nbool check_24(char* string) { return (string[23] != 'I') && (string[31] != '^') && (string[20] >= 47); }\nbool check_25(char* string) { return (string[17] >= 90) && (string[2] >= 67) && ((string[13] * 47 % 44) == 18); }\nbool check_26(char* string) { return (string[15] >= 69) && (string[12] != 'w') && ((string[5] * 87 % 71) == 0); }\nbool check_27(char* string) { return (string[22] <= 126) && (string[31] >= 103) && (string[21] <= 104); }\nbool check_28(char* string) { return ((string[0] * 57 % 30) == 0) && (string[28] >= 34) && (string[14] >= 41); }\nbool check_29(char* string) { return ((string[4] * 79 % 15) == 11) && ((string[3] * 98 % 35) == 0) && (string[26] != '?'); }\nbool check_30(char* string) { return (string[3] >= 35) && (string[13] != 'l') && ((string[11] * 61 % 86) == 20); }\nbool check_31(char* string) { return (string[26] >= 36) && (string[24] >= 72) && ((string[31] * 53 % 59) == 13); }\n\nint main() {\n  setvbuf(stdout,_IONBF,0,0);\n\n\n\n  char input[33];\n  printf(\"Enter the password:\\n\");\n  fgets(input, 33, stdin);\n  bool correct = check_len(input) && check_0(input) && check_1(input) && check_2(input) && check_3(input) && check_4(input) && check_5(input) && check_6(input) && check_7(input) && check_8(input) && check_9(input) && check_10(input) && check_11(input) && check_12(input) && check_13(input) && check_14(input) && check_15(input) && check_16(input) && check_17(input) && check_18(input) && check_19(input) && check_20(input) && check_21(input) && check_22(input) && check_23(input) && check_24(input) && check_25(input) && check_26(input) && check_27(input) && check_28(input) && check_29(input) && check_30(input) && check_31(input);\n\n  if(correct) {\n    printf(\"Correct!\\n\");\n    FILE* flagfile = fopen(\"flag.txt\",\"r\");\n    char flag[25];\n    if(flagfile != NULL) {\n      fgets(flag, 25, flagfile);\n      printf(\"%s\", flag);\n    }\n  } else {\n    printf(\"Incorrect.\\n\");\n  }\n\n}\n",
    "constraintgen.py": "import re\nfrom random import shuffle, randint, choice, getrandbits\nfrom string import printable, whitespace\nprintable = [x for x in printable if x not in ['\\'', '\\\"', chr(0x0b), chr(10), \"\\\\\", \"\\n\"] + [x for x in whitespace]]\neqs = \"({} == \\'{}\\')\"\nneqs = \"({} != \\'{}\\')\"\neqs_index = \"(string[{}] == \\'{}\\')\"\nands = \"({} && {})\"\nors = \"({} || {})\"\ngts = \"({} >= {})\"\nlts = \"({} <= {})\"\n\npw = \"(#P#;G~mT[$D5^E_$h.AC7{(Z.+c>AQj\"\n\ncheck_length = 3\n\ndef neconstraint(index):\n\tchar = choice(printable)\n\twhile char == pw[index]:\n\t\tchar = choice(printable)\n\treturn neqs.format(\"string[{}]\".format(index), char)\n\ndef leconstraint(index):\n    num = randint(ord(pw[index]), 0x7e)\n    return lts.format(\"string[{}]\".format(index), num)\n\ndef geconstrainst(index):\n\tnum = randint(0x21, ord(pw[index]))\n\treturn gts.format(\"string[{}]\".format(index), num)\n\ndef cons1(index):\n\tr1 = randint(1, 100)\n\tr2 = randint(1, 100)\n\tr3 = randint(1, 100)\n\tr4 = randint(1, 100)\n\tr5 = randint(1, 100)\n\tlhs = \"(string[{}] * {} % {})\".format(index, r1, r2)\n\trhs = ord(pw[index]) * r1 % r2\n\treturn \"({} == {})\".format(lhs, rhs)\n\n\nfuncs = [neconstraint, leconstraint, geconstrainst, cons1]\nconstraints = []\noutput = []\n\nfor i in range(32):\n\tfor j in range(check_length):\n\t\tconstraints.append(choice(funcs)(i))\nshuffle(constraints)\n\nfor i in range(0, 32*check_length, check_length):\n\toutput.append(\" && \".join(constraints[i:i+check_length]))\n\ncomparison = \"\"\nfor i in range(32):\n\tprint(\"bool check_{}(char* string) {{ return {}; }}\".format(i, output[i]))\n\tcomparison += \"check_{}(input) && \".format(i)\n\nprint(comparison)\n\n",
    "Dockerfile": "FROM debian:buster-slim as build\n\nRUN apt-get update -y; apt-get install build-essential -y;\n\nRUN mkdir /angrmanagement\nWORKDIR /angrmanagement\nCOPY angrmanagement.c .\nRUN gcc angrmanagement.c -o angrmanagement -lm\n\nFROM ubuntu:latest\n\nenv DEBIAN_FRONTEND=\"noninteractive\"\n\nRUN apt-get update && apt-get install socat -y\n\nCOPY --from=build /angrmanagement/angrmanagement /angrmanagement/angrmanagement\nCOPY flag.txt /angrmanagement/flag.txt\nCOPY start.sh /angrmanagement/start.sh\n\nRUN groupadd ctf\nRUN useradd -G ctf --home=/angrmanagement angrmanagement\n\nRUN chown -R angrmanagement /angrmanagement\nRUN chmod -R 555 /angrmanagement\n\nEXPOSE 4322\n\nENTRYPOINT [\"bash\", \"angrmanagement/start.sh\"]\n",
    "flag.txt": "gigem{4n63r_m4n463m3n7}",
    "README.md": "## Description\n\n`nc rev.tamuctf.com 4322`\n\n## Documentation\n\nReverse the password, use angr or similar tool if you don't hate yourself.  I grabbed the same url scheme that was used last year.  I assume it'll be the same this year but its possible that'll need to change.  \n\n### Setup\n\n1. docker build . -t angrmanagement\n2. docker run --rm -it -p 4322:4322 angrmanagement\n\n## Solution\n\nI've attached a solver using angr.  It's pretty straightforward.  I make a symbolic variable of 32 bytes, tell it to write to stdin, and then give it memory addresses to find and avoid.  I also constrain it to printable characters, but that is more for convenience.  If I don't do that it is entirely possible it'll find a valid series of bytes that isn't entirely printable.  \n",
    "solver.py": "from angr import *\nfrom claripy import *\n\n\nproj = Project('angrmanagement', load_options={ 'auto_load_libs': False, 'main_opts': {'base_addr': 0x0}})\n\nx = BVS('x', 32 * 8)\nstate = proj.factory.blank_state(stdin=x)\n\n\n\n# constrain to printable characters\ndef char(state, byte):\n    return state.solver.And(byte <= '~', byte >= ' ')\n\nfor c in x.chop(8):\n    state.solver.add(char(state, c))\n\nsm = proj.factory.simulation_manager(state)\n\n\nsm.explore(find=0x2264, avoid=0x22b6)\n\nif sm.found:\n    for i in sm.found:\n        print(str(i.solver.eval(x, cast_to=bytes)))",
    "start.sh": "#!/bin/bash\n\nwhile : \ndo\n    su -c \"exec socat TCP-LISTEN:4322,reuseaddr,fork EXEC:./angrmanagement,stderr\" - angrmanagement;\ndone\n",
    "category": "Reversing"
}