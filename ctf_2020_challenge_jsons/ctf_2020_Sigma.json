{
    "encrypt.py": "'''\nJust outputs prefix sums of ascii.\n'''\n\nwith open('flag.txt', 'r') as flag_file:\n    flag = flag_file.read().rstrip('\\r\\n')\n    flag = [ord(c) for c in flag]\n    pref = 0\n    for i in flag:\n        pref += i\n        print(pref, end='')\n",
    "encrypted_flag.txt": "10320831141252164475480592397410881183128414021520157116851780189419421991209921942315241625302578269728072902300131153236334834643575368637343782389340044129",
    "flag.txt": "gigem{n3v3r_evv3r_r01l_yer0wn_cryptoo00oo}\n",
    "README.md": "# Sigma\n\n## Description\n\n10320831141252164475480592397410881183128414021520157116851780189419421991209921942315241625302578269728072902300131153236334834643575368637343782389340044129\n\n## Documentation\n\nA simple adhoc crypto challenge. The \"encryption\" method is simply to take prefix sums of the ascii values\nof the flag string and concatenate their prefix sums together.\n\n### Setup\n1. Put desired flag in flag.txt.\n2. Run `python encrypt.py > encrypted_flag.txt`, which outputs the encrypted flag to the file.\n3. This encrypted flag is all that is needed for the challenge.\n\n## Solution\n\nOne could pretty easily solve this by hand after noticing that the first three digits are the ascii value of 'g', the first\ncharacter of the flag. From there, subtracting by hand the next substring which has a decimal value greater than the previous\nis sufficient. The script `solution.py` automates this.\n",
    "solution.py": "s = input()\n\ns = s[3:]\nflag = 'g'\npref = ord('g')\n\ncur = ''\nfor c in s:\n    if len(cur) == 0 or int(cur) < pref:\n        cur += c\n    else:\n        flag += chr(int(cur)-pref)\n        pref = int(cur)\n        cur = c\n\nif len(cur) > 0 and int(cur) > pref:\n    flag += chr(int(cur)-pref)\n\nprint(flag)\n",
    "category": "Crypto"
}