{
    "docker-compose.yml": "version: '2.4'\n\nx-limits: &limits\n    pids_limit: 1024\n    cpu_shares: 256\n    mem_limit: 512m\n    logging:\n        options:\n            max-size: 10m\n            max-file: '3'\n\nservices:\n    shell:\n        <<: *limits\n        build:\n            context: ./shell\n            args:\n                USERNAME: alice\n                PASSWORD: TickTockOnTheCl0ck\n                NAUMOTP_SECRET: DQ6K6V3MNA5F2BIZK2FYVPNXOQMW5YECOZMP7QU7VW3UOOBK3VHQ\n                CTF_FLAG: gigem{a032b26061c96e00e2a0b9e991f11476}\n        image: naumachia/clock.shell\n        networks:\n            default:\n                ipv4_address: 172.30.0.2\n        expose:\n            - \"23\"\n        cap_add:\n            - NET_BIND_SERVICE\n        restart: unless-stopped\n\n    client:\n        <<: *limits\n        build: ./client\n        image: naumachia/clock.client\n        environment:\n            NAUMOTP_SECRET: DQ6K6V3MNA5F2BIZK2FYVPNXOQMW5YECOZMP7QU7VW3UOOBK3VHQ\n            SHELL_USER: alice\n            SHELL_PASS: TickTockOnTheCl0ck\n        networks:\n            default:\n                ipv4_address: 172.30.0.3\n        restart: unless-stopped\n\nnetworks:\n    default:\n        driver: l2bridge\n        ipam:\n            driver: static\n            config:\n                - subnet: 172.30.0.0/28\n",
    "README.rst": "===========\nBrick House\n===========\n\nThis little piggy was a very hard worker and decided to roll his own two-factor authentication to keep the wolves out. It actually looks pretty strong but there is always another way in.\n",
    "client\\Dockerfile": "FROM python:3-alpine\n\nCOPY ./app ./app\nCMD [\"python\", \"-m\", \"app\"]\n",
    "client\\app\\client.py": "from .telnetbot import TelnetBot\nfrom os import environ\nimport logging\nimport random\nimport time\n\nHOST = environ.get('SHELL_HOST', 'shell')\nUSER = environ.get('SHELL_USER', 'noob')\nPASSWD = environ.get('SHELL_PASS', 'noob')\nNAUMOTP_SECRET = environ.get('NAUMOTP_SECRET', None)\nHUMANISH = environ.get(\"HUMANISH\", \"true\").lower() == \"true\"\n\nDELAY_MEAN = 3\nDELAY_VAR = 0.6\nDELAY_INITIAL = 10\n\nlogger = logging.getLogger(\"client\")\nlogging.basicConfig(level=environ.get('LOG_LEVEL', 'info').upper())\n\ndef delay(mu=DELAY_MEAN, sigma=DELAY_VAR):\n    length = abs(random.gauss(mu, sigma))\n    time.sleep(length)\n\ndef session():\n    with TelnetBot(HOST, USER, PASSWD, naumotp_secret=NAUMOTP_SECRET, humanish=HUMANISH) as shell:\n        shell.login()\n        logger.info(f\"Logged in to {HOST} as {USER} with {PASSWD}\")\n        delay()\n\n        date = shell.date()\n        logger.info(f\"Got date as {date}\")\n        delay()\n\ndef main():\n    logger.info(\"Telnet shell host is '{0}'\".format(HOST))\n\n    while True:\n        try:\n            if DELAY_INITIAL > 0:\n                logger.info(f\"Waiting {DELAY_INITIAL} seconds to start\")\n                time.sleep(DELAY_INITIAL)\n            session()\n        except ConnectionErrror:\n            logger.exception(\"Connection error in interaction loop\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "client\\app\\telnetbot.py": "from binascii import hexlify, unhexlify\nfrom datetime import datetime\nfrom hashlib import sha256\nfrom os import path, environ, getenv\nfrom telnetlib import Telnet\nimport hmac\nimport itertools\nimport logging\nimport random\nimport re\nimport string\nimport sys\nimport time\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=environ.get('LOG_LEVEL', 'info').upper())\n\ndef timepoints(mu, sigma):\n    acc = time.time()\n    while True:\n        yield acc\n        acc += random.gauss(mu, sigma)\n\ndef humantype(text, mu=0.3, sigma=0.05):\n    for (ch, schedule) in zip(text, timepoints(mu, sigma)):\n        yield ch\n        time.sleep(max(schedule - time.time(), 0))\n        \nclass TelnetTimeoutError(ConnectionError):\n    def __init__(self, msg=\"telnet connection took too long to respond\"):\n        self.msg = msg\n\n    def __str__(self):\n        return \"TelnetTimoutException: {msg}\".format(msg=self.msg)\n\nclass TelnetBot:\n    \"\"\"\n    An interface for issuing and interpretting commands over telnet\n    \"\"\"\n    port = 23\n    retry_period = 5\n    retry_count = 5\n\n    def __init__(self, host, user=None, passwd=None, timeout=10, naumotp_secret=None, humanish=True):\n        self.connected = False\n        self.loggedin = False\n        self.host = host\n        self.user = user\n        self.passwd = passwd\n        self.timeout = timeout\n        self.naumotp_secret = naumotp_secret\n        self.humanish = humanish\n\n        if isinstance(self.naumotp_secret, str):\n            self.naumotp_secret = self.naumotp_secret.encode('utf-8')\n\n        self.connect()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.write(\"exit\\n\")\n        self.conn.close()\n\n    def connect(self):\n        for i in range(self.retry_count + 1):\n            start_time = time.time()\n            try:\n                self.conn = Telnet(self.host, self.port, self.timeout)\n            except Exception as e: # Catch all errors: not very precise, but it shouldn't be an issue\n                logger.info(\"Connect to shell server failed due to '{0}'\".format(e))\n                elapsed = time.time() - start_time\n                remaining = self.retry_period - elapsed\n                logger.debug(\"Retrying in {0:.2f}s\".format(remaining))\n                if remaining > 0: time.sleep(remaining)\n                if i == self.retry_count: raise\n            else:\n                self.connected = True\n\n\n    def login(self):\n        self.read_until(\"login: \")\n        self.write(\"{0}\\n\".format(self.user))\n\n        self.read_until(\"Password: \")\n        self.write(\"{0}\\n\".format(self.passwd))\n\n        index, match, _ = self.expect([r'\\$ ', r'challenge \\[(?P<chal>[0-9a-f]+)\\]'])\n        if index == 0:\n            self.loggedin = True\n\n        elif index == 1:\n            if self.naumotp_secret is None:\n                raise ValueError(\"Encountered naumotp challenge without a secret to compute the HMAC\")\n\n            resp = hexlify(hmac.new(self.naumotp_secret, unhexlify(match[\"chal\"]), digestmod=sha256).digest())\n\n            self.read_until(\"response: \")\n            self.write(\"{0}\\n\".format(resp.decode('utf-8')), humanish=False)\n\n            index, _, _ = self.expect([r'\\$ '])\n            if index == 0:\n                self.loggedin = True\n\n    def expect(self, patterns):\n        for i, pattern in enumerate(patterns):\n            if isinstance(pattern, str):\n                patterns[i] = pattern.encode('utf-8')\n\n        index, match, text = self.conn.expect(patterns, self.timeout)\n\n        try:\n            logger.debug(text.decode('utf-8'))\n        except UnicodeDecodeError:\n            pass\n\n        if index == -1:\n            raise TelnetTimeoutError()\n        else:\n            return index, match, text.decode('utf-8')\n\n    def read_until(self, expected):\n        if isinstance(expected, str):\n            expected = expected.encode('utf-8')\n\n        text = self.conn.read_until(expected, self.timeout)\n\n        try:\n            result = text.decode('utf-8')\n            logger.debug(result)\n        except UnicodeDecodeError:\n            result = None\n\n        if not text.endswith(expected):\n            raise TelnetTimeoutError()\n        else:\n            return result\n\n    def write(self, text, humanish=None):\n        if isinstance(text, str):\n            text = text.encode('utf-8')\n\n        try:\n            logger.debug(text.decode('utf-8'))\n        except UnicodeDecodeError:\n           pass\n\n        if humanish is None:\n            humanish = self.humanish\n\n        if humanish:\n            for ch in humantype(text):\n                self.conn.write(bytes((ch,)))\n        else:\n            self.conn.write(text)\n\n    def bc(self, expr):\n        self.write(f\"bc <<< '{expr}'\\n\")\n        return int(self.read_until(\"$ \").splitlines()[-2])\n\n    def date(self):\n        self.write(f\"date\\n\")\n        return self.read_until(\"$ \").splitlines()[-2]\n",
    "client\\app\\__init__.py": "",
    "client\\app\\__main__.py": "from .client import main\n\nif __name__ == \"__main__\":\n    main()\n",
    "shell\\Dockerfile": "FROM ubuntu:xenial\n\nRUN apt-get update && \\\n    apt-get -y install xinetd telnetd git automake build-essential libpam0g-dev libssl-dev\n\n# BUILD PAM_NAUMOTP\nARG NAUMOTP_REPO_URL=https://github.com/nategraf/pam_naumotp.git\nARG NAUMOTP_REPO_BRANCH=master\n\nCOPY ./make-naumotp.sh ./make-naumotp.sh\nRUN sh ./make-naumotp.sh\n\nRUN apt-get -y remove automake build-essential && \\\n    apt-get -y autoremove\n\n# SET UP ENV\nARG USERNAME \nARG PASSWORD \nARG NAUMOTP_SECRET\nARG CTF_FLAG\n\nRUN useradd -Um $USERNAME && \\\n    printf \"${PASSWORD}\\n${PASSWORD}\\n\" | passwd $USERNAME\n\nRUN cd /home/$USERNAME && \\\n    echo \"$CTF_FLAG\" > .ctf_flag\n\n# Copy is done in two steps to avoid clobering all of pam.d\nCOPY ./etc/* /etc/\nCOPY ./pam.d/* /etc/pam.d/\nRUN echo $NAUMOTP_SECRET > /home/$USERNAME/.naumotp_secret && \\\n    chmod 600 /home/$USERNAME/.naumotp_secret\n\nEXPOSE 23\n\nCMD [\"xinetd\", \"-dontfork\", \"-inetd_compat\"]\n",
    "shell\\make-naumotp.sh": "#!/bin/sh\n\nset -e\n\necho \"Building Naum OTP from $NAUMOTP_REPO_URL\"\n\nOWD=$PWD\n\nmkdir build-tmp\ncd build-tmp\n\ngit clone \"$NAUMOTP_REPO_URL\" naumotp\nif [ -z \"$(ls naumotp)\" ]; then\n    echo \"BUILD FAILED: Could not clone $NAUMOTP_REPO_URL\"\n    exit 1\nfi\n\ncd naumotp\n\nif [ -n \"$NAUMOTP_REPO_BRANCH\" ]; then\n    git checkout \"$NAUMOTP_REPO_BRANCH\"\nfi\n\nmake && make install\n\ncd $OWD\n\nrm -rf build-tmp\n",
    "shell\\etc\\hostname": "naumachia-login\n",
    "shell\\etc\\inetd.conf": "telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd\n",
    "shell\\pam.d\\common-auth": "auth    [success=1 default=ignore]      pam_unix.so nullok_secure\n\nauth    requisite                       pam_deny.so\nauth    required                        pam_permit.so\n\nauth    required                        pam_naumotp.so\n",
    "category": "NetworkPentest"
}