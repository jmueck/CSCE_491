{
    ".gitlab-ci.yml": "image: shotes/buffer_overflow:latest\n\n\ntest:\n  script:\n    - \"./tests/entry.sh\"\n\n",
    "Dockerfile": "FROM ubuntu:latest\n\nRUN apt update && apt install -y \\\n\tapt-utils \\\n\tgcc \\\n\tgcc-multilib \\\n\tbuild-essential \\\n\tpython \\\n\tpython-pip \\\n\tsocat\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nEXPOSE 3456\n",
    "README.md": "# buffer_overflow Secure Coding Scenario\n\n### Setup\nAdd the following to the challenge_mapper in the Akeso config.py:\n'echo_overflow':('echo_overflow',['overflow'],['echo_server'],3456)\n\nPut contents of Exploits in the Exploits directory of Akeso.\nPut contents of Services in the Services directory of Akeso.\n\n### Solution\nchange gets(buf) to fgets(buf,128,stdin) and commit code to gitlab\n",
    "requirements.txt": "requests\ndocker\nstructlog\npika\npwntools\n",
    "vuln.c": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid echo()\n{\n\tprintf(\"%s\", \"Enter a word to be echoed:\\n\");\n\tchar buf[128];\n\tgets(buf);\n\tprintf(\"%s\\n\", buf);\n}\n\nint main()\n{\n\techo();\n}\n",
    "Exploits\\overflow.py": "from ExploitFrame import ExploitFrame\nfrom pwn import *\n\nclass Exploit(ExploitFrame):\n    def __init_(self, serviceInfo):\n        self.name = 'overflow'\n        self.output = None\n        ExploitFrame.__init__(self, serviceInfo)\n\n    def exploit(self):\n        p = remote(self.serviceInfo.serviceHost,self.serviceInfo.servicePort)\n        p.send('A'*40000 + '\\n')\n        try:\n            p.recv()\n            self.output = False\n        except EOFError:\n            self.output = True\n        except:\n            self.output = True\n\n    def exploitSuccess(self):\n        return self.output\n",
    "Services\\echo_server\\echo_server.py": "from .. import ServiceFrame\nimport docker\nimport requests\nimport structlog\nimport subprocess\nfrom pwn import *\n\nlogger = structlog.get_logger()\n\nclass ServiceCheck(ServiceFrame.ServiceFrame):\n    def __init__(self, serviceInfo):\n        ServiceFrame.ServiceFrame.__init__(self, serviceInfo)\n        self.flag = \"gigem{check_that_buffer_size_baby}\"\n\n    def checkService(self):\n        msg = \"ServiceCheck Started\"\n        logger.info(\"echo_server\", msg=msg, serviceInfo=self.serviceInfo.__dict__)\n        p = remote(self.serviceInfo.serviceHost,self.serviceInfo.servicePort)\n        p.send('APPLES' + '\\n')\n        try:\n            value = p.recv()\n            if 'APPLES' in value:\n                msg = 'Passed ServiceCheck'\n                logger.info(\"echo_server\", msg=msg, serviceInfo=self.serviceInfo.__dict__)\n                return True\n            else:\n                msg = 'Failed ServiceCheck'\n                logger.info(\"echo_server\", msg=msg, serviceInfo=self.serviceInfo.__dict__)\n                return False\n        except: # NOQA\n            msg = \"SOMETHING BROKE!!! EVERYBODY STAY CALM!! STAY! CALM!!\"\n            logger.info(\"echo_server\", msg=msg, serviceInfo=self.serviceInfo.__dict__)\n            return False\n        return False\n\n    def getLogs(self):\n        client = docker.from_env(version=\"auto\")\n        container = client.containers.get(self.serviceInfo.serviceName)\n        return container.logs()\n",
    "Services\\echo_server\\__init__.py": "",
    "tests\\entry.sh": "#!/bin/sh\ngcc -m32 -w -fno-stack-protector -z execstack -o vuln vuln.c\nsocat TCP-LISTEN:3456,reuseaddr,fork EXEC:./vuln &\npython tests/queue.py\n\n",
    "tests\\queue.py": "import pika\nimport json\nimport sys\nimport os\nimport socket\nimport binascii\n\ndef callback(ch, method, properties, body):\n    print body\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n    sys.exit()\n    return\n\n\ninfo = ('sqlisimple', 'SQLi', 'SQLiSimple', 80, 'login.php')\ncredentials = pika.PlainCredentials('guest', 'guest')\nparameters = pika.ConnectionParameters('172.17.0.2')\n\nconnection = pika.BlockingConnection(parameters)\nchannel = connection.channel()\nchannel.queue_declare(queue='attackQueue', durable=True)\n\n\nuserinfo = binascii.hexlify(os.urandom(32)).decode('ascii')\n\n#Stupid hack I found to get host ip\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\ns.connect((\"8.8.8.8\", 80))\nhostname = s.getsockname()[0]\nprint(hostname)\ns.close()\n\n# A lot of this I won't need anymore\nservice = {\n    'chal': 'echo_overflow',\n    'userInfo': userinfo,\n    'serviceHost': hostname,\n}\n\nprint \"Pushing: {}\".format(service)\nchannel.basic_publish(exchange='',\n                      routing_key='attackQueue',\n                      body=json.dumps(service))\n\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters('172.17.0.2'))\nuserChannel = connection.channel()\nuserChannel.exchange_declare(exchange='resultX')\nuserChannel.queue_declare(queue='resultQueue', durable=True)\n\n\nuserChannel.queue_bind(exchange='resultX',\n                       queue='resultQueue',\n                       routing_key=userinfo)\n\nuserChannel.basic_consume(callback, queue='resultQueue' )\nuserChannel.start_consuming()\n\nuserChannel.close()\n\n\n",
    "category": "Secure_Coding"
}