{
    "chall.py": "import re\nfrom flag import flag, key\n\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nregex = re.compile('[^a-zA-Z]')\n\nmsg = flag\nkey = key\n\ndef encrypt(msg, key):\n\tctxt = ''\n\n\tmsg = regex.sub('', msg).lower()\n\tkey = regex.sub('', key).lower()\n\n\tfor i in range(len(msg)):\n\t\tindex = alpha.index(msg[i]) ^ alpha.index(key[i % len(key)])\n\t\tif index < 26:\n\t\t\tctxt += alpha[index]\n\t\telse:\n\t\t\tctxt += msg[i]\n\t\t\n\t\tif i % len(key) == len(key) - 1:\n\t\t\tkey = key[1:] + key[0]\n\n\treturn ctxt\n\nc = encrypt(msg, key)\n\nprint(\"encrypted message: %s\" % c)\n",
    "flag.py": "flag = \"werenostrangerstoloveyouknowtherulesandsodoidoiafullcommitmentswhatimthinkingofyouwouldntgetthisfromanyotherguyijustwannatellyouhowimfeelinggottamakeyouunderstandnevergonnagiveyouupnevergonnaletyoudownnevergonnarunaroundanddesertyounevergonnamakeyoucrynevergonnasaygoodbyenevergonnatellalieandhurtyouweveknowneachotherforsolongyourheartsbeenachingbutyouretooshytosayitsayitinsidewebothknowwhatsbeengoingongoingonweknowthegameandweregonnaplayitandifyouaskmehowimfeelingdonttellmeyouretooblindtoseenevergonnagiveyouupnevergonnaletyoudownnevergonnarunaroundanddesertyounevergonnamakeyoucrynevergonnasaygoodbyenevergonnatellalieandhurtyounevergonnagiveyouupnevergonnaletyoudownnevergonnarunaroundanddesertyounevergonnamakeyoucrynevergonnasaygoodbyenevergonnatellalieandhurtyouweveknowneachotherforsolongyourheartsbeenachingbutyouretooshytosayittosayitinsidewebothknowwhatsbeengoingongoingonweknowthegameandweregonnaplayitijustwannatellyouhowimfeelinggottamakeyouunderstandnevergonnagiveyouupnevergonnaletyoudownnevergonnarunaroundanddesertyounevergonnamakeyoucrynevergonnasaygoodbyenevergonnatellalieandhurtyounevergonnagiveyouupnevergonnaletyoudownnevergonnarunaroundanddesertyounevergonnamakeyoucrynevergonnasaygoodbyenevergonnatellalieandhurtyounevergonnagiveyouupnevergonnaletyoudownnevergonnarunaroundanddesertyounevergonnamakeyoucrynevergonnasaygoodbyenevergonnatellalieandhurtyoutheflagisfrequencyanalysisiscool\"\nkey = \"rickrolledlol\"\n",
    "Makefile": "NAME := vigenot\n\ndist:\n\tzip $(NAME).zip chall.py\n\n",
    "README.md": "# Vigenot\n\nAuthor: `_mac_`\n\nI've been staring at this so long my brain hertz. Here's the ciphertext if ya want to take a crack at it.\n`hmtonazyvdgipzqzoffvayfubnmwcjprqipslnlyonfdhndoofdjtahhmqhkgcsunoydiqmggkapmootkxwaullpzxkyxedsoagoknwfxeprnfqkdfsywdgdlcmjbjaumkwghumgbzdnnkqtlmiiojauujaprdtchsdpvasnanfcmzvptkxubgmxoaifgjdakyjmusawgjhvkrxghnorujdraunlcnnipwhrttoupovprcngdlmiiojfugstdpemtmodgerlwnogbljkgawprnofpkckaadagprfbnfrytkuypemihoygpebjfcpgruarzkifgxqmuajplvqzpvmpktjdgccuttgwrvtffwettfdcsztzlylyggdajvypkkqmegowuwoyzfhpdnoapmagnklgifnwganfwxepilmmchsypvhnagninbrwdxdgnduqmursbhhmawzehovfdgciagctgblcptkxrpcgmllggixnzpvfgvvrnfjolizvgsouuejhvkromhnoapxyfuiouhnkvpvffdgrzunorfqoiogslgdkryynudpemtmaggeplepjgwiatgawprnofpkdotcnfnkjmpoekrcngdlcmjbrfdpdgnmfzrsougprprnofpkxgvpynuupfgvvrnfjolavtyefnfwjopvvzeendlrqolrfupjrdiiarpryjmunkvpvffdgrekkktfqbrwgvvgaifgjdzotxgmjptpjhvkrxgphryppilfdvipjwurxyfuwvvganawjhlmmotfoalfrrfffnoyefrmpertzqmghrmmdjfpucqmuakyfkrmtcgqkjgyykrlwztkhdgipshkaypihoywmeqzppvpmoggnkonadnoenypbjnwtmvocmklghvprpxgphoeaeydtdyuqzhlgjdykalqmuwawmpokplapmxayxdhobvqmufdipsztlnlpoekrnkgdlxaxojauulokvvzeendlaaqtfflmwndpvasnanfcrfdlrkxgnlfbjvsprxyfugvxoaifgjdhobvqefmrtjhvkrxgpnozlyffaiqqghkvpvffdgrtgbllamhldiwutzjaujhvkrxgphridrhtaufhpoekrnngdllmrsouifsgdpemtmodglvxdlagwhsogihhzpatyefdpvasnanfcgreptkxjrtfgvvrnfjolsljeeonktaopvpaoendlyaiaoazmcnnmuvqtaunmxornfjolidemyefuejhvkrxgphrfpxyfuiowphvvpvffdgrzwhrrfuoiogslgyvrytkudpemtmodglidepjgwiawgprhrnofpkdotnknipjmpoekrnkogoymjbrfdpeoijuarsouymagaonzspakquaojwlnijjsdzmrjafl`\n\nNote, submit the flag in `gigem{flag}` format \n\n## Solution\nWe are given ciphertext and source code for the encryption algorithm. It appears to calculate an ciphertext character via xor with a key and rotates a key to expand its length by to k^2 where k is the original key length. \n\nFirst problem is finding key length, which is done via index of coincidence calculations on the unrotated ciphertext. The unrotate to to align all the characters of the ciphertext that are encrypted with the same character of the key. This IoC calculation finds a key length of 13.\n\nNext problem is actually finding the key, which is done via frequency analysis and the X^{2} method, as described well [here](https://pages.mtu.edu/~shene/NSF-4/Tutorial/VIG/Vig-Recover.html). This gets us the key `rickrolledlol`, which successfully decrypts the ciphertext to find us the flag. Final solve script in `solve.py`.\n\nFlag: `gigem{frequencyanalysisiscool}`\n",
    "solve.py": "ct = \"hmtonazyvdgipzqzoffvayfubnmwcjprqipslnlyonfdhndoofdjtahhmqhkgcsunoydiqmggkapmootkxwaullpzxkyxedsoagoknwfxeprnfqkdfsywdgdlcmjbjaumkwghumgbzdnnkqtlmiiojauujaprdtchsdpvasnanfcmzvptkxubgmxoaifgjdakyjmusawgjhvkrxghnorujdraunlcnnipwhrttoupovprcngdlmiiojfugstdpemtmodgerlwnogbljkgawprnofpkckaadagprfbnfrytkuypemihoygpebjfcpgruarzkifgxqmuajplvqzpvmpktjdgccuttgwrvtffwettfdcsztzlylyggdajvypkkqmegowuwoyzfhpdnoapmagnklgifnwganfwxepilmmchsypvhnagninbrwdxdgnduqmursbhhmawzehovfdgciagctgblcptkxrpcgmllggixnzpvfgvvrnfjolizvgsouuejhvkromhnoapxyfuiouhnkvpvffdgrzunorfqoiogslgdkryynudpemtmaggeplepjgwiatgawprnofpkdotcnfnkjmpoekrcngdlcmjbrfdpdgnmfzrsougprprnofpkxgvpynuupfgvvrnfjolavtyefnfwjopvvzeendlrqolrfupjrdiiarpryjmunkvpvffdgrekkktfqbrwgvvgaifgjdzotxgmjptpjhvkrxgphryppilfdvipjwurxyfuwvvganawjhlmmotfoalfrrfffnoyefrmpertzqmghrmmdjfpucqmuakyfkrmtcgqkjgyykrlwztkhdgipshkaypihoywmeqzppvpmoggnkonadnoenypbjnwtmvocmklghvprpxgphoeaeydtdyuqzhlgjdykalqmuwawmpokplapmxayxdhobvqmufdipsztlnlpoekrnkgdlxaxojauulokvvzeendlaaqtfflmwndpvasnanfcrfdlrkxgnlfbjvsprxyfugvxoaifgjdhobvqefmrtjhvkrxgpnozlyffaiqqghkvpvffdgrtgbllamhldiwutzjaujhvkrxgphridrhtaufhpoekrnngdllmrsouifsgdpemtmodglvxdlagwhsogihhzpatyefdpvasnanfcgreptkxjrtfgvvrnfjolsljeeonktaopvpaoendlyaiaoazmcnnmuvqtaunmxornfjolidemyefuejhvkrxgphrfpxyfuiowphvvpvffdgrzwhrrfuoiogslgyvrytkudpemtmodglidepjgwiawgprhrnofpkdotnknipjmpoekrnkogoymjbrfdpeoijuarsouymagaonzspakquaojwlnijjsdzmrjafl\"\n\nalpha = 'abcdefghijklmnopqrstuvwxyz'\n\n\ndef encrypt(msg, key):\n\tctxt = ''\n\n\tfor i in range(len(msg)):\n\t\tindex = alpha.index(msg[i]) ^ alpha.index(key[i % len(key)])\n\t\tif index < 26:\n\t\t\tctxt += alpha[index]\n\t\telse:\n\t\t\tctxt += msg[i]\n\t\t\n\t\tif i % len(key) == len(key) - 1:\n\t\t\tkey = key[1:] + key[0]\n\n\treturn ctxt\n\n\ndef decrypt(ct, key):\n    pt = ''\n\n    for i in range(len(ct)):\n        idx = alpha.index(ct[i]) ^ alpha.index(key[i%len(key)])\n        if idx < 26:\n            pt += alpha[idx]\n        else:\n            pt += ct[i]\n\n        if i % len(key) == len(key) - 1:\n            key = key[1:] + key[0]\n\n    return pt\n\n\nassert(decrypt(encrypt('testingsuperlongstringtomakesuredecryptencryptaregoodabcdefghijklmnopqrstuvwxyz', 'abcd'), 'abcd') == 'testingsuperlongstringtomakesuredecryptencryptaregoodabcdefghijklmnopqrstuvwxyz')\n\nassert(decrypt(encrypt('abcdefghijklmnopqrstuvwxyz', 'f'), 'f') == 'abcdefghijklmnopqrstuvwxyz')\n\ndef unrotate_helper(s, i):\n    l = len(s)\n    return s[l - i:] + s[:l - i]\n\n\ndef unrotate(ct, key_len):\n    pt = ''\n    for i in range(0, len(ct), key_len):\n        substr = ct[i:i+key_len]\n        pt += unrotate_helper(substr, (i//key_len) % key_len)\n    return pt\n\n\nassert(unrotate(\"ABCDBCDACDABDABC\", 4) == \"ABCDABCDABCDABCD\")\n\n\ndef ic(ct):\n    ret = 0.0\n    den = ((len(ct)*(len(ct)-1))+0.0 / len(alpha))\n    for a in alpha:\n        n = ct.count(a)\n        ret += (n*(n-1)) / den\n    return ret\n\ndef expand_key(k):\n    l = len(k)\n    ret = ''\n    for i in range(l):\n        ret += k[i:l]+k[:i]\n    return ret\n\n\n#for i in range(1, 50):\n#    temp = unrotate(ct, i)\n#    s = 0.0\n#    for j in range(i):\n#        s += ic( temp[j:len(ct):i] )\n#\n#    print(s/i , i)\n\nkeylen = 13\n\nunrotated_ct = unrotate(ct, 13)\nsets = []\nfor i in range(13):\n    sets.append(unrotated_ct[i::13])\n\nF = [0.084, 0.014, 0.028, 0.038, 0.131, 0.029, 0.020, 0.053, 0.064, 0.001, 0.004, 0.034, 0.025, 0.071, 0.080, 0.020, 0.001, 0.068, 0.061, 0.105, 0.025, 0.009, 0.015, 0.002, 0.020, 0.001]\n\nkey = ''\nfor s in sets:\n    best = ('z', 1.0)\n    for a in alpha:\n        total = 0.0\n        counts = [0]*26\n        temp = decrypt(s, a)\n        for c in temp:\n            counts[alpha.index(c)] += 1\n        for i in range(26):\n            counts[i] /= len(s)\n            total += pow((counts[i] - F[i]) , 2) / F[i]\n        if total < best[1]:\n            best = (a, total)\n    key += best[0]\nprint(key)\n\nprint(decrypt(ct, key))\n",
    "category": "crypto"
}