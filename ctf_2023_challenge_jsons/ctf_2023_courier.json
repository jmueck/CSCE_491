{
    ".gitignore": "*.tar.gz\nstamp.key",
    "Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"atomic-polyfill\"\nversion = \"0.1.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e3ff7eb3f316534d83a8a2c3d1674ace8a5a71198eba31e2e2b597833f699b28\"\ndependencies = [\n \"critical-section\",\n]\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n\n[[package]]\nname = \"bare-metal\"\nversion = \"0.2.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5deb64efa5bd81e31fcd1938615a6d98c82eafcbcd787162b6f63b91d6bac5b3\"\ndependencies = [\n \"rustc_version 0.2.3\",\n]\n\n[[package]]\nname = \"bare-metal\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f8fe8f5a8a398345e52358e18ff07cc17a568fbca5c6f73873d3a62056309603\"\n\n[[package]]\nname = \"bitfield\"\nversion = \"0.13.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"46afbd2983a5d5a7bd740ccb198caf5b82f45c40c09c0eed36052d91cb92e719\"\n\n[[package]]\nname = \"block-buffer\"\nversion = \"0.10.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"69cce20737498f97b993470a6e536b8523f0af7892a4f928cceb1ac5e52ebe7e\"\ndependencies = [\n \"generic-array\",\n]\n\n[[package]]\nname = \"byteorder\"\nversion = \"1.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"cobs\"\nversion = \"0.2.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"67ba02a97a2bd10f4b59b25c7973101c79642302776489e030cd13cdab09ed15\"\n\n[[package]]\nname = \"consignee\"\nversion = \"0.1.0\"\ndependencies = [\n \"cortex-m\",\n \"cortex-m-rtic\",\n \"cortex-m-semihosting\",\n \"courier-proto\",\n \"embedded-alloc\",\n \"lm3s6965\",\n \"lm3s6965-uart\",\n \"panic-semihosting\",\n \"postcard\",\n]\n\n[[package]]\nname = \"cortex-m\"\nversion = \"0.7.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8ec610d8f49840a5b376c69663b6369e71f4b34484b9b2eb29fb918d92516cb9\"\ndependencies = [\n \"bare-metal 0.2.5\",\n \"bitfield\",\n \"critical-section\",\n \"embedded-hal\",\n \"volatile-register\",\n]\n\n[[package]]\nname = \"cortex-m-rt\"\nversion = \"0.6.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"454f278bf469e2de0a4d22ea019d169d8944f86957c8207a39e3f66c32be2fc6\"\ndependencies = [\n \"cortex-m-rt-macros\",\n \"r0\",\n]\n\n[[package]]\nname = \"cortex-m-rt-macros\"\nversion = \"0.6.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c8e3aa52243e26f5922fa522b0814019e0c98fc567e2756d715dce7ad7a81f49\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn\",\n]\n\n[[package]]\nname = \"cortex-m-rtic\"\nversion = \"1.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c6b82f1c39acd6c3a35c2013b6110c20f5bc534522791fabadeed49ccada2dce\"\ndependencies = [\n \"bare-metal 1.0.0\",\n \"cortex-m\",\n \"cortex-m-rtic-macros\",\n \"heapless\",\n \"rtic-core\",\n \"rtic-monotonic\",\n \"version_check\",\n]\n\n[[package]]\nname = \"cortex-m-rtic-macros\"\nversion = \"1.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9e8e9645ef54bec1cf70ac33e9bf9566e6507ab5b41ae6baf3735662194e8607\"\ndependencies = [\n \"proc-macro-error\",\n \"proc-macro2\",\n \"quote\",\n \"rtic-syntax\",\n \"syn\",\n]\n\n[[package]]\nname = \"cortex-m-semihosting\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c23234600452033cc77e4b761e740e02d2c4168e11dbf36ab14a0f58973592b0\"\ndependencies = [\n \"cortex-m\",\n]\n\n[[package]]\nname = \"courier\"\nversion = \"0.1.0\"\ndependencies = [\n \"cortex-m\",\n \"cortex-m-rtic\",\n \"cortex-m-semihosting\",\n \"courier-proto\",\n \"embedded-alloc\",\n \"lm3s6965\",\n \"lm3s6965-uart\",\n \"panic-semihosting\",\n]\n\n[[package]]\nname = \"courier-proto\"\nversion = \"0.1.0\"\ndependencies = [\n \"cortex-m-semihosting\",\n \"heapless\",\n \"hmac\",\n \"postcard\",\n \"serde\",\n \"sha2\",\n]\n\n[[package]]\nname = \"cpufeatures\"\nversion = \"0.2.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"28d997bd5e24a5928dd43e46dc529867e207907fe0b239c3477d924f7f2ca320\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"critical-section\"\nversion = \"1.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6548a0ad5d2549e111e1f6a11a6c2e2d00ce6a3dafe22948d67c2b443f775e52\"\n\n[[package]]\nname = \"crypto-common\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\ndependencies = [\n \"generic-array\",\n \"typenum\",\n]\n\n[[package]]\nname = \"digest\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8168378f4e5023e7218c89c891c0fd8ecdb5e5e4f18cb78f38cf245dd021e76f\"\ndependencies = [\n \"block-buffer\",\n \"crypto-common\",\n \"subtle\",\n]\n\n[[package]]\nname = \"embedded-alloc\"\nversion = \"0.5.0\"\nsource = \"git+https://github.com/rust-embedded/embedded-alloc.git?rev=89cb8d50e6634130302cd444b3f547aed0fd32dc#89cb8d50e6634130302cd444b3f547aed0fd32dc\"\ndependencies = [\n \"critical-section\",\n \"linked_list_allocator\",\n]\n\n[[package]]\nname = \"embedded-hal\"\nversion = \"0.2.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"35949884794ad573cf46071e41c9b60efb0cb311e3ca01f7af807af1debc66ff\"\ndependencies = [\n \"nb 0.1.3\",\n \"void\",\n]\n\n[[package]]\nname = \"generic-array\"\nversion = \"0.14.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bff49e947297f3312447abdca79f45f4738097cc82b06e72054d2223f601f1b9\"\ndependencies = [\n \"typenum\",\n \"version_check\",\n]\n\n[[package]]\nname = \"hash32\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b0c35f58762feb77d74ebe43bdbc3210f09be9fe6742234d573bacc26ed92b67\"\ndependencies = [\n \"byteorder\",\n]\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.12.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n\n[[package]]\nname = \"heapless\"\nversion = \"0.7.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"db04bc24a18b9ea980628ecf00e6c0264f3c1426dac36c00cb49b6fbad8b0743\"\ndependencies = [\n \"atomic-polyfill\",\n \"hash32\",\n \"rustc_version 0.4.0\",\n \"serde\",\n \"spin\",\n \"stable_deref_trait\",\n]\n\n[[package]]\nname = \"hmac\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e\"\ndependencies = [\n \"digest\",\n]\n\n[[package]]\nname = \"indexmap\"\nversion = \"1.9.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\ndependencies = [\n \"autocfg\",\n \"hashbrown\",\n]\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.139\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n\n[[package]]\nname = \"linked_list_allocator\"\nversion = \"0.10.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e322f259d225fbae43a1b053b2dc6a5968a6bdf8b205f5de684dab485b95030e\"\n\n[[package]]\nname = \"lm3s6965\"\nversion = \"0.1.3\"\nsource = \"git+https://github.com/japaric/lm3s6965.git?rev=facf63aa0169c773175a143f6014a1d0977fb74f#facf63aa0169c773175a143f6014a1d0977fb74f\"\ndependencies = [\n \"bare-metal 0.2.5\",\n \"cortex-m-rt\",\n]\n\n[[package]]\nname = \"lm3s6965-uart\"\nversion = \"0.1.0\"\ndependencies = [\n \"volatile-register\",\n]\n\n[[package]]\nname = \"lock_api\"\nversion = \"0.4.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"435011366fe56583b16cf956f9df0095b405b82d76425bc8981c0e22e60ec4df\"\ndependencies = [\n \"autocfg\",\n \"scopeguard\",\n]\n\n[[package]]\nname = \"nb\"\nversion = \"0.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"801d31da0513b6ec5214e9bf433a77966320625a37860f910be265be6e18d06f\"\ndependencies = [\n \"nb 1.0.0\",\n]\n\n[[package]]\nname = \"nb\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"546c37ac5d9e56f55e73b677106873d9d9f5190605e41a856503623648488cae\"\n\n[[package]]\nname = \"panic-semihosting\"\nversion = \"0.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ee8a3e1233d9073d76a870223512ce4eeea43c067a94a445c13bd6d792d7b1ab\"\ndependencies = [\n \"cortex-m\",\n \"cortex-m-semihosting\",\n]\n\n[[package]]\nname = \"postcard\"\nversion = \"1.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1c2b180dc0bade59f03fd005cb967d3f1e5f69b13922dad0cd6e047cb8af2363\"\ndependencies = [\n \"cobs\",\n \"heapless\",\n \"serde\",\n]\n\n[[package]]\nname = \"proc-macro-error\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c\"\ndependencies = [\n \"proc-macro-error-attr\",\n \"proc-macro2\",\n \"quote\",\n \"syn\",\n \"version_check\",\n]\n\n[[package]]\nname = \"proc-macro-error-attr\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"version_check\",\n]\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.49\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"57a8eca9f9c4ffde41714334dee777596264c7825420f521abc92b5b5deb63a5\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.23\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8856d8364d252a14d474036ea1358d63c9e6965c8e5c1885c18f73d70bff9c7b\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"r0\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e2a38df5b15c8d5c7e8654189744d8e396bddc18ad48041a500ce52d6948941f\"\n\n[[package]]\nname = \"rtic-core\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d9369355b04d06a3780ec0f51ea2d225624db777acbc60abd8ca4832da5c1a42\"\n\n[[package]]\nname = \"rtic-monotonic\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fb8b0b822d1a366470b9cea83a1d4e788392db763539dc4ba022bcc787fece82\"\n\n[[package]]\nname = \"rtic-syntax\"\nversion = \"1.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3ad3ae243dd8d0a1b064615f664d4fa7e63929939074c564cbe5efdc4c503065\"\ndependencies = [\n \"indexmap\",\n \"proc-macro2\",\n \"quote\",\n \"syn\",\n]\n\n[[package]]\nname = \"rustc_version\"\nversion = \"0.2.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\ndependencies = [\n \"semver 0.9.0\",\n]\n\n[[package]]\nname = \"rustc_version\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366\"\ndependencies = [\n \"semver 1.0.16\",\n]\n\n[[package]]\nname = \"scopeguard\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n\n[[package]]\nname = \"semver\"\nversion = \"0.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\ndependencies = [\n \"semver-parser\",\n]\n\n[[package]]\nname = \"semver\"\nversion = \"1.0.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"58bc9567378fc7690d6b2addae4e60ac2eeea07becb2c64b9f218b53865cba2a\"\n\n[[package]]\nname = \"semver-parser\"\nversion = \"0.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n\n[[package]]\nname = \"sender\"\nversion = \"0.1.0\"\ndependencies = [\n \"courier-proto\",\n \"postcard\",\n]\n\n[[package]]\nname = \"serde\"\nversion = \"1.0.152\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bb7d1f0d3021d347a83e556fc4683dea2ea09d87bccdf88ff5c12545d89d5efb\"\ndependencies = [\n \"serde_derive\",\n]\n\n[[package]]\nname = \"serde_derive\"\nversion = \"1.0.152\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"af487d118eecd09402d70a5d72551860e788df87b464af30e5ea6a38c75c541e\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn\",\n]\n\n[[package]]\nname = \"sha2\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"82e6b795fe2e3b1e845bafcb27aa35405c4d47cdfc92af5fc8d3002f76cebdc0\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"digest\",\n]\n\n[[package]]\nname = \"spin\"\nversion = \"0.9.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f6002a767bff9e83f8eeecf883ecb8011875a21ae8da43bffb817a57e78cc09\"\ndependencies = [\n \"lock_api\",\n]\n\n[[package]]\nname = \"stable_deref_trait\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3\"\n\n[[package]]\nname = \"stamper\"\nversion = \"0.1.0\"\ndependencies = [\n \"cortex-m\",\n \"cortex-m-rtic\",\n \"cortex-m-semihosting\",\n \"courier-proto\",\n \"embedded-alloc\",\n \"lm3s6965\",\n \"lm3s6965-uart\",\n \"panic-semihosting\",\n]\n\n[[package]]\nname = \"subtle\"\nversion = \"2.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6bdef32e8150c2a081110b42772ffe7d7c9032b606bc226c8260fd97e0976601\"\n\n[[package]]\nname = \"syn\"\nversion = \"1.0.107\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1f4064b5b16e03ae50984a5a8ed5d4f8803e6bc1fd170a3cda91a1be4b18e3f5\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"typenum\"\nversion = \"1.16.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba\"\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"84a22b9f218b40614adcb3f4ff08b703773ad44fa9423e4e0d346d5db86e4ebc\"\n\n[[package]]\nname = \"vcell\"\nversion = \"0.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"77439c1b53d2303b20d9459b1ade71a83c716e3f9c34f3228c00e6f185d6c002\"\n\n[[package]]\nname = \"version_check\"\nversion = \"0.9.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n\n[[package]]\nname = \"void\"\nversion = \"1.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n\n[[package]]\nname = \"volatile-register\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9ee8f19f9d74293faf70901bc20ad067dc1ad390d2cbf1e3f75f721ffee908b6\"\ndependencies = [\n \"vcell\",\n]\n",
    "Cargo.toml": "[workspace]\nmembers = [\n    \"consignee\",\n    \"courier\",\n    \"courier-proto\",\n    \"lm3s6965-uart\",\n    \"sender\",\n    \"stamper\",\n]",
    "Dockerfile": "FROM ubuntu\n\nARG port\n\nRUN apt update; apt -y install qemu-system-arm socat\n\nCOPY target/thumbv7m-none-eabi/release/courier /opt/chal/courier\nCOPY target/thumbv7m-none-eabi/release/consignee /opt/chal/consignee\n\nADD entrypoint.sh /opt/chal/entrypoint.sh\nRUN chmod +x /opt/chal/entrypoint.sh\n\nENV PORT ${port}\n\nWORKDIR /tmp\n\nCMD [\"bash\", \"-c\", \"socat -d -d TCP-LISTEN:$PORT,reuseaddr,fork EXEC:/opt/chal/entrypoint.sh\"]\n",
    "entrypoint.sh": "#!/usr/bin/env bash\n\nset -m\n\nchallenge_base=\"/opt/chal\"\n\nsocks=\"$(mktemp -d)\"\n\ncleanup() {\n  trap \"\" INT TERM EXIT\n  kill $(jobs -p) 2>/dev/null || true\n  rm -rf \"${socks}\"\n}\n\ntrap cleanup INT TERM EXIT\n\nqemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -display none -semihosting-config enable=on,target=native -serial unix:\"${socks}/consignee\",server -kernel \"${challenge_base}/consignee\" &\nqemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -display none -semihosting-config enable=on,target=native -serial unix:\"${socks}/sender\",server -serial unix:\"${socks}/consignee\" -kernel \"${challenge_base}/courier\" &\nsleep .5\nsocat - UNIX-CONNECT:\"${socks}/sender\"\n",
    "flag.txt": "gigem{what_is_old_becomes_new_again}",
    "Makefile": "NAME := courier\nPORT := 42069\n\nall: dist docker\n\nstamp.key:\n\thead -c64 /dev/urandom > stamp.key\n\ndocker: Dockerfile stamp.key\n\tcargo build --release --features debug --target thumbv7m-none-eabi -p courier -p consignee\n\tdocker build -t $(NAME) --build-arg port=$(PORT) .\n\nrun: stop docker dist\n\tdocker run -d --read-only --restart=always --mount type=tmpfs,destination=/tmp --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nstop:\n\tdocker rm -f $(NAME)\n\nlogs:\n\tdocker logs -f $(NAME)\n\nclean: stop\n\tdocker rmi $(NAME)\n\ndist: consignee courier courier-proto lm3s6965-uart sender stamper Cargo.lock Cargo.toml Dockerfile entrypoint.sh Makefile\n\ttar czvf courier.tar.gz $^\n\n",
    "README.md": "# Courier\n\nAuthor: `Addison`\n\nSpecial delivery! This device emulates a delivery system, but we don't have the ability to connect to the stamping\ndevice. Can you trick the target into leaking the flag?\n\nConnections to `TODO` will connect you to the UART of the device. You can test with the provided files (just\ninstall Rust with the `thumbv7m-none-eabi` target). We've provided the `sender/` implementation as a reference.\n\nHint: There are very few comments. The ones that are present are extremely relevant to the intended solution.\n\n## Dev Notes\n\nContestants are provided with the courier.tar.gz (`make dist`) as well as connection details. You can test locally with\n`make run` and connect to port 42069 on localhost.\n\nHints: (avoid using these if possible; if necessary, view in order and let me know which are viewed)\n\n<details>\n\n<summary>Hint 1</summary>\n\nDon't worry too much about the UART implementation. It's mostly sane. Look at the implementation details of courier,\nconsignee, and courier-proto instead.\n\n</details>\n\n<details>\n\n<summary>Hint 2</summary>\n\nWhat's strange about courier-proto's `try_read_msg`? What happens to the input stream when an error occurs?\n\n</details>\n\n## Solution\n\nSee `solution` for details.\n\nFlag: `gigem{what_is_old_becomes_new_again}`",
    ".cargo\\config.toml": "[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\nrunner = \"gdb-multiarch -q -x openocd.gdb\"\nrustflags = [\n  \"-C\", \"link-arg=-Tlink.x\",\n]",
    "consignee\\Cargo.toml": "[package]\nname = \"consignee\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[features]\ndebug = [\"cortex-m-semihosting\", \"panic-semihosting\"]\n\n[dependencies]\ncortex-m = { version = \"0.7.6\", features = [\"critical-section-single-core\"] }\ncortex-m-rtic = \"1.1.3\"\ncortex-m-semihosting = { version = \"0.5.0\", optional = true }\ncourier-proto = { path = \"../courier-proto\" }\nembedded-alloc = { git = \"https://github.com/rust-embedded/embedded-alloc.git\", rev = \"89cb8d50e6634130302cd444b3f547aed0fd32dc\" }\nlm3s6965 = { git = \"https://github.com/japaric/lm3s6965.git\", rev = \"facf63aa0169c773175a143f6014a1d0977fb74f\" }\nlm3s6965-uart = { path = \"../lm3s6965-uart\" }\npanic-semihosting = { version = \"0.6.0\", features = [\"exit\"], optional = true }\npostcard = { version = \"1.0\", features = [\"alloc\"] }\n",
    "consignee\\.cargo\\config.toml": "[target.thumbv7m-none-eabi]\nrunner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -serial tcp:127.0.0.1:31337,server,nodelay -kernel\"\n",
    "consignee\\src\\main.rs": "#![deny(unsafe_code)]\n#![deny(warnings)]\n#![allow(unused_variables)] // for featuring\n#![no_main]\n#![no_std]\n#![feature(alloc_error_handler)]\n\nextern crate alloc;\n\n#[cfg(feature = \"debug\")]\nuse cortex_m_semihosting::{\n    debug::{exit, EXIT_FAILURE},\n    heprintln,\n};\n#[cfg(feature = \"debug\")]\nuse panic_semihosting as _;\n\nuse core::alloc::Layout;\nuse embedded_alloc::Heap;\n\nconst HEAP_SIZE: usize = 1 << 14;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\npub fn hailstone(value: u16) -> u16 {\n    let mut steps = 0;\n    let mut current = value as u32;\n    while current > 1 {\n        if current % 2 == 0 {\n            current = current / 2;\n        } else {\n            current = 3 * current + 1;\n        }\n        steps += 1;\n    }\n    steps\n}\n\n#[rtic::app(device = lm3s6965, dispatchers = [GPIOA, GPIOB])]\nmod app {\n    use crate::{hailstone, HEAP, HEAP_SIZE};\n    use alloc::format;\n    use alloc::string::ToString;\n    use alloc::vec::Vec;\n    #[cfg(feature = \"debug\")]\n    use cortex_m_semihosting::heprintln;\n    use courier_proto::messages::{\n        CourieredPackage, ResponsePackage, StampRequiredPackage, UnstampedPackage,\n    };\n    use courier_proto::{into_msg, try_read_msg, ReadMsgError};\n    use lm3s6965_uart::{\n        ManageUART, ReadUART, UARTAddress, UARTPeripheral, UARTPeripheralManageHalf,\n        UARTPeripheralReadHalf, UARTPeripheralWriteHalf, WriteUART,\n    };\n\n    #[shared]\n    struct Shared {}\n\n    #[local]\n    struct Local {\n        courier_manage: UARTPeripheralManageHalf,\n        courier_rx: UARTPeripheralReadHalf,\n        courier_tx: UARTPeripheralWriteHalf,\n        next_msg: Option<CourieredPackage>,\n        rx_buf: Vec<u8>,\n    }\n\n    #[init]\n    #[allow(unsafe_code)]\n    fn init(_: init::Context) -> (Shared, Local, init::Monotonics) {\n        {\n            use core::mem::MaybeUninit;\n            static mut HEAP_MEM: [MaybeUninit<u8>; HEAP_SIZE] = [MaybeUninit::uninit(); HEAP_SIZE];\n            unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n        }\n\n        let (courier_manage, courier_rx, courier_tx) =\n            unsafe { UARTPeripheral::new(UARTAddress::UART0) }\n                .enable_transmit(true)\n                .enable_receive(true)\n                .enable_fifo(true)\n                .enable_break_interrupt(true)\n                .enable_receive_interrupt(true)\n                .finish()\n                .split();\n\n        (\n            Shared {},\n            Local {\n                courier_manage,\n                courier_rx,\n                courier_tx,\n                next_msg: None,\n                rx_buf: Vec::new(),\n            },\n            init::Monotonics(),\n        )\n    }\n\n    #[idle]\n    fn idle(_: idle::Context) -> ! {\n        loop {\n            cortex_m::asm::wfi(); // peacefully sleep *honk mimimimi*\n        }\n    }\n\n    #[task(binds = UART0, priority = 1, local = [courier_rx, next_msg, rx_buf])]\n    fn recv_msg(cx: recv_msg::Context) {\n        let next_msg = cx.local.next_msg;\n        if let Some(msg) = next_msg.take() {\n            if let Err(failed_msg) = respond_to_msg::spawn(msg) {\n                *next_msg = Some(failed_msg);\n                return;\n            }\n        }\n\n        let uart = cx.local.courier_rx;\n        let rx_buf = cx.local.rx_buf;\n\n        while uart.rx_avail() {\n            let Ok(b) = uart.readb() else { return; };\n            rx_buf.push(b);\n            // reduced size since we have to deserialise the signed packages\n            match try_read_msg::<_, { 1 << 10 }, true>(rx_buf) {\n                Err(ReadMsgError::NotYetDone) => {}\n                Ok(msg) => {\n                    if let Err(msg) = respond_to_msg::spawn(msg) {\n                        *next_msg = Some(msg);\n                        return;\n                    }\n                }\n                Err(e) => {\n                    #[cfg(feature = \"debug\")]\n                    heprintln!(\"error while processing: {:?}\", e);\n                }\n            }\n        }\n    }\n\n    #[task(priority = 2, capacity = 4, local = [courier_manage, courier_tx])]\n    fn respond_to_msg(cx: respond_to_msg::Context, msg: CourieredPackage) {\n        let resp = match msg {\n            CourieredPackage::Unstamped(unstamped) => match unstamped {\n                UnstampedPackage::HailstoneRequest(base) => {\n                    ResponsePackage::HailstoneResponse(hailstone(base))\n                }\n            },\n            CourieredPackage::Stamped(stamped) => {\n                let stamped = match stamped.unpack() {\n                    Ok(pkg) => pkg,\n                    Err(e) => {\n                        #[cfg(feature = \"debug\")]\n                        heprintln!(\"couldn't deserialised a signed package: {:?}\", e);\n                        return;\n                    }\n                };\n                match stamped {\n                    StampRequiredPackage::WeddingInvitation { .. } => {\n                        ResponsePackage::WeddingResponse(\n                            \"Oh! How kind! I don't think I can make it... :(\".to_string(),\n                        )\n                    }\n                    StampRequiredPackage::FlagRequest => ResponsePackage::FlagResponse(format!(\n                        \"Oh, sure! Here you go: {}\",\n                        include_str!(\"../../flag.txt\")\n                    )),\n                }\n            }\n            CourieredPackage::Response(_) => {\n                #[cfg(feature = \"debug\")]\n                heprintln!(\"bad delivery request detected: {:?}\", msg);\n                return;\n            }\n        };\n\n        let courier_manage = cx.local.courier_manage;\n        let courier_tx = cx.local.courier_tx;\n\n        courier_manage\n            .update_interrupts()\n            .update_transmit_interrupt(true)\n            .commit();\n\n        for b in into_msg(CourieredPackage::Response(resp)) {\n            while !courier_tx.tx_avail() {\n                cortex_m::asm::wfi();\n            }\n            courier_tx.writeb(b);\n        }\n\n        courier_manage\n            .update_interrupts()\n            .update_transmit_interrupt(false)\n            .commit();\n    }\n}\n\n#[alloc_error_handler]\nfn oom(_: Layout) -> ! {\n    #[cfg(feature = \"debug\")]\n    heprintln!(\"Whoops! Ran out of memory while executing.\");\n    #[cfg(feature = \"debug\")]\n    exit(EXIT_FAILURE);\n\n    loop {\n        cortex_m::asm::nop();\n    }\n}\n\n#[cfg(not(feature = \"debug\"))]\n#[panic_handler]\nfn panic_handler(_: &core::panic::PanicInfo) -> ! {\n    loop {\n        cortex_m::asm::nop()\n    }\n}\n",
    "courier\\Cargo.toml": "[package]\nname = \"courier\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[features]\ndebug = [\"cortex-m-semihosting\", \"panic-semihosting\"]\n\n[dependencies]\ncortex-m = { version = \"0.7.6\", features = [\"critical-section-single-core\"] }\ncortex-m-rtic = \"1.1.3\"\ncortex-m-semihosting = { version = \"0.5.0\", optional = true }\ncourier-proto = { path = \"../courier-proto\", features = [\"stamps\"] }\nembedded-alloc = { git = \"https://github.com/rust-embedded/embedded-alloc.git\", rev = \"89cb8d50e6634130302cd444b3f547aed0fd32dc\" }\nlm3s6965 = { git = \"https://github.com/japaric/lm3s6965.git\", rev = \"facf63aa0169c773175a143f6014a1d0977fb74f\" }\nlm3s6965-uart = { path = \"../lm3s6965-uart\" }\npanic-semihosting = { version = \"0.6.0\", features = [\"exit\"], optional = true }\n",
    "courier\\.cargo\\config.toml": "[target.thumbv7m-none-eabi]\nrunner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -serial tcp:127.0.0.1:21337,server,nodelay -serial tcp:127.0.0.1:31337,nodelay -kernel\"\n",
    "courier\\src\\main.rs": "#![deny(unsafe_code)]\n#![deny(warnings)]\n#![allow(unused_variables)] // for featuring\n#![no_main]\n#![no_std]\n#![feature(alloc_error_handler)]\n\nextern crate alloc;\n\n#[cfg(feature = \"debug\")]\nuse cortex_m_semihosting::{\n    debug::{exit, EXIT_FAILURE},\n    heprintln,\n};\n#[cfg(feature = \"debug\")]\nuse panic_semihosting as _;\n\nuse core::alloc::Layout;\nuse embedded_alloc::Heap;\n\nconst HEAP_SIZE: usize = 1 << 14;\n\nconst STAMP_KEY: &[u8; 64] = include_bytes!(\"../../stamp.key\");\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n#[rtic::app(device = lm3s6965, dispatchers = [GPIOA, GPIOB, GPIOC])]\nmod app {\n    use crate::{HEAP, HEAP_SIZE, STAMP_KEY};\n    use alloc::vec::Vec;\n    use core::mem::swap;\n    #[cfg(feature = \"debug\")]\n    use cortex_m_semihosting::heprintln;\n    use courier_proto::messages::CourieredPackage;\n    use courier_proto::stamps::check_stamp;\n    use courier_proto::{into_msg, try_read_msg, ReadMsgError};\n    use lm3s6965_uart::{\n        ManageUART, ReadUART, UARTAddress, UARTPeripheral, UARTPeripheralManageHalf,\n        UARTPeripheralReadHalf, UARTPeripheralWriteHalf, WriteUART,\n    };\n\n    #[shared]\n    struct Shared {}\n\n    #[local]\n    struct Local {\n        sender_manage: UARTPeripheralManageHalf,\n        sender_rx: UARTPeripheralReadHalf,\n        sender_tx: UARTPeripheralWriteHalf,\n        consignee_manage: UARTPeripheralManageHalf,\n        consignee_rx: UARTPeripheralReadHalf,\n        consignee_tx: UARTPeripheralWriteHalf,\n        stamp_ctr: u64,\n        next_msg_sender: Option<CourieredPackage>,\n        next_msg_consignee: Option<(Vec<u8>, CourieredPackage)>,\n        rx_buf_sender: Vec<u8>,\n        rx_buf_consignee: Vec<u8>,\n    }\n\n    #[init]\n    #[allow(unsafe_code)]\n    #[allow(unreachable_code)]\n    fn init(_: init::Context) -> (Shared, Local, init::Monotonics) {\n        {\n            use core::mem::MaybeUninit;\n            static mut HEAP_MEM: [MaybeUninit<u8>; HEAP_SIZE] = [MaybeUninit::uninit(); HEAP_SIZE];\n            unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n        }\n\n        let (sender_manage, sender_rx, sender_tx) =\n            unsafe { UARTPeripheral::new(UARTAddress::UART0) }\n                .enable_transmit(true)\n                .enable_receive(true)\n                .enable_fifo(true)\n                .enable_break_interrupt(true)\n                .enable_receive_interrupt(true)\n                .finish()\n                .split();\n\n        let (consignee_manage, consignee_rx, consignee_tx) =\n            unsafe { UARTPeripheral::new(UARTAddress::UART1) }\n                .enable_transmit(true)\n                .enable_receive(true)\n                .enable_fifo(true)\n                .enable_break_interrupt(true)\n                .enable_receive_interrupt(true)\n                .finish()\n                .split();\n\n        (\n            Shared {},\n            Local {\n                sender_manage,\n                sender_rx,\n                sender_tx,\n                consignee_manage,\n                consignee_rx,\n                consignee_tx,\n                stamp_ctr: 0,\n                next_msg_sender: None,\n                next_msg_consignee: None,\n                rx_buf_sender: Vec::new(),\n                rx_buf_consignee: Vec::new(),\n            },\n            init::Monotonics(),\n        )\n    }\n\n    #[idle]\n    fn idle(_: idle::Context) -> ! {\n        loop {\n            cortex_m::asm::wfi(); // peacefully sleep *honk mimimimi*\n        }\n    }\n\n    #[task(binds = UART0, priority = 1, local = [sender_rx, next_msg_consignee, rx_buf_sender])]\n    fn recv_msg_sender(cx: recv_msg_sender::Context) {\n        let next_msg = cx.local.next_msg_consignee;\n        if let Some(msg) = next_msg.take() {\n            if let Err(failed_msg) = send_msg_consignee::spawn(msg) {\n                *next_msg = Some(failed_msg);\n                return;\n            }\n        }\n\n        let uart = cx.local.sender_rx;\n        let rx_buf = cx.local.rx_buf_sender;\n\n        while uart.rx_avail() {\n            let Ok(b) = uart.readb() else { return; };\n            rx_buf.push(b);\n            match try_read_msg::<_, { 1 << 12 }, false>(rx_buf) {\n                Err(ReadMsgError::NotYetDone) => {}\n                Ok(msg) => {\n                    let mut prev_buf = Vec::new();\n                    swap(rx_buf, &mut prev_buf);\n                    if let Err(msg) = send_msg_consignee::spawn((prev_buf, msg)) {\n                        *next_msg = Some(msg);\n                        return;\n                    }\n                }\n                Err(e) => {\n                    #[cfg(feature = \"debug\")]\n                    heprintln!(\"error while processing: {:?}\", e);\n                }\n            }\n        }\n    }\n\n    #[task(priority = 3, capacity = 1, local = [consignee_manage, consignee_tx, stamp_ctr])]\n    fn send_msg_consignee(\n        cx: send_msg_consignee::Context,\n        (prev_buf, msg): (Vec<u8>, CourieredPackage),\n    ) {\n        match &msg {\n            CourieredPackage::Unstamped(_) => {}\n            CourieredPackage::Stamped(stamped) => {\n                let stamp_ctr = cx.local.stamp_ctr;\n                match check_stamp(stamp_ctr, STAMP_KEY, stamped) {\n                    Ok(_) => {}\n                    Err(e) => {\n                        #[cfg(feature = \"debug\")]\n                        heprintln!(\"stamp check failed: {:?}\", e);\n                        return; // we received an invalid stamp/message\n                    }\n                }\n            }\n            msg => {\n                #[cfg(feature = \"debug\")]\n                heprintln!(\"bad delivery request detected: {:?}\", msg);\n                return;\n            }\n        };\n        drop(msg);\n\n        let consignee_manage = cx.local.consignee_manage;\n        let consignee_tx = cx.local.consignee_tx;\n\n        consignee_manage\n            .update_interrupts()\n            .update_transmit_interrupt(true)\n            .commit();\n\n        for b in prev_buf {\n            while !consignee_tx.tx_avail() {\n                cortex_m::asm::wfi();\n            }\n            consignee_tx.writeb(b);\n        }\n\n        consignee_manage\n            .update_interrupts()\n            .update_transmit_interrupt(false)\n            .commit();\n    }\n\n    #[task(binds = UART1, priority = 2, local = [consignee_rx, next_msg_sender, rx_buf_consignee])]\n    fn recv_msg_consignee(cx: recv_msg_consignee::Context) {\n        let next_msg = cx.local.next_msg_sender;\n        if let Some(msg) = next_msg.take() {\n            if let Err(failed_msg) = send_msg_sender::spawn(msg) {\n                *next_msg = Some(failed_msg);\n                return;\n            }\n        }\n\n        let uart = cx.local.consignee_rx;\n        let rx_buf = cx.local.rx_buf_consignee;\n\n        while uart.rx_avail() {\n            let Ok(b) = uart.readb() else { return; };\n            rx_buf.push(b);\n            match try_read_msg::<_, { 1 << 12 }, true>(rx_buf) {\n                Err(ReadMsgError::NotYetDone) => {}\n                Ok(msg) => {\n                    if let Err(msg) = send_msg_sender::spawn(msg) {\n                        *next_msg = Some(msg);\n                        return;\n                    }\n                }\n                Err(e) => {\n                    #[cfg(feature = \"debug\")]\n                    heprintln!(\"error while processing: {:?}\", e);\n                }\n            }\n        }\n    }\n\n    #[task(priority = 4, capacity = 1, local = [sender_manage, sender_tx])]\n    fn send_msg_sender(cx: send_msg_sender::Context, msg: CourieredPackage) {\n        if !matches!(msg, CourieredPackage::Response(_)) {\n            #[cfg(feature = \"debug\")]\n            heprintln!(\"bad delivery response detected: {:?}\", msg);\n            return;\n        }\n\n        let sender_manage = cx.local.sender_manage;\n        let sender_tx = cx.local.sender_tx;\n\n        sender_manage\n            .update_interrupts()\n            .update_transmit_interrupt(true)\n            .commit();\n\n        for b in into_msg(msg) {\n            while !sender_tx.tx_avail() {\n                cortex_m::asm::wfi();\n            }\n            sender_tx.writeb(b);\n        }\n\n        sender_manage\n            .update_interrupts()\n            .update_transmit_interrupt(false)\n            .commit();\n    }\n}\n\n#[alloc_error_handler]\nfn oom(_: Layout) -> ! {\n    #[cfg(feature = \"debug\")]\n    heprintln!(\"Whoops! Ran out of memory while executing.\");\n    #[cfg(feature = \"debug\")]\n    exit(EXIT_FAILURE);\n\n    loop {\n        cortex_m::asm::nop();\n    }\n}\n\n#[cfg(not(feature = \"debug\"))]\n#[panic_handler]\nfn panic_handler(_: &core::panic::PanicInfo) -> ! {\n    loop {\n        cortex_m::asm::nop()\n    }\n}\n",
    "courier-proto\\Cargo.toml": "[package]\nname = \"courier-proto\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[features]\nsemihosted-debug = [\"cortex-m-semihosting\"]\ndebug = [\"std\"]\nstd = []\nstamps = [\"hmac\"]\n\n[dependencies]\ncortex-m-semihosting = { version = \"0.5.0\", optional = true }\nheapless = \"0.7.16\"\nhmac = { version = \"0.12.1\", default-features = false, optional = true }\npostcard = { version = \"1.0\", features = [\"alloc\"] }\nsha2 = { version = \"0.10.6\", default-features = false }\nserde = { version = \"1.0\", default-features = false, features = [\"derive\", \"alloc\"] }",
    "courier-proto\\src\\lib.rs": "#![cfg_attr(not(feature = \"std\"), no_std)]\n#![feature(iterator_try_collect)]\n#![cfg_attr(feature = \"std\", feature(io_error_more))]\n\npub mod messages;\n#[cfg(feature = \"stamps\")]\npub mod stamps;\n\nextern crate alloc;\n\n#[cfg(feature = \"std\")]\nuse std::io::{ErrorKind, Read};\n\nuse alloc::vec::Vec;\nuse postcard::Error;\nuse serde::{Deserialize, Serialize};\n\npub const MSG_MAGIC: &[u8] = b\"COURIERM\";\n\n#[derive(Debug)]\npub enum ReadMsgError {\n    NotYetDone,\n    #[cfg(feature = \"std\")]\n    IoError(std::io::Error),\n    PostcardError(Error),\n    MessageTooLong,\n}\n\nimpl From<Error> for ReadMsgError {\n    fn from(value: Error) -> Self {\n        ReadMsgError::PostcardError(value)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl From<std::io::Error> for ReadMsgError {\n    fn from(value: std::io::Error) -> Self {\n        ReadMsgError::IoError(value)\n    }\n}\n\npub fn try_read_msg<M: for<'a> Deserialize<'a>, const MAX_SIZE: u16, const CLEAR_ON_DESER: bool>(\n    buf: &mut Vec<u8>,\n) -> Result<M, ReadMsgError> {\n    if buf.len() >= MSG_MAGIC.len() + core::mem::size_of::<u16>() {\n        let mut len_buf = [0u8; core::mem::size_of::<u16>()];\n        buf.iter()\n            .copied()\n            .skip(MSG_MAGIC.len())\n            .take(core::mem::size_of::<u16>())\n            .zip(&mut len_buf)\n            .for_each(|(b, e)| *e = b);\n        let msg_len = u16::from_be_bytes(len_buf);\n        if msg_len > MAX_SIZE {\n            #[cfg(feature = \"semihosted-debug\")]\n            cortex_m_semihosting::heprintln!(\n                \"message would have exceeded max length: {} / {}\",\n                msg_len,\n                MAX_SIZE\n            );\n\n            buf.clear();\n            return Err(ReadMsgError::MessageTooLong);\n        }\n\n        #[cfg(feature = \"semihosted-debug\")]\n        cortex_m_semihosting::heprintln!(\n            \"attempting read of a message with length: {} / {}\",\n            buf.len(),\n            MSG_MAGIC.len() + core::mem::size_of::<u16>() + msg_len as usize\n        );\n\n        if buf.len() == MSG_MAGIC.len() + core::mem::size_of::<u16>() + msg_len as usize {\n            #[cfg(feature = \"semihosted-debug\")]\n            cortex_m_semihosting::heprintln!(\"reading a message with length: {}\", msg_len);\n\n            let value =\n                postcard::from_bytes(&buf[(MSG_MAGIC.len() + core::mem::size_of::<u16>())..])?;\n            if CLEAR_ON_DESER {\n                buf.clear();\n            }\n            return Ok(value);\n        }\n    } else if buf.len() <= MSG_MAGIC.len() {\n        if let Some(last) = buf.last().copied() {\n            if last != MSG_MAGIC[buf.len() - 1] {\n                #[cfg(feature = \"semihosted-debug\")]\n                cortex_m_semihosting::heprintln!(\"failed the magic check: {:?}\", buf);\n\n                buf.clear();\n                buf.push(last); // we might actually be handling the next valid input!\n            }\n        }\n    }\n\n    Err(ReadMsgError::NotYetDone)\n}\n\n#[cfg(feature = \"std\")]\npub fn read_msg<R: Read, M: for<'a> Deserialize<'a>, const MAX_SIZE: u16>(\n    reader: &mut R,\n) -> Result<M, ReadMsgError> {\n    let mut bytes = reader.bytes();\n\n    {\n        let mut magic = heapless::Vec::<_, { MSG_MAGIC.len() }>::new();\n        loop {\n            if let Some(last) = magic.last().copied() {\n                if last != MSG_MAGIC[magic.len() - 1] {\n                    magic.clear();\n                    magic.push(last).unwrap();\n                    continue;\n                }\n            }\n            if magic.len() == MSG_MAGIC.len() {\n                break;\n            }\n            magic.push(bytes.next().unwrap()?).unwrap();\n        }\n    }\n\n    let mut len_buf = [0u8; core::mem::size_of::<u16>()];\n    (&mut bytes)\n        .take(core::mem::size_of::<u16>())\n        .zip(&mut len_buf)\n        .try_for_each(|(b, e)| {\n            *e = b?;\n            Ok::<_, std::io::Error>(())\n        })?;\n    let msg_len = u16::from_be_bytes(len_buf);\n    if msg_len > MAX_SIZE {\n        Err(std::io::Error::from(ErrorKind::FileTooLarge).into())\n    } else {\n        Ok(postcard::from_bytes(\n            &bytes.take(msg_len as usize).try_collect::<Vec<_>>()?,\n        )?)\n    }\n}\n\npub fn into_msg<M: Serialize>(value: M) -> impl Iterator<Item = u8> + Send {\n    let serialised = postcard::to_allocvec(&value).unwrap();\n    assert!(serialised.len() <= u16::MAX as usize);\n    MSG_MAGIC\n        .iter()\n        .copied()\n        .chain((serialised.len() as u16).to_be_bytes())\n        .chain(serialised)\n}\n",
    "courier-proto\\src\\messages.rs": "use alloc::string::String;\nuse alloc::vec::Vec;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize)]\npub enum UnstampedPackage {\n    HailstoneRequest(u16),\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub enum StampRequiredPackage {\n    WeddingInvitation {\n        when: u64,\n        marrying_parties: Vec<String>,\n        details: Vec<u8>,\n    },\n    FlagRequest,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub enum ResponsePackage {\n    HailstoneResponse(u16),\n    WeddingResponse(String),\n    FlagResponse(String),\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub enum CourieredPackage {\n    Unstamped(UnstampedPackage),\n    Stamped(StampedPackage),\n    Response(ResponsePackage),\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct StampedPackage {\n    pub ctr: u64,\n    pub hmac: [u8; 32],\n    pub stamped_payload: Vec<u8>,\n}\n\nimpl StampedPackage {\n    pub fn unpack(self) -> Result<StampRequiredPackage, postcard::Error> {\n        postcard::from_bytes(&self.stamped_payload)\n    }\n}\n",
    "courier-proto\\src\\stamps.rs": "use crate::messages::{StampRequiredPackage, StampedPackage};\nuse hmac::digest::{FixedOutput, KeyInit};\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\n\npub type StampHmac = Hmac<Sha256>;\n\n#[derive(Debug)]\npub enum StampError {\n    InvalidCtr,\n    InvalidStamp,\n    Postcard(postcard::Error),\n}\n\nimpl From<postcard::Error> for StampError {\n    fn from(value: postcard::Error) -> Self {\n        StampError::Postcard(value)\n    }\n}\n\npub fn stamp(\n    ctr: &mut u64,\n    key: &[u8; 64],\n    package: StampRequiredPackage,\n) -> Result<StampedPackage, StampError> {\n    let payload = postcard::to_allocvec(&package)?;\n    let mut hmac = <StampHmac as KeyInit>::new_from_slice(key).unwrap();\n    hmac.update(&ctr.to_be_bytes());\n    hmac.update(&payload);\n    let hmac = hmac.finalize_fixed();\n\n    let result = StampedPackage {\n        ctr: *ctr,\n        hmac: hmac.into(),\n        stamped_payload: payload,\n    };\n\n    *ctr += 1;\n\n    Ok(result)\n}\n\npub fn check_stamp(\n    ctr: &mut u64,\n    key: &[u8; 64],\n    package: &StampedPackage,\n) -> Result<(), StampError> {\n    if package.ctr < *ctr {\n        return Err(StampError::InvalidCtr);\n    }\n\n    let mut hmac = <StampHmac as KeyInit>::new_from_slice(key).unwrap();\n    hmac.update(&package.ctr.to_be_bytes());\n    hmac.update(&package.stamped_payload);\n    if hmac.verify(&package.hmac.into()).is_err() {\n        return Err(StampError::InvalidStamp);\n    }\n\n    *ctr = package.ctr + 1; // redemption\n\n    Ok(())\n}\n",
    "lm3s6965-uart\\Cargo.toml": "[package]\nname = \"lm3s6965-uart\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nvolatile-register = \"0.2.1\"\n",
    "lm3s6965-uart\\src\\consts.rs": "pub const UARTDR_MASK: u32 = 0x0fff;\npub const UARTDR_OE: u32 = 0b100000000000;\npub const UARTDR_BE: u32 = 0b010000000000;\npub const UARTDR_PE: u32 = 0b001000000000;\npub const UARTDR_FE: u32 = 0b000100000000;\npub const UARTDR_ERR: u32 = 0x0f00;\npub const UARTDR_DATA: u32 = 0x00ff;\n\npub const UARTRSR_MASK: u32 = 0b1111;\npub const UARTRSR_OE: u32 = 0b1000;\npub const UARTRSR_BE: u32 = 0b0100;\npub const UARTRSR_PE: u32 = 0b0010;\npub const UARTRSR_FE: u32 = 0b0001;\npub const UARTRSR_ERR: u32 = UARTRSR_MASK;\n\npub const UARTFR_MASK: u32 = 0b11111000;\npub const UARTFR_TXFE: u32 = 0b10000000;\npub const UARTFR_RXFF: u32 = 0b01000000;\npub const UARTFR_TXFF: u32 = 0b00100000;\npub const UARTFR_RXFE: u32 = 0b00010000;\npub const UARTFR_BUSY: u32 = 0b00001000;\n\npub const UARTCTL_MASK: u32 = 0b1110000111;\npub const UARTCTL_RXE: u32 = 0b1000000000;\npub const UARTCTL_TXE: u32 = 0b0100000000;\npub const UARTCTL_LBE: u32 = 0b0010000000;\npub const UARTCTL_SIRLP: u32 = 0b0000000100;\npub const UARTCTL_SIREN: u32 = 0b0000000010;\npub const UARTCTL_UARTEN: u32 = 0b0000000001;\n\npub const UARTIBRD_MASK: u32 = 0xffff;\npub const UARTFBRD_MASK: u32 = 0b111111;\n\npub const UARTLCRH_MASK: u32 = 0b11111111;\npub const UARTLCRH_FEN: u32 = 0b00010000;\n\npub const UARTIM_MASK: u32 = 0b11111110000;\npub const UARTIM_OEIM: u32 = 0b10000000000;\npub const UARTIM_BEIM: u32 = 0b01000000000;\npub const UARTIM_PEIM: u32 = 0b00100000000;\npub const UARTIM_FEIM: u32 = 0b00010000000;\npub const UARTIM_RTIM: u32 = 0b00001000000;\npub const UARTIM_TXIM: u32 = 0b00000100000;\npub const UARTIM_RXIM: u32 = 0b00000010000;\n",
    "lm3s6965-uart\\src\\lib.rs": "// this file modified from: https://github.com/TAMU-CSE/mitre-ectf2021/blob/master/controller/scewl-rust/src/interface.rs\n#![allow(unsafe_code)]\n#![allow(clippy::upper_case_acronyms)]\n#![allow(warnings)]\n#![no_std]\n\nuse core::fmt::{Debug, Formatter, Pointer};\n\nuse volatile_register::{RO, RW, WO};\n\nmod consts;\nuse consts::*;\n\n/// The UART struct as specified by the CMSIS specification (and, more specifically, [line 620 of `lm3s_cmsis.h`](https://github.com/mitre-cyber-academy/2021-ectf-insecure-example/blob/master/controller/lm3s/lm3s_cmsis.h#L620))\n///\n/// This implementation differs slightly in that [volatile registers](https://docs.rs/volatile-register/0.2.0/volatile_register/)\n/// are used in place of type metadata [as defined in `core_cm3.h`](https://github.com/mitre-cyber-academy/2021-ectf-insecure-example/blob/master/controller/CMSIS/Include/core_cm3.h#L197)\n/// to compile-time enforce appropriate reading and writing to these registers.\n///\n/// Otherwise, this struct should never be instantiated, but instead static mutable references to\n/// raw pointers (which point to the [various memory-mapped UART peripherals](https://github.com/mitre-cyber-academy/2021-ectf-insecure-example/blob/master/controller/lm3s/lm3s_cmsis.h#L876))\n/// should be derived via [raw pointer to reference casting](https://docs.rust-embedded.org/book/c-tips/index.html#references-vs-pointers).\n#[repr(C)]\npub struct RawUART {\n    /// Data register\n    dr: RW<u32>,\n    /// Receive status register\n    rsr: RW<u32>,\n    /// A reserved region with no explicit use\n    reserved1: [u8; 16],\n    /// Flag register\n    fr: RO<u32>,\n    /// A reserved region with no explicit use\n    reserved2: [u8; 4],\n    /// UART IrDA low-power register\n    ilpr: RW<u32>,\n    /// Integer baud rate divisor register\n    ibrd: RW<u32>,\n    /// Fractional baud rate divisor register\n    fbrd: RW<u32>,\n    /// UART line control\n    lcrh: RW<u32>,\n    /// Control register\n    ctl: RW<u32>,\n    /// Interrupt FIFO level select register\n    ifls: RW<u32>,\n    /// Interrupt mask set/clear register\n    im: RW<u32>,\n    /// Raw interrupt status register\n    ris: RO<u32>,\n    /// Masked interrupt status register\n    mis: RO<u32>,\n    /// Interrupt clear register\n    icr: WO<u32>,\n    /// UART DMA control\n    dmactl: RW<u32>,\n}\n\n/// Memory-mapped UART peripheral addresses for the different serial lines, which will then be\n/// copied to the sockets for the respective data lines being emulated\n#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Copy, Clone)]\npub enum UARTAddress {\n    /// Address of UART0\n    UART0 = 0x4000_C000,\n    /// Address of UART1\n    UART1 = 0x4000_D000,\n    /// Address of UART2\n    UART2 = 0x4000_E000,\n}\n\npub trait AsRawUART {\n    fn uart<'a>(&mut self) -> &'a mut RawUART;\n}\n\npub struct ReadError<const ERR_ONLY: bool> {\n    read: u32,\n}\n\nimpl ReadError<true> {\n    pub fn overrun(&self) -> bool {\n        self.read & UARTRSR_OE != 0\n    }\n\n    pub fn broken(&self) -> bool {\n        self.read & UARTRSR_BE != 0\n    }\n\n    pub fn parity(&self) -> bool {\n        self.read & UARTRSR_PE != 0\n    }\n\n    pub fn framing(&self) -> bool {\n        self.read & UARTRSR_FE != 0\n    }\n\n    pub fn any(&self) -> bool {\n        self.read & UARTRSR_ERR != 0\n    }\n}\n\nimpl Debug for ReadError<true> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"ReadError\")\n            .field(\"is_overrun\", &self.overrun())\n            .field(\"is_broken\", &self.broken())\n            .field(\"parity_failed\", &self.parity())\n            .field(\"framing_failed\", &self.framing())\n            .finish()\n    }\n}\n\nimpl ReadError<false> {\n    pub fn overrun(&self) -> bool {\n        self.read & UARTDR_OE != 0\n    }\n\n    pub fn broken(&self) -> bool {\n        self.read & UARTDR_BE != 0\n    }\n\n    pub fn parity(&self) -> bool {\n        self.read & UARTDR_PE != 0\n    }\n\n    pub fn framing(&self) -> bool {\n        self.read & UARTDR_FE != 0\n    }\n\n    pub fn any(&self) -> bool {\n        self.read & UARTRSR_ERR != 0\n    }\n\n    pub fn data(&self) -> u8 {\n        self.read as u8\n    }\n}\n\nimpl Debug for ReadError<false> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"ReadError\")\n            .field(\"is_overrun\", &self.overrun())\n            .field(\"is_broken\", &self.broken())\n            .field(\"parity_failed\", &self.parity())\n            .field(\"framing_failed\", &self.framing())\n            .field(\"data\", &self.data())\n            .finish()\n    }\n}\n\nmacro_rules! define_modifier {\n    ($fn_name:ident, $field:ident, $bits:ident) => {\n        pub fn $fn_name(mut self, enable: bool) -> Self {\n            if enable {\n                self.$field |= $bits;\n            } else {\n                self.$field &= !$bits;\n            }\n            self\n        }\n    };\n}\n\npub struct UpdateUARTIM<'a, M: ManageUART> {\n    manager: &'a mut M,\n    im: u32,\n}\n\nimpl<'a, M: ManageUART> UpdateUARTIM<'a, M> {\n    define_modifier!(update_overflow_interrupt, im, UARTIM_OEIM);\n    define_modifier!(update_break_interrupt, im, UARTIM_BEIM);\n    define_modifier!(update_parity_interrupt, im, UARTIM_PEIM);\n    define_modifier!(update_framing_interrupt, im, UARTIM_FEIM);\n    define_modifier!(update_receive_timeout_interrupt, im, UARTIM_RTIM);\n    define_modifier!(update_transmit_interrupt, im, UARTIM_TXIM);\n    define_modifier!(update_receive_interrupt, im, UARTIM_RXIM);\n\n    pub fn commit(self) {\n        unsafe {\n            self.manager.uart().im.write(self.im);\n        }\n        self.manager.reset();\n    }\n}\n\npub trait ManageUART: AsRawUART + Sized {\n    fn update_interrupts(&mut self) -> UpdateUARTIM<Self> {\n        UpdateUARTIM {\n            im: self.uart().im.read(),\n            manager: self,\n        }\n    }\n\n    fn reset(&mut self) {\n        unsafe {\n            let prev = self.uart().ctl.read();\n            self.uart().ctl.write(prev & 0xffff_fffe);\n            self.uart().ctl.write(prev | 0x1);\n        }\n    }\n}\n\npub trait ReadUART: AsRawUART {\n    fn rx_avail(&mut self) -> bool {\n        self.uart().fr.read() & UARTFR_RXFE == 0\n    }\n\n    fn rx_error(&mut self) -> ReadError<true> {\n        let read = unsafe { self.uart().rsr.read() };\n        ReadError { read }\n    }\n\n    fn readb(&mut self) -> Result<u8, ReadError<false>> {\n        let read = unsafe { self.uart().dr.read() };\n        if read & UARTDR_ERR != 0 {\n            Err(ReadError { read })\n        } else {\n            Ok(read as u8)\n        }\n    }\n}\n\npub trait WriteUART: AsRawUART {\n    fn tx_avail(&mut self) -> bool {\n        self.uart().fr.read() & UARTFR_TXFF == 0\n    }\n\n    fn writeb(&mut self, b: u8) {\n        unsafe { self.uart().dr.write(b as u32) };\n    }\n}\n\n/// Wrapper type for interfacing with the UART peripherals\n///\n/// This type is effectively equivalent to the struct defined in the original C implementation, but\n/// methods are defined on the interface instead to restrict operations to a theoretically safe\n/// subset of operations on the UART peripheral.\npub struct UARTPeripheral {\n    /// The UART adapter to be manipulated by this wrapper\n    uart: *mut RawUART,\n}\n\npub struct UARTPeripheralReadHalf {\n    /// The UART adapter to be manipulated by this wrapper\n    uart: *mut RawUART,\n}\n\npub struct UARTPeripheralWriteHalf {\n    /// The UART adapter to be manipulated by this wrapper\n    uart: *mut RawUART,\n}\n\npub struct UARTPeripheralManageHalf {\n    /// The UART adapter to be manipulated by this wrapper\n    uart: *mut RawUART,\n}\n\nimpl AsRawUART for UARTPeripheral {\n    fn uart<'a>(&mut self) -> &'a mut RawUART {\n        unsafe { self.uart.as_mut().unwrap_unchecked() }\n    }\n}\n\nunsafe impl Send for UARTPeripheral {}\n\nimpl ManageUART for UARTPeripheral {}\nimpl ReadUART for UARTPeripheral {}\nimpl WriteUART for UARTPeripheral {}\n\nimpl AsRawUART for UARTPeripheralReadHalf {\n    fn uart<'a>(&mut self) -> &'a mut RawUART {\n        unsafe { self.uart.as_mut().unwrap_unchecked() }\n    }\n}\n\nunsafe impl Send for UARTPeripheralReadHalf {}\n\nimpl ReadUART for UARTPeripheralReadHalf {}\n\nimpl AsRawUART for UARTPeripheralWriteHalf {\n    fn uart<'a>(&mut self) -> &'a mut RawUART {\n        unsafe { self.uart.as_mut().unwrap_unchecked() }\n    }\n}\n\nunsafe impl Send for UARTPeripheralWriteHalf {}\n\nimpl WriteUART for UARTPeripheralWriteHalf {}\n\nimpl AsRawUART for UARTPeripheralManageHalf {\n    fn uart<'a>(&mut self) -> &'a mut RawUART {\n        unsafe { self.uart.as_mut().unwrap_unchecked() }\n    }\n}\n\nunsafe impl Send for UARTPeripheralManageHalf {}\n\nimpl ManageUART for UARTPeripheralManageHalf {}\n\npub struct UARTUpdater<M: ManageUART> {\n    inner: M,\n    ctl: u32,\n    ibrd: u32,\n    fbrd: u32,\n    lcrh: u32,\n    im: u32,\n}\n\nmacro_rules! define_enabler {\n    ($fn_name:ident, $field:ident, $bits:ident) => {\n        pub fn $fn_name(mut self, enable: bool) -> Self {\n            if enable {\n                self.$field |= $bits;\n            } else {\n                self.$field &= !$bits;\n            }\n            self\n        }\n    };\n}\n\nimpl<M: ManageUART> UARTUpdater<M> {\n    fn new(raw: M) -> Self {\n        Self {\n            inner: raw,\n            ctl: 0,\n            ibrd: 0xa,\n            fbrd: 0x36,\n            lcrh: 0x60,\n            im: 0x0,\n        }\n    }\n\n    define_enabler!(enable_receive, ctl, UARTCTL_RXE);\n    define_enabler!(enable_transmit, ctl, UARTCTL_TXE);\n    define_enabler!(enable_loopback, ctl, UARTCTL_LBE);\n    define_enabler!(enable_sir_lowpower, ctl, UARTCTL_SIRLP);\n    define_enabler!(enable_sir, ctl, UARTCTL_SIREN);\n\n    define_enabler!(enable_fifo, lcrh, UARTLCRH_FEN);\n\n    define_enabler!(enable_overflow_interrupt, im, UARTIM_OEIM);\n    define_enabler!(enable_break_interrupt, im, UARTIM_BEIM);\n    define_enabler!(enable_parity_interrupt, im, UARTIM_PEIM);\n    define_enabler!(enable_framing_interrupt, im, UARTIM_FEIM);\n    define_enabler!(enable_receive_timeout_interrupt, im, UARTIM_RTIM);\n    define_enabler!(enable_transmit_interrupt, im, UARTIM_TXIM);\n    define_enabler!(enable_receive_interrupt, im, UARTIM_RXIM);\n\n    pub fn finish(mut self) -> M {\n        let mut inner = self.inner;\n        let uart = inner.uart();\n\n        unsafe {\n            uart.ctl.write(uart.ctl.read() & 0xffff_fffe);\n\n            uart.ibrd\n                .write((uart.ibrd.read() & !UARTIBRD_MASK) | self.ibrd);\n            uart.fbrd\n                .write((uart.fbrd.read() & !UARTFBRD_MASK) | self.fbrd);\n            uart.lcrh\n                .write((uart.lcrh.read() & !UARTLCRH_MASK) | self.lcrh);\n            uart.im.write((uart.im.read() & !UARTIM_MASK) | self.im);\n            uart.ctl.write(uart.ctl.read() & !UARTCTL_MASK | self.ctl);\n\n            uart.ctl.write(uart.ctl.read() | 0x1);\n        }\n\n        inner\n    }\n}\n\nimpl UARTPeripheral {\n    pub unsafe fn new(addr: UARTAddress) -> UARTUpdater<Self> {\n        UARTUpdater::new(Self {\n            uart: &mut *(addr as usize as *mut RawUART),\n        })\n    }\n\n    pub fn split(\n        self,\n    ) -> (\n        UARTPeripheralManageHalf,\n        UARTPeripheralReadHalf,\n        UARTPeripheralWriteHalf,\n    ) {\n        #[allow(clippy::cast_ref_to_mut)]\n        (\n            UARTPeripheralManageHalf { uart: self.uart },\n            UARTPeripheralReadHalf { uart: self.uart },\n            UARTPeripheralWriteHalf { uart: self.uart },\n        )\n    }\n}\n",
    "sender\\Cargo.toml": "[package]\nname = \"sender\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\ncourier-proto = { path = \"../courier-proto\", features = [\"std\", \"stamps\"] }\npostcard = { version = \"1.0\", features = [\"alloc\"] }\n",
    "sender\\src\\main.rs": "use courier_proto::messages::ResponsePackage::FlagResponse;\nuse courier_proto::messages::StampRequiredPackage;\nuse courier_proto::{\n    messages::CourieredPackage::{self, Response, Stamped, Unstamped},\n    messages::ResponsePackage::HailstoneResponse,\n    messages::UnstampedPackage::HailstoneRequest,\n    read_msg,\n};\nuse std::io::{BufReader, BufWriter, Write};\nuse std::net::TcpStream;\n\nfn main() {\n    let courier_write = TcpStream::connect(\"127.0.0.1:42069\").unwrap();\n    let courier_read = courier_write.try_clone().unwrap();\n\n    let mut courier_write = BufWriter::new(courier_write);\n    let mut courier_read = BufReader::new(courier_read);\n\n    let mut max = 0;\n    for i in 0..4096 {\n        courier_proto::into_msg(Unstamped(HailstoneRequest(i)))\n            .try_for_each(|b| courier_write.write(&[b]).map(|_| ()))\n            .unwrap();\n        courier_write.flush().unwrap();\n\n        let resp: CourieredPackage = read_msg::<_, _, { u16::MAX }>(&mut courier_read).unwrap();\n        let Response(HailstoneResponse(hail)) = resp else { unreachable!() };\n        if hail > max {\n            max = hail;\n        }\n        println!(\"(max: {max}): {i} => {hail}\");\n    }\n\n    let stamped = courier_proto::stamps::stamp(\n        &mut 0,\n        include_bytes!(\"../../stamp.key\"),\n        StampRequiredPackage::FlagRequest,\n    )\n    .unwrap();\n    courier_proto::into_msg(Stamped(stamped))\n        .try_for_each(|b| courier_write.write(&[b]).map(|_| ()))\n        .unwrap();\n    courier_write.flush().unwrap();\n    let resp: CourieredPackage = read_msg::<_, _, { u16::MAX }>(&mut courier_read).unwrap();\n    let Response(FlagResponse(flag)) = resp else { unreachable!() };\n    println!(\"{}\", flag);\n}\n",
    "solution\\Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"atomic-polyfill\"\nversion = \"0.1.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e3ff7eb3f316534d83a8a2c3d1674ace8a5a71198eba31e2e2b597833f699b28\"\ndependencies = [\n \"critical-section\",\n]\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n\n[[package]]\nname = \"block-buffer\"\nversion = \"0.10.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71\"\ndependencies = [\n \"generic-array\",\n]\n\n[[package]]\nname = \"byteorder\"\nversion = \"1.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"cobs\"\nversion = \"0.2.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"67ba02a97a2bd10f4b59b25c7973101c79642302776489e030cd13cdab09ed15\"\n\n[[package]]\nname = \"courier-proto\"\nversion = \"0.1.0\"\ndependencies = [\n \"heapless\",\n \"hmac\",\n \"postcard\",\n \"serde\",\n \"sha2\",\n]\n\n[[package]]\nname = \"cpufeatures\"\nversion = \"0.2.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3e4c1eaa2012c47becbbad2ab175484c2a84d1185b566fb2cc5b8707343dfe58\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"critical-section\"\nversion = \"1.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6548a0ad5d2549e111e1f6a11a6c2e2d00ce6a3dafe22948d67c2b443f775e52\"\n\n[[package]]\nname = \"crypto-common\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\ndependencies = [\n \"generic-array\",\n \"typenum\",\n]\n\n[[package]]\nname = \"digest\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8168378f4e5023e7218c89c891c0fd8ecdb5e5e4f18cb78f38cf245dd021e76f\"\ndependencies = [\n \"block-buffer\",\n \"crypto-common\",\n \"subtle\",\n]\n\n[[package]]\nname = \"generic-array\"\nversion = \"0.14.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a\"\ndependencies = [\n \"typenum\",\n \"version_check\",\n]\n\n[[package]]\nname = \"hash32\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b0c35f58762feb77d74ebe43bdbc3210f09be9fe6742234d573bacc26ed92b67\"\ndependencies = [\n \"byteorder\",\n]\n\n[[package]]\nname = \"heapless\"\nversion = \"0.7.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"db04bc24a18b9ea980628ecf00e6c0264f3c1426dac36c00cb49b6fbad8b0743\"\ndependencies = [\n \"atomic-polyfill\",\n \"hash32\",\n \"rustc_version\",\n \"serde\",\n \"spin\",\n \"stable_deref_trait\",\n]\n\n[[package]]\nname = \"hmac\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e\"\ndependencies = [\n \"digest\",\n]\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.142\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6a987beff54b60ffa6d51982e1aa1146bc42f19bd26be28b0586f252fccf5317\"\n\n[[package]]\nname = \"lock_api\"\nversion = \"0.4.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"435011366fe56583b16cf956f9df0095b405b82d76425bc8981c0e22e60ec4df\"\ndependencies = [\n \"autocfg\",\n \"scopeguard\",\n]\n\n[[package]]\nname = \"postcard\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cfa512cd0d087cc9f99ad30a1bf64795b67871edbead083ffc3a4dfafa59aa00\"\ndependencies = [\n \"cobs\",\n \"heapless\",\n \"serde\",\n]\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.56\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2b63bdb0cd06f1f4dedf69b254734f9b45af66e4a031e42a7480257d9898b435\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.26\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4424af4bf778aae2051a77b60283332f386554255d722233d09fbfc7e30da2fc\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"rustc_version\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366\"\ndependencies = [\n \"semver\",\n]\n\n[[package]]\nname = \"scopeguard\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n\n[[package]]\nname = \"semver\"\nversion = \"1.0.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bebd363326d05ec3e2f532ab7660680f3b02130d780c299bca73469d521bc0ed\"\n\n[[package]]\nname = \"serde\"\nversion = \"1.0.160\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bb2f3770c8bce3bcda7e149193a069a0f4365bda1fa5cd88e03bca26afc1216c\"\ndependencies = [\n \"serde_derive\",\n]\n\n[[package]]\nname = \"serde_derive\"\nversion = \"1.0.160\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"291a097c63d8497e00160b166a967a4a79c64f3facdd01cbd7502231688d77df\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn\",\n]\n\n[[package]]\nname = \"sha2\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"82e6b795fe2e3b1e845bafcb27aa35405c4d47cdfc92af5fc8d3002f76cebdc0\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"digest\",\n]\n\n[[package]]\nname = \"solution\"\nversion = \"0.1.0\"\ndependencies = [\n \"courier-proto\",\n \"postcard\",\n]\n\n[[package]]\nname = \"spin\"\nversion = \"0.9.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67\"\ndependencies = [\n \"lock_api\",\n]\n\n[[package]]\nname = \"stable_deref_trait\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3\"\n\n[[package]]\nname = \"subtle\"\nversion = \"2.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6bdef32e8150c2a081110b42772ffe7d7c9032b606bc226c8260fd97e0976601\"\n\n[[package]]\nname = \"syn\"\nversion = \"2.0.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a34fcf3e8b60f57e6a14301a2e916d323af98b0ea63c599441eec8558660c822\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"typenum\"\nversion = \"1.16.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba\"\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e5464a87b239f13a63a501f2701565754bae92d243d4bb7eb12f6d57d2269bf4\"\n\n[[package]]\nname = \"version_check\"\nversion = \"0.9.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n",
    "solution\\Cargo.toml": "[workspace]\n# exclude\n\n[package]\nname = \"solution\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\ncourier-proto = { path = \"../courier-proto\", features = [\"stamps\", \"std\"] }\npostcard = { version = \"1.0\", features = [\"alloc\"] }\n",
    "solution\\src\\main.rs": "use courier_proto::messages::ResponsePackage::FlagResponse;\nuse courier_proto::messages::StampRequiredPackage::FlagRequest;\nuse courier_proto::messages::StampedPackage;\nuse courier_proto::{\n    messages::CourieredPackage::{self, Response, Stamped, Unstamped},\n    messages::UnstampedPackage::HailstoneRequest,\n    read_msg, MSG_MAGIC,\n};\nuse std::io::{BufReader, BufWriter, Write};\nuse std::net::TcpStream;\n\nfn main() {\n    let courier_write = TcpStream::connect(\"127.0.0.1:42069\").unwrap();\n    let courier_read = courier_write.try_clone().unwrap();\n\n    let mut courier_write = BufWriter::new(courier_write);\n    let mut courier_read = BufReader::new(courier_read);\n\n    let pretend = postcard::to_allocvec(&Unstamped(HailstoneRequest(1))).unwrap();\n    let smuggled = postcard::to_allocvec(&Stamped(StampedPackage {\n        ctr: 0,\n        hmac: [0; 32],\n        stamped_payload: postcard::to_allocvec(&FlagRequest).unwrap(),\n    }))\n    .unwrap();\n    let serialised = MSG_MAGIC\n        .iter()\n        .copied()\n        .chain((smuggled.len() as u16).to_be_bytes())\n        .chain(smuggled);\n\n    let message = MSG_MAGIC\n        .iter()\n        .copied()\n        .chain(((1 << 11) as u16).to_be_bytes())\n        .chain(pretend)\n        .chain(serialised)\n        .chain(std::iter::repeat(0).take(1 << 11))\n        .collect::<Vec<_>>();\n\n    courier_write.write_all(&message).unwrap();\n    courier_write.flush().unwrap();\n    let resp: CourieredPackage = read_msg::<_, _, { u16::MAX }>(&mut courier_read).unwrap();\n    let Response(FlagResponse(flag)) = resp else { unreachable!() };\n\n    println!(\"flag: {flag}\");\n}\n\n",
    "stamper\\Cargo.toml": "[package]\nname = \"stamper\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[features]\ndebug = [\"cortex-m-semihosting\", \"panic-semihosting\"]\n\n[dependencies]\ncortex-m = { version = \"0.7.6\", features = [\"critical-section-single-core\"] }\ncortex-m-rtic = \"1.1.3\"\ncortex-m-semihosting = { version = \"0.5.0\", optional = true }\ncourier-proto = { path = \"../courier-proto\", features = [\"stamps\"] }\nembedded-alloc = { git = \"https://github.com/rust-embedded/embedded-alloc.git\", rev = \"89cb8d50e6634130302cd444b3f547aed0fd32dc\" }\nlm3s6965 = { git = \"https://github.com/japaric/lm3s6965.git\", rev = \"facf63aa0169c773175a143f6014a1d0977fb74f\" }\nlm3s6965-uart = { path = \"../lm3s6965-uart\" }\npanic-semihosting = { version = \"0.6.0\", features = [\"exit\"], optional = true }\n",
    "stamper\\.cargo\\config.toml": "[target.thumbv7m-none-eabi]\nrunner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -serial tcp:127.0.0.1:1337,server,nodelay -kernel\"\n",
    "stamper\\src\\main.rs": "#![deny(unsafe_code)]\n#![deny(warnings)]\n#![allow(unused_variables)] // for featuring\n#![no_main]\n#![no_std]\n#![feature(alloc_error_handler)]\n\nextern crate alloc;\n\n#[cfg(feature = \"debug\")]\nuse cortex_m_semihosting::{\n    debug::{exit, EXIT_FAILURE},\n    heprintln,\n};\n#[cfg(feature = \"debug\")]\nuse panic_semihosting as _;\n\nuse core::alloc::Layout;\nuse embedded_alloc::Heap;\n\nconst HEAP_SIZE: usize = 1 << 14;\n\nconst STAMP_KEY: &[u8; 64] = include_bytes!(\"../../stamp.key\");\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n#[rtic::app(device = lm3s6965, dispatchers = [GPIOA, GPIOB])]\nmod app {\n    use crate::{HEAP, HEAP_SIZE, STAMP_KEY};\n    use alloc::vec::Vec;\n    #[cfg(feature = \"debug\")]\n    use cortex_m_semihosting::heprintln;\n    use courier_proto::messages::StampRequiredPackage;\n    use courier_proto::stamps::stamp;\n    use courier_proto::{into_msg, try_read_msg, ReadMsgError};\n    use lm3s6965_uart::{\n        ManageUART, ReadUART, UARTAddress, UARTPeripheral, UARTPeripheralManageHalf,\n        UARTPeripheralReadHalf, UARTPeripheralWriteHalf, WriteUART,\n    };\n\n    #[shared]\n    struct Shared {}\n\n    #[local]\n    struct Local {\n        sender_manage: UARTPeripheralManageHalf,\n        sender_rx: UARTPeripheralReadHalf,\n        sender_tx: UARTPeripheralWriteHalf,\n        stamp_ctr: usize,\n        next_msg: Option<StampRequiredPackage>,\n        rx_buf: Vec<u8>,\n    }\n\n    #[init]\n    #[allow(unsafe_code)]\n    fn init(_: init::Context) -> (Shared, Local, init::Monotonics) {\n        {\n            use core::mem::MaybeUninit;\n            static mut HEAP_MEM: [MaybeUninit<u8>; HEAP_SIZE] = [MaybeUninit::uninit(); HEAP_SIZE];\n            unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n        }\n\n        let (sender_manage, sender_rx, sender_tx) =\n            unsafe { UARTPeripheral::new(UARTAddress::UART0) }\n                .enable_transmit(true)\n                .enable_receive(true)\n                .enable_fifo(true)\n                .enable_break_interrupt(true)\n                .enable_receive_interrupt(true)\n                .finish()\n                .split();\n\n        (\n            Shared {},\n            Local {\n                sender_manage,\n                sender_rx,\n                sender_tx,\n                stamp_ctr: 0,\n                next_msg: None,\n                rx_buf: Vec::new(),\n            },\n            init::Monotonics(),\n        )\n    }\n\n    #[idle]\n    fn idle(_: idle::Context) -> ! {\n        loop {\n            cortex_m::asm::wfi(); // peacefully sleep *honk mimimimi*\n        }\n    }\n\n    #[task(binds = UART0, priority = 1, local = [sender_rx, next_msg, rx_buf])]\n    fn recv_msg(cx: recv_msg::Context) {\n        let next_msg = cx.local.next_msg;\n        if let Some(msg) = next_msg.take() {\n            if let Err(failed_msg) = send_msg::spawn(msg) {\n                *next_msg = Some(failed_msg);\n                return;\n            }\n        }\n\n        let uart = cx.local.sender_rx;\n        let rx_buf = cx.local.rx_buf;\n\n        while uart.rx_avail() {\n            let b = uart.readb().unwrap();\n            rx_buf.push(b);\n            match try_read_msg::<_, { 1 << 12 }, true>(rx_buf) {\n                Err(ReadMsgError::NotYetDone) => {}\n                Ok(msg) => {\n                    if let Err(msg) = send_msg::spawn(msg) {\n                        *next_msg = Some(msg);\n                        return;\n                    }\n                }\n                Err(e) => {\n                    #[cfg(feature = \"debug\")]\n                    heprintln!(\"error while processing: {:?}\", e);\n                }\n            }\n        }\n    }\n\n    #[task(priority = 2, capacity = 1, local = [sender_manage, sender_tx, stamp_ctr])]\n    fn send_msg(cx: send_msg::Context, msg: StampRequiredPackage) {\n        let stamp_ctr = cx.local.stamp_ctr;\n        let stamped = stamp(stamp_ctr, STAMP_KEY, msg).expect(\"Couldn't stamp message\");\n\n        let sender_manage = cx.local.sender_manage;\n        let sender_tx = cx.local.sender_tx;\n\n        sender_manage\n            .update_interrupts()\n            .update_transmit_interrupt(true)\n            .commit();\n\n        for b in into_msg(stamped) {\n            while !sender_tx.tx_avail() {\n                cortex_m::asm::wfi();\n            }\n            sender_tx.writeb(b);\n        }\n\n        sender_manage\n            .update_interrupts()\n            .update_transmit_interrupt(false)\n            .commit();\n    }\n}\n\n#[alloc_error_handler]\nfn oom(_: Layout) -> ! {\n    #[cfg(feature = \"debug\")]\n    heprintln!(\"Whoops! Ran out of memory while executing.\");\n    #[cfg(feature = \"debug\")]\n    exit(EXIT_FAILURE);\n\n    loop {\n        cortex_m::asm::nop();\n    }\n}\n\n#[cfg(not(feature = \"debug\"))]\n#[panic_handler]\nfn panic_handler(_: &core::panic::PanicInfo) -> ! {\n    loop {\n        cortex_m::asm::nop()\n    }\n}\n",
    "category": "embedded"
}