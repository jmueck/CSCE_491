{
    "Dockerfile": "FROM debian:buster-slim\n\nRUN apt-get update -y; apt-get install build-essential python3 -y\nADD flag-encryptor.c /flag-encryptor.c\nADD enc.py /enc.py\nADD flag_backup.png /flag.png\nCOPY ./tiny-AES-c /tiny-AES-c\nADD Makefile /Makefile\nRUN make all\n",
    "enc.py": "# This code is bad don't look at this\n# Encrypts a section and writes the key and size of encrypted section to a variable in the binary. \n# Usage: python3 enc.py <bin>\nimport secrets\nimport struct\nimport subprocess\nimport sys\n\ndef main():\n    elf_path = sys.argv[1]\n    x = subprocess.check_output(f'nm -S {elf_path}'.split(' ')).decode().split('\\n')\n    mprot_size_addr = 0\n    foo_size_addr = 0\n    key_addr = 0\n    foo_addr = 0\n    foo_size = 0\n\n    for row in x:\n        if 'T foo' in row:\n            parts = row.split(' ')\n            foo_addr = int(parts[0], 16)\n            foo_size = int(parts[1], 16)\n        if 'enc_key' in row:\n            key_addr = int(row.split(' ')[0], 16) - 0x1000\n        if 'mprot_size' in row:\n            mprot_size_addr = int(row.split(' ')[0], 16) - 0x1000\n        if 'foo_size' in row:\n            foo_size_addr = int(row.split(' ')[0], 16) - 0x1000\n\n    mprot_size = foo_size + (foo_addr - (foo_addr & 0xfffffffffffff000))\n\n    print(hex(mprot_size_addr), hex(foo_size_addr))\n    print(hex(foo_addr), hex(foo_size))\n    print(hex(key_addr))\n\n    key_len = 16\n    key = secrets.token_bytes(key_len)\n    elf = open(elf_path, 'rb+')\n    elf.seek(mprot_size_addr)\n    elf.write(struct.pack('<Q', mprot_size))\n    elf.seek(foo_size_addr)\n    elf.write(struct.pack('<Q', foo_size))\n    elf.seek(key_addr)\n    elf.write(key)\n    elf.seek(foo_addr)\n    foo_bytes = bytearray(elf.read(foo_size))\n\n    for i in range(foo_size):\n        foo_bytes[i] = foo_bytes[i] ^ key[i % key_len]\n\n    elf.seek(foo_addr)\n    elf.write(foo_bytes)\n\n\nmain()\n",
    "flag-encryptor.c": "#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include \"tiny-AES-c/aes.h\"\n\nunsigned long foo_size = 0x1122334455667788;\nunsigned long mprot_size = 0x1122334455667788;\nunsigned char enc_key[16] = \"AAAABBBBCCCCDDDD\";\n\nvoid __attribute__((section(\".foo\"))) foo() {\n    FILE *f = fopen(\"flag.png\", \"rb+\");\n    if (f == NULL) {\n        puts(\"No flag.png to encrypt :(\");\n        return;\n    }\n\n    if (fseek(f, 0, SEEK_END) == -1) {\n        perror(\"first fseek\");\n        return;\n    }\n    long f_size = ftell(f);\n    if (f_size == -1) {\n        perror(\"ftell\");\n        return;\n    }\n    f_size += (16 - (f_size%16));\n\n    unsigned char* buf = calloc(1, f_size);\n    if (buf == NULL) {\n        puts(\"calloc failed\");\n        return;\n    }\n    \n    if (fseek(f, 0, SEEK_SET) == -1) {\n        perror(\"second fseek\");\n        return;\n    }\n    fread(buf, f_size, 1, f);\n    \n    struct AES_ctx ctx;\n    AES_init_ctx(&ctx, enc_key);\n    for (long i = 0; i < f_size; i += 16) {\n        AES_ECB_encrypt(&ctx, buf+i);\n    }\n\n    if (fseek(f, 0, SEEK_SET) == -1) {\n        perror(\"third fseek\");\n        return;\n    }\n    fwrite(buf, f_size, 1, f);\n\n    exit(0);\n}\n\nvoid decrypt(unsigned char* bytes) {\n    for (unsigned long i = 0; i < foo_size; i++) {\n        bytes[i] ^= enc_key[i % 16];\n    }\n}\n\nvoid main () {\n    mprotect( (unsigned long)foo & 0xfffffffffffff000, mprot_size, PROT_READ|PROT_WRITE|PROT_EXEC); // Needs to be page aligned\n    decrypt((unsigned char*)foo);\n    foo();\n    return 0;\n}\n",
    "flag_backup.png": "[Binary file or unsupported type: png]",
    "Makefile": "NAME := flag-encryptor\n\nall: $(NAME).c\n\tgcc -o $(NAME) $(NAME).c tiny-AES-c/aes.c\n\tpython3 enc.py $(NAME)\n\tstrip $(NAME)\n\t./$(NAME)\n\ndist: Dockerfile\n\tdocker build -t $(NAME) .\n\tdocker run -d --name $(NAME) $(NAME)\n\tdocker cp $(NAME):/$(NAME) ./$(NAME)\n\tdocker cp $(NAME):/flag.png ./flag.png\n\tzip $(NAME).zip $(NAME) flag.png\n\nclean:\n\trm -f $(NAME).zip $(NAME) flag.png\n\tdocker rm -f $(NAME)\n\tdocker rmi $(NAME)\n",
    "README.md": "# Flag Encryptor\n\nAuthor: `anomie`\n\nThis program appears to look for a file `flag.png` and encrypts it.\n\n## Dev notes\nGiven files are `flag-encryptor` and `flag.png`. Acquire these files by running `make dist`\n\nTo initialize this so that `make dist` Just Works:tm:, run the following:\n```\ngit submodule init\ngit submodule update\n```\n\n## Solution\nLooking at the binary statically (stripped :pensive:), we can find the entry point in Ghidra by looking for references to `__libc_start_main`; the caller will pass the address of `main` as the first argument. `main` immediately calls `mprotect` with all protections enabled (`PROT_READ | PROT_WRITE | PROT_EXEC`), so the subsequent functions probably unpack code. After doing some basic exploration, we have the following:\n```c\nvoid decrypt_memory(byte *ptr) {\n    ulong i;\n\n    for (i = 0; i < 0x1c2; i = i + 1) {\n        ptr[i] = ptr[i] ^ XOR_KEY[(uint)i & 0xf];\n    }\n    return;\n}\n\nvoid main(void) {\n    mprotect((void *)0x2000,0x8a3,7);\n    decrypt_memory((byte *)encrypted_fun);\n    encrypted_fun();\n    return;\n}\n```\n\nTo take a closer look at the encrypted payload, let's look at this with dynamic analysis. Since PIE is on, we'll need to set breakpoints in `gdb` by first running the binary with `starti`, then breaking on the actual addresses with `b $_base() + <addr>`. After breaking just before the jump into the decrypted payload, we can dump the memory for further examination:\n```\ndump memory decrypted 0x005555555566e1 (0x005555555566e1 + 0x1c2)\n```\n\nTo look at the disassembly, I googled https://stackoverflow.com/questions/14290879/disassembling-a-flat-binary-file-using-objdump because I never remember the flags.\n```\nobjdump -D -Mintel,x86-64 -b binary -m i386 decrypted > out.s\n```\n\nHowever, looking at the disassembly is really terrible, so we'll load the decrypted instructions back into Ghidra to decompile it. To do this:\n\n1. Get the hexadecimal values of the decrypted instructions into a single line, and copy it to your clipboard:\n```\n> xxd -p -c 100000 decrypted\n554889e54881ece0000000488d3511090000488d3d0e090000e891e9ffff488945f048837df0007511488d3d00090000e81ae9ffffe986010000488b45f0ba02000000be000000004889c7e83fe9ffff83f8ff7511488d3dee080000e85ee9ffffe95a010000488b45f04889c7e80de9ffff488945e848837de8ff7511488d3dd2080000e836e9ffffe932010000488b45e8489948c1ea3c4801d083e00f4829d0ba100000004829c24889d0480145e8488b45e84889c6bf01000000e8aee8ffff488945e048837de0007511488d3d89080000e877e8ffffe9e3000000488b45f0ba00000000be000000004889c7e89ce8ffff83f8ff7511488d3d6b080000e8bbe8ffffe9b7000000488b75e8488b55f0488b45e04889d1ba010000004889c7e83ae8ffff488d8520ffffff488d357c2800004889c7e8e3ecffff48c745f800000000eb22488b55f8488b45e04801c2488d8520ffffff4889d64889c7e871fbffff488345f810488b45f8483b45e87cd4488b45f0ba00000000be000000004889c7e808e8ffff83f8ff750e488d3de4070000e827e8ffffeb26488b75e8488b55f0488b45e04889d1ba010000004889c7e829e8ffffbf00000000e80fe8ffffc9c3\n```\n2. Go to \"Window\", then select \"Script Manager\".\n3. Highlight the first byte (click and drag your cursor over the first 2 nibbles) within the listing that you want to start overwriting from.\n4. Switch over to the \"Script Manager\" window, then search for \"EditBytesScript.java\".\n5. Run the script by double-clicking the entry.\n6. Paste your clipboard when it prompts you with \"Replace bytes at cursor with\"; it will automatically separate the bytes within your input with whitespace.\n7. Click \"OK\".\n\nUnfortunately, when I did this, there were several errors in the disassembly (indicated by red \"X\" marks in the listing). To fix this, repeat the following for each error:\n\n1. Highlight the bytes to fix (refer to your output from `objdump` to determine the starting and ending bytes).\n2. Type \"c\" to clear the current disassembly for the bytes.\n3. Type \"d\" to disassemble the bytes again.\n\nAfter much laboring, here's the decompilation for the encrypted function:\n\n```c\nvoid encrypted_fun(void) {\n    int iVar1;\n    undefined auStack_e8 [192];\n    void *pvStack_28;\n    size_t sStack_20;\n    FILE *pFStack_18;\n    long lStack_10;\n\n    pFStack_18 = fopen(\"flag.png\",\"rb+\");\n    if (pFStack_18 == (FILE *)0x0) {\n        puts(\"No flag.png to encrypt :(\");\n    }\n    else {\n        iVar1 = fseek(pFStack_18,0,2);\n        if (iVar1 == -1) {\n            perror(\"first fseek\");\n        }\n        else {\n            sStack_20 = ftell(pFStack_18);\n            if (sStack_20 == -1) {\n                perror(\"ftell\");\n            }\n            else {\n                sStack_20 = sStack_20 + (0x10 - (long)sStack_20 % 0x10);\n                pvStack_28 = calloc(1,sStack_20);\n                if (pvStack_28 == (void *)0x0) {\n                    puts(\"calloc failed\");\n                }\n                else {\n                    iVar1 = fseek(pFStack_18,0,0);\n                    if (iVar1 == -1) {\n                        perror(\"second fseek\");\n                    }\n                    else {\n                        fread(pvStack_28,sStack_20,1,pFStack_18);\n                        FUN_000014ff(auStack_e8,XOR_KEY);\n                        for (lStack_10 = 0; lStack_10 < (long)sStack_20; lStack_10 = lStack_10 + 0x10) {\n                            FUN_000023b4(auStack_e8,lStack_10 + (long)pvStack_28);\n                        }\n                        iVar1 = fseek(pFStack_18,0,0);\n                        if (iVar1 != -1) {\n                            fwrite(pvStack_28,sStack_20,1,pFStack_18);\n                            /* WARNING: Subroutine does not return */\n                            exit(0);\n                        }\n                        perror(\"third fseek\");\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n```\n\nThis looks much nicer! This reads `flag.png` from the current working directory, then presumably encrypts the data section of the PNG. After exploring more of the functions, it's evident that the encryption algorithm is AES-128-ECB, where the encryption key is the XOR key used to decrypt the second stage. The biggest indicators are the lookup table for the substitution box (the first few bytes start with 0x63, 0x7C, 0x77, 0x7B, etc.) and the operation on chunks of 16 bytes at a time.\n```\nSBOX\n\n00003080 63              db         63h\n00003081 7c              db         7Ch\n00003082 77              db         77h\n00003083 7b              db         7Bh\n...\n```\n```c\nvoid sbox(uint8_t *param_1) {\n    byte j;\n    byte i;\n\n    for (i = 0; i < 4; i = i + 1) {\n        for (j = 0; j < 4; j = j + 1) {\n            param_1[(long)(int)(uint)i + (long)(int)(uint)j * 4] =\n                (&SBOX)[(int)(uint)param_1[(long)(int)(uint)i + (long)(int)(uint)j * 4]];\n        }\n    }\n    return;\n}\n```\n\nNow, we just need to decrypt the data within the image. To extract the key bytes from Ghidra, we can highlight the bytes of the key within the listing, click \"Copy Special...\", then select \"Python Byte String\". For decryption, we can use [PyCryptodome](https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html). The magic bytes are corrupted, so we'll start from the beginning of the file, then iterate in chunks of 16 bytes (we won't mess with any remaining bytes).\n```python\nfrom Crypto.Cipher import AES\nfrom pathlib import Path\n\nkey = b'\\xb1\\x88\\xdf\\xf7\\xac\\x59\\x24\\x97\\xcd\\xe2\\x18\\x9e\\xd4\\x53\\x92\\xe6'\ncipher = AES.new(key, AES.MODE_ECB)\nenc_img = Path(\"flag.png\").read_bytes()\ndec_img = bytearray()\nfor i in range(0, len(enc_img), 16):\n    dec_img += cipher.decrypt(enc_img[i:i + 16])\nPath(\"actual_flag.png\").write_bytes(dec_img)\n```\n\nViewing the decrypted image yields the flag!\n\nFlag: `gigem{its_encryption_all_the_way_down}`\n",
    "category": "rev"
}