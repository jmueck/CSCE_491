{
    "makefile": "CFLAGS = -z execstack -m32 -fno-stack-protector -masm=intel\nCC = gcc\nOUT = -o pizza\n\nall: pizza.o\n\t$(CC) $(CFLAGS) pizza.o $(OUT)\n\nsoup.o: pizza.c\n\t$(CC) $(CFLAGS) -c pizza.c\n\nclean:\n\trm pizza\n\trm *.o \n",
    "pizza.c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define XOR(A, B) A^B\n#define HEXLEN 100\n\nint main(int argc, char** argv)\n{\n    if(argc != 3){ return 1; }\n    if(strlen(argv[1]) != 5){ return 1; }\n\n    char newcode[] = {\n        0xd8,0xdf,0xc7,0xd4,0xc9,0xd8,0xdf,0xc7,0xd4,0xc9,\n        0xd8,0xdf,0xc7,0xd4,0xc9,0xd8,0xdf,0xc7,0xd4,0xc9,\n        0x47,0xf7,0x56,0x44,0x59,0x48,0xf4,0x57,0x44,0x59,\n        0x48,0x82,0xd7,0xad,0x47,0x48,0x4f,0x57,0xfc,0x5d,\n        0x48,0x4f,0x57,0xff,0x58,0x48,0x4f,0x57,0x1d,0xe3,\n        0x53,0x4f,0x57,0x44,0x94,0xc8,0xf7,0x56,0x44,0x59,\n        0x48,0xf4,0x57,0x44,0x59,0x48,0x82,0xd7,0xac,0x84,\n        0xb7,0xb0,0xa8,0x23,0x30,0x2f,0x2a,0x3a,0x3f,0x29,\n        0x78,0x7e,0x39,0x30,0x6a,0x3a,0x10,0x3a,0x25,0x3e,\n        0x79,0x2c,0x08,0x34,0x38,0x79,0x21,0x24,0x39,0x53\n    };\n\n    for(int i = 0; i < HEXLEN; i++){ newcode[i] = XOR(newcode[i], argv[1][i % 5]); }\n\n    int a = atoi(argv[2]);\n\n    char execcode[] = {\n        0x8d, 0x95, 0x7c, 0xff, 0xff, 0xff,\n        0x8b, 0x45, 0xe0,\n        0x01, 0xd0,\n        0xff, 0xd0,\n        0xb8, 0x00, 0x00, 0x00, 0x00\n    };\n\n    ((void(*)())(execcode))();\n}\n",
    "README.md": "# RE-do 3\n\n## Description\nThe lord is my shepard, I shall not want;\nBut my dreams this challenge will haunt.\n\nElegance and care put into its creation;\njust make sure to not fall into stagnation.\n\n## Solution\nI didn't feel like manually reversing too much, so I lifted the global data from Ghidra, then wrote a simple brute-forcer. Looking at the decompilation, we know that the first argument is 5 characters and gets repeatedly XORed against the global data, so I assumed there would eventually be a \"gigem\" somewhere in the output. I also assumed the input argument would be alphanumeric since it was a command-line argument .\n\n```rust\nstatic CODE: [u8; 100] = [\n    0xd8, 0xdf, 0xc7, 0xd4, 0xc9, 0xd8, 0xdf, 0xc7, 0xd4, 0xc9, 0xd8, 0xdf, 0xc7, 0xd4, 0xc9, 0xd8,\n    0xdf, 0xc7, 0xd4, 0xc9, 0x47, 0xf7, 0x56, 0x44, 0x59, 0x48, 0xf4, 0x57, 0x44, 0x59, 0x48, 0x82,\n    0xd7, 0xad, 0x47, 0x48, 0x4f, 0x57, 0xfc, 0x5d, 0x48, 0x4f, 0x57, 0xff, 0x58, 0x48, 0x4f, 0x57,\n    0x1d, 0xe3, 0x53, 0x4f, 0x57, 0x44, 0x94, 0xc8, 0xf7, 0x56, 0x44, 0x59, 0x48, 0xf4, 0x57, 0x44,\n    0x59, 0x48, 0x82, 0xd7, 0xac, 0x84, 0xb7, 0xb0, 0xa8, 0x23, 0x30, 0x2f, 0x2a, 0x3a, 0x3f, 0x29,\n    0x78, 0x7e, 0x39, 0x30, 0x6a, 0x3a, 0x10, 0x3a, 0x25, 0x3e, 0x79, 0x2c, 0x08, 0x34, 0x38, 0x79,\n    0x21, 0x24, 0x39, 0x53,\n];\nstatic ALPHA: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\nfn check(out: &mut [u8; 100], guess: &[u8; 5]) {\n    for (out_chunk, code_chunk) in out.chunks_exact_mut(5).zip(CODE.chunks_exact(5)) {\n        for ((code, out), guess) in code_chunk\n            .iter()\n            .copied()\n            .zip(out_chunk.iter_mut())\n            .zip(guess.iter().copied())\n        {\n            *out = code ^ guess;\n        }\n    }\n    if out.windows(5).any(|w| w == b\"gigem\") {\n        println!(\"{}\", String::from_utf8_lossy(out));\n        std::process::exit(0);\n    }\n}\nfn main() {\n    let mut out = [0u8; 100];\n    let mut bytes = [0u8; 5];\n    for &x in ALPHA {\n        bytes[0] = x;\n        for &x in ALPHA {\n            bytes[1] = x;\n            for &x in ALPHA {\n                bytes[2] = x;\n                for &x in ALPHA {\n                    bytes[3] = x;\n                    for &x in ALPHA {\n                        bytes[4] = x;\n                        check(&mut out, &bytes);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nFlag: `gigem{p01nt3r_mag1c_pa1ns}`\n",
    "category": "reversing"
}